{"text_input": "Generate Digest code for module.cpp", "output": "std::optional<component::Digest> OpenSSL::OpDigest(operation::Digest& op) {\n    std::optional<component::Digest> ret = std::nullopt;\n    Datasource ds(op.modifier.GetPtr(), op.modifier.GetSize());\n\n    util::Multipart parts;\n\n    CF_EVP_MD_CTX ctx(ds);\n    const EVP_MD* md = nullptr;\n\n    /* Initialize */\n    {\n        parts = util::ToParts(ds, op.cleartext);\n        CF_CHECK_NE(md = toEVPMD(op.digestType), nullptr);\n        CF_CHECK_EQ(EVP_DigestInit_ex(ctx.GetPtr(), md, nullptr), 1);\n    }\n\n    /* Process */\n    for (const auto& part : parts) {\n        CF_CHECK_EQ(EVP_DigestUpdate(ctx.GetPtr(), part.first, part.second), 1);\n    }\n\n    /* Finalize */\n    {\n        unsigned int len = -1;\n        unsigned char md[EVP_MAX_MD_SIZE];\n        CF_CHECK_EQ(EVP_DigestFinal_ex(ctx.GetPtr(), md, &len), 1);\n\n        ret = component::Digest(md, len);\n    }\n\nend:\n    return ret;\n}\n\n#if !defined(CRYPTOFUZZ_BORINGSSL) && !defined(CRYPTOFUZZ_OPENSSL_098)\n\n"}
{"text_input": "Generate HMAC_EVP code for module.cpp", "output": "std::optional<component::MAC> OpenSSL::OpHMAC_EVP(operation::HMAC& op, Datasource& ds) {\n    std::optional<component::MAC> ret = std::nullopt;\n\n    util::Multipart parts;\n\n    CF_EVP_MD_CTX ctx(ds);\n    const EVP_MD* md = nullptr;\n    EVP_PKEY *pkey = nullptr;\n\n    /* Initialize */\n    {\n        parts = util::ToParts(ds, op.cleartext);\n\n        CF_CHECK_NE(md = toEVPMD(op.digestType), nullptr);\n        CF_CHECK_NE(pkey = EVP_PKEY_new_mac_key(EVP_PKEY_HMAC, nullptr, op.cipher.key.GetPtr(), op.cipher.key.GetSize()), nullptr);\n        CF_CHECK_EQ(EVP_DigestSignInit(ctx.GetPtr(), nullptr, md, nullptr, pkey), 1);\n    }\n\n    /* Process */\n    for (const auto& part : parts) {\n        CF_CHECK_EQ(EVP_DigestSignUpdate(ctx.GetPtr(), part.first, part.second), 1);\n    }\n\n    /* Finalize */\n    {\n        size_t len = -1;\n        uint8_t out[EVP_MAX_MD_SIZE];\n        CF_CHECK_EQ(EVP_DigestSignFinal(ctx.GetPtr(), out, &len), 1);\n\n        ret = component::MAC(out, len);\n    }\n\nend:\n    EVP_PKEY_free(pkey);\n\n    return ret;\n}\n#endif\n\n#if !defined(CRYPTOFUZZ_OPENSSL_102) && !defined(CRYPTOFUZZ_OPENSSL_098)\n\n"}
{"text_input": "Generate HMAC_HMAC code for module.cpp", "output": "std::optional<component::MAC> OpenSSL::OpHMAC_HMAC(operation::HMAC& op, Datasource& ds) {\n    std::optional<component::MAC> ret = std::nullopt;\n\n    util::Multipart parts;\n\n    CF_HMAC_CTX ctx(ds);\n    const EVP_MD* md = nullptr;\n\n    /* Initialize */\n    {\n        parts = util::ToParts(ds, op.cleartext);\n        /* TODO remove ? */\n        HMAC_CTX_reset(ctx.GetPtr());\n        CF_CHECK_NE(md = toEVPMD(op.digestType), nullptr);\n        CF_CHECK_EQ(HMAC_Init_ex(ctx.GetPtr(), op.cipher.key.GetPtr(), op.cipher.key.GetSize(), md, nullptr), 1);\n    }\n\n    /* Process */\n    for (const auto& part : parts) {\n        CF_CHECK_EQ(HMAC_Update(ctx.GetPtr(), part.first, part.second), 1);\n    }\n\n    /* Finalize */\n    {\n        unsigned int len = -1;\n        uint8_t out[EVP_MAX_MD_SIZE];\n        CF_CHECK_EQ(HMAC_Final(ctx.GetPtr(), out, &len), 1);\n\n        ret = component::MAC(out, len);\n    }\n\nend:\n    return ret;\n}\n#endif\n\n#if !defined(CRYPTOFUZZ_OPENSSL_098)\n\n"}
{"text_input": "Generate HMAC code for module.cpp", "output": "std::optional<component::MAC> OpenSSL::OpHMAC(operation::HMAC& op) {\n    Datasource ds(op.modifier.GetPtr(), op.modifier.GetSize());\n\n    if (    op.digestType.Get() == CF_DIGEST(\"SIPHASH64\") ||\n            op.digestType.Get() == CF_DIGEST(\"SIPHASH128\") ) {\n        /* Not HMAC but invoking SipHash here anyway due to convenience. */\n        return OpenSSL_detail::SipHash(op);\n    }\n\n    bool useEVP = true;\n    try {\n        useEVP = ds.Get<bool>();\n    } catch ( fuzzing::datasource::Datasource::OutOfData& ) {\n    }\n\n    if ( useEVP == true ) {\n#if !defined(CRYPTOFUZZ_BORINGSSL)\n        return OpHMAC_EVP(op, ds);\n#else\n        return OpHMAC_HMAC(op, ds);\n#endif\n    } else {\n#if !defined(CRYPTOFUZZ_OPENSSL_102) && !defined(CRYPTOFUZZ_OPENSSL_098)\n        return OpHMAC_HMAC(op, ds);\n#else\n        return OpHMAC_EVP(op, ds);\n#endif\n    }\n}\n#endif\n\n#if !defined(CRYPTOFUZZ_BORINGSSL)\n\n"}
{"text_input": "Generate SymmetricEncrypt_BIO code for module.cpp", "output": "std::optional<component::Ciphertext> OpenSSL::OpSymmetricEncrypt_BIO(operation::SymmetricEncrypt& op, Datasource& ds) {\n    (void)ds;\n\n    std::optional<component::Ciphertext> ret = std::nullopt;\n\n    /* No support for AEAD tags and AAD with BIO */\n    if ( op.tagSize != std::nullopt || op.aad != std::nullopt ) {\n        return ret;\n    }\n\n#if defined(CRYPTOFUZZ_OPENSSL_102)\n    /* WRAP ciphers crash in OpenSSL 1.0.2 */\n    if ( repository::IsWRAP(op.cipher.cipherType.Get()) ) {\n        return ret;\n    }\n#endif\n\n    util::Multipart parts;\n\n    const EVP_CIPHER* cipher = nullptr;\n    BIO* bio_cipher = nullptr;\n\n    uint8_t* out = util::malloc(op.ciphertextSize);\n\n    /* Initialization */\n    {\n        CF_CHECK_NE(cipher = toEVPCIPHER(op.cipher.cipherType), nullptr);\n\n        /* TODO set key/iv size? */\n        CF_CHECK_EQ(static_cast<int>(op.cipher.key.GetSize()), EVP_CIPHER_key_length(cipher));\n        CF_CHECK_EQ(static_cast<int>(op.cipher.iv.GetSize()), EVP_CIPHER_iv_length(cipher));\n\n        CF_CHECK_NE(bio_cipher = BIO_new(BIO_f_cipher()), nullptr);\n#if !defined(CRYPTOFUZZ_OPENSSL_102) && !defined(CRYPTOFUZZ_OPENSSL_098)\n        /* In OpenSSL 1.0.2 and 0.9.8, BIO_set_cipher does not return a value */\n        CF_CHECK_EQ(\n#endif\n                BIO_set_cipher(bio_cipher, cipher, op.cipher.key.GetPtr(), op.cipher.iv.GetPtr(), 1 /* encrypt */)\n#if !defined(CRYPTOFUZZ_OPENSSL_102) && !defined(CRYPTOFUZZ_OPENSSL_098)\n        , 1)\n#endif\n           ;\n    }\n\n    /* Process */\n    {\n#if defined(CRYPTOFUZZ_OPENSSL_098)\n        BIO_push(bio_cipher, BIO_new_mem_buf((void*)op.cleartext.GetPtr(), op.cleartext.GetSize()));\n#else\n        BIO_push(bio_cipher, BIO_new_mem_buf(op.cleartext.GetPtr(), op.cleartext.GetSize()));\n#endif\n        //CF_CHECK_EQ(BIO_write(bio_out, op.cleartext.GetPtr(), op.cleartext.GetSize()), static_cast<int>(op.cleartext.GetSize()));\n    }\n\n    /* Finalize */\n    {\n        int num;\n        CF_CHECK_GTE(num = BIO_read(bio_cipher, out, op.ciphertextSize), 0);\n\n        CF_ASSERT(\n                num <= (int)op.ciphertextSize,\n                \"BIO_read reports more written bytes than the buffer can hold\");\n\n        {\n            /* Check if more data can be read. If yes, then the buffer is too small.\n             * BIO_eof doesn't seem to work as expected here. */\n            int num2;\n            uint8_t out2[1];\n            CF_CHECK_EQ(num2 = BIO_read(bio_cipher, out2, sizeof(out2)), 0);\n        }\n\n        /* Currently disabled to due length/padding mismatches with EVP, which are not necessarily OpenSSL's fault.\n         * (needs researching)\n         */\n        //ret = component::Ciphertext(Buffer(out, num));\n    }\n\nend:\n    BIO_free_all(bio_cipher);\n    util::free(out);\n\n    return ret;\n}\n#endif\n\n\n"}
{"text_input": "Generate SymmetricEncrypt_EVP code for module.cpp", "output": "std::optional<component::Ciphertext> OpenSSL::OpSymmetricEncrypt_EVP(operation::SymmetricEncrypt& op, Datasource& ds) {\n    std::optional<component::Ciphertext> ret = std::nullopt;\n\n    util::Multipart partsCleartext, partsAAD;\n\n    const EVP_CIPHER* cipher = nullptr;\n    CF_EVP_CIPHER_CTX ctx(ds);\n\n    size_t out_size = op.ciphertextSize;\n    size_t outIdx = 0;\n    uint8_t* out = util::malloc(out_size);\n    uint8_t* outTag = op.tagSize != std::nullopt ? util::malloc(*op.tagSize) : nullptr;\n\n    /* Initialize */\n    {\n        CF_CHECK_NE(cipher = toEVPCIPHER(op.cipher.cipherType), nullptr);\n        if ( op.tagSize != std::nullopt || op.aad != std::nullopt ) {\n            /* Trying to treat non-AEAD with AEAD-specific features (tag, aad)\n             * leads to all kinds of gnarly memory bugs in OpenSSL.\n             * It is quite arguably misuse of the OpenSSL API, so don't do this.\n             */\n            CF_CHECK_EQ(isAEAD(cipher, op.cipher.cipherType.Get()), true);\n        }\n\n        if ( repository::IsWRAP(op.cipher.cipherType.Get()) ) {\n#if defined(CRYPTOFUZZ_OPENSSL_098)\n            goto end;\n#else\n            /* noret */ EVP_CIPHER_CTX_set_flags(ctx.GetPtr(), EVP_CIPHER_CTX_FLAG_WRAP_ALLOW);\n#endif\n        }\n        CF_CHECK_EQ(EVP_EncryptInit_ex(ctx.GetPtr(), cipher, nullptr, nullptr, nullptr), 1);\n\n        if ( repository::IsWRAP(op.cipher.cipherType.Get()) ) {\n            partsCleartext = util::Multipart{ {op.cleartext.GetPtr(), op.cleartext.GetSize()} };\n        } else {\n            /* Convert cleartext to parts */\n            partsCleartext = util::CipherInputTransform(ds, op.cipher.cipherType, out, out_size, op.cleartext.GetPtr(), op.cleartext.GetSize());\n        }\n\n        if ( op.aad != std::nullopt ) {\n            if ( repository::IsCCM( op.cipher.cipherType.Get() ) ) {\n                /* CCM does not support chunked AAD updating.\n                 * See: https://wiki.openssl.org/index.php/EVP_Authenticated_Encryption_and_Decryption#Authenticated_Encryption_using_CCM_mode\n                 */\n                partsAAD = { {op.aad->GetPtr(), op.aad->GetSize()} };\n            } else {\n                partsAAD = util::ToParts(ds, *(op.aad));\n            }\n        }\n\n        if ( op.cipher.cipherType.Get() != CF_CIPHER(\"CHACHA20\") ) {\n            CF_CHECK_EQ(checkSetIVLength(op.cipher.cipherType.Get(), cipher, ctx.GetPtr(), op.cipher.iv.GetSize()), true);\n        } else {\n            CF_CHECK_EQ(op.cipher.iv.GetSize(), 12);\n        }\n        CF_CHECK_EQ(checkSetKeyLength(cipher, ctx.GetPtr(), op.cipher.key.GetSize()), true);\n\n        if ( op.cipher.cipherType.Get() != CF_CIPHER(\"CHACHA20\") ) {\n            CF_CHECK_EQ(EVP_EncryptInit_ex(ctx.GetPtr(), nullptr, nullptr, op.cipher.key.GetPtr(), op.cipher.iv.GetPtr()), 1);\n        } else {\n            /* Prepend the 32 bit counter (which is 0) to the iv */\n            uint8_t cc20IV[16];\n            memset(cc20IV, 0, 4);\n            memcpy(cc20IV + 4, op.cipher.iv.GetPtr(), op.cipher.iv.GetSize());\n            CF_CHECK_EQ(EVP_EncryptInit_ex(ctx.GetPtr(), nullptr, nullptr, op.cipher.key.GetPtr(), cc20IV), 1);\n        }\n\n        /* Disable ECB padding for consistency with mbed TLS */\n        if ( repository::IsECB(op.cipher.cipherType.Get()) ) {\n            CF_CHECK_EQ(EVP_CIPHER_CTX_set_padding(ctx.GetPtr(), 0), 1);\n        }\n    }\n\n    /* Process */\n    {\n        /* If the cipher is CCM, the total cleartext size needs to be indicated explicitly\n         * https://wiki.openssl.org/index.php/EVP_Authenticated_Encryption_and_Decryption\n         */\n        if ( repository::IsCCM(op.cipher.cipherType.Get()) == true ) {\n            int len;\n            CF_CHECK_EQ(EVP_EncryptUpdate(ctx.GetPtr(), nullptr, &len, nullptr, op.cleartext.GetSize()), 1);\n        }\n\n        /* Set AAD */\n        if ( op.aad != std::nullopt ) {\n\n            for (const auto& part : partsAAD) {\n                int len;\n                CF_CHECK_EQ(EVP_EncryptUpdate(ctx.GetPtr(), nullptr, &len, part.first, part.second), 1);\n            }\n        }\n\n        for (const auto& part : partsCleartext) {\n            if ( repository::IsWRAP(op.cipher.cipherType.Get()) ) {\n                /* WRAP ciphers don't honor the default rule */\n                CF_CHECK_GTE(out_size, part.second + EVP_CIPHER_block_size(cipher));\n            } else {\n                /* \"the amount of data written may be anything from zero bytes to (inl + cipher_block_size - 1)\" */\n                CF_CHECK_GTE(out_size, part.second + EVP_CIPHER_block_size(cipher) - 1);\n            }\n\n            int len = -1;\n            CF_CHECK_EQ(EVP_EncryptUpdate(ctx.GetPtr(), out + outIdx, &len, part.first, part.second), 1);\n            outIdx += len;\n            out_size -= len;\n        }\n    }\n\n    /* Finalize */\n    {\n        CF_CHECK_GTE(out_size, static_cast<size_t>(EVP_CIPHER_block_size(cipher)));\n\n        int len = -1;\n        CF_CHECK_EQ(EVP_EncryptFinal_ex(ctx.GetPtr(), out + outIdx, &len), 1);\n        outIdx += len;\n\n        if ( op.tagSize != std::nullopt ) {\n#if !defined(CRYPTOFUZZ_LIBRESSL) && !defined(CRYPTOFUZZ_OPENSSL_102) && !defined(CRYPTOFUZZ_OPENSSL_098)\n            /* Get tag.\n             *\n             * See comments around EVP_CTRL_AEAD_SET_TAG in OpSymmetricDecrypt_EVP for reasons\n             * as to why this is disabled for LibreSSL.\n             */\n            CF_CHECK_EQ(EVP_CIPHER_CTX_ctrl(ctx.GetPtr(), EVP_CTRL_AEAD_GET_TAG, *op.tagSize, outTag), 1);\n            ret = component::Ciphertext(Buffer(out, outIdx), Buffer(outTag, *op.tagSize));\n#endif\n        } else {\n            ret = component::Ciphertext(Buffer(out, outIdx));\n        }\n    }\n\nend:\n\n    util::free(out);\n    util::free(outTag);\n\n    return ret;\n}\n\n#if defined(CRYPTOFUZZ_BORINGSSL) || defined(CRYPTOFUZZ_LIBRESSL)\nstd::optional<component::Ciphertext> OpenSSL::AEAD_Encrypt(operation::SymmetricEncrypt& op, Datasource& ds) {\n    (void)ds;\n\n    std::optional<component::Ciphertext> ret = std::nullopt;\n\n    const EVP_AEAD* aead = nullptr;\n    EVP_AEAD_CTX* ctx = nullptr;\n    size_t len;\n\n    size_t out_size = op.ciphertextSize;\n    uint8_t* out = util::malloc(out_size);\n\n    const size_t tagSize = op.tagSize != std::nullopt ? *op.tagSize : 0;\n\n    /* Initialize */\n    {\n        CF_CHECK_NE(aead = toEVPAEAD(op.cipher.cipherType), nullptr);\n#if defined(CRYPTOFUZZ_LIBRESSL)\n\t\tCF_CHECK_NE(ctx = EVP_AEAD_CTX_new(), nullptr);\n        CF_CHECK_NE(EVP_AEAD_CTX_init(\n                    ctx,\n                    aead,\n                    op.cipher.key.GetPtr(),\n                    op.cipher.key.GetSize(),\n                    tagSize,\n                    nullptr), 0);\n#else /* CRYPTOFUZZ_BORINGSSL */\n        CF_CHECK_NE(ctx = EVP_AEAD_CTX_new(\n                    aead,\n                    op.cipher.key.GetPtr(),\n                    op.cipher.key.GetSize(),\n                    tagSize), nullptr);\n#endif\n    }\n\n    /* Process */\n    {\n        CF_CHECK_NE(EVP_AEAD_CTX_seal(ctx,\n                    out,\n                    &len,\n                    out_size,\n                    op.cipher.iv.GetPtr(),\n                    op.cipher.iv.GetSize(),\n                    op.cleartext.GetPtr(),\n                    op.cleartext.GetSize(),\n                    op.aad != std::nullopt ? op.aad->GetPtr() : nullptr,\n                    op.aad != std::nullopt ? op.aad->GetSize() : 0),\n                0);\n    }\n\n    /* Finalize */\n    {\n        size_t tagSize2 = tagSize;\n#if defined(CRYPTOFUZZ_BORINGSSL)\n        if ( tagSize == 0 ) {\n            CF_CHECK_EQ(EVP_AEAD_CTX_tag_len(ctx, &tagSize2, op.cleartext.GetSize(), 0), 1);\n        }\n#elif defined(CRYPTOFUZZ_LIBRESSL)\n        /* LibreSSL does not have EVP_AEAD_CTX_tag_len */\n        CF_CHECK_NE(tagSize, 0);\n#endif\n\n        /* The tag should be part of the output.\n         * Hence, the total output size should be equal or greater than the tag size.\n         * Note that removing this check will lead to an overflow below. */\n        CF_ASSERT(op.cleartext.GetSize() + tagSize2 == len, \"input + tag size != output length\");\n\n        if ( tagSize != 0 ) {\n            const size_t ciphertextSize = len - tagSize2;\n            ret = component::Ciphertext(Buffer(out, ciphertextSize), Buffer(out + ciphertextSize, tagSize));\n        } else {\n            /* Do not set ret if tag size is 0; the AEAD API cannot decrypt inputs whose tag size is 0,\n             * because it interprets a tag size of 0 as the default tag size\n             */\n        }\n    }\n\nend:\n    CF_NORET(EVP_AEAD_CTX_free(ctx));\n\n    util::free(out);\n\n    return ret;\n}\n#endif\n\nstd::optional<component::Ciphertext> OpenSSL::AES_Encrypt(operation::SymmetricEncrypt& op, Datasource& ds) {\n    (void)ds;\n\n    std::optional<component::Ciphertext> ret = std::nullopt;\n\n    AES_KEY key;\n    uint8_t* out = nullptr;\n\n    /* Initialize */\n    {\n        CF_CHECK_EQ(op.aad, std::nullopt);\n        CF_CHECK_EQ(op.tagSize, std::nullopt);\n        CF_CHECK_EQ(op.cipher.iv.GetSize(), 0);\n        CF_CHECK_GT(op.cleartext.GetSize(), 0);\n        CF_CHECK_GTE(op.ciphertextSize, op.cleartext.GetSize());\n        CF_CHECK_EQ(op.cleartext.GetSize() % 16, 0);\n        CF_CHECK_EQ(AES_set_encrypt_key(op.cipher.key.GetPtr(), op.cipher.key.GetSize() * 8, &key), 0);\n    }\n\n    /* Process */\n    {\n#if 0\n        bool useOverlap = false;\n        uint64_t cleartextIndex;\n        try {\n            bool _useOverlap = ds.Get<bool>();\n            if ( _useOverlap == true ) {\n                cleartextIndex = ds.Get<uint64_t>() % op.cleartext.GetSize();\n                useOverlap = true;\n            }\n        } catch ( fuzzing::datasource::Datasource::OutOfData& ) {\n        }\n\n        if ( useOverlap == true ) {\n            /* in and out are allowed to overlap */\n            out = (uint8_t*)malloc(op.cleartext.GetSize() + cleartextIndex);\n            memcpy(out + cleartextIndex, op.cleartext.GetPtr(), op.cleartext.GetSize());\n\n            for (size_t i = 0; i < op.cleartext.GetSize(); i += 16) {\n                AES_encrypt(out + cleartextIndex + i, out + i, &key);\n            }\n        } else\n#endif\n        {\n            out = (uint8_t*)malloc(op.ciphertextSize);\n\n            for (size_t i = 0; i < op.cleartext.GetSize(); i += 16) {\n                AES_encrypt(op.cleartext.GetPtr() + i, out + i, &key);\n            }\n        }\n    }\n\n    /* Finalize */\n    {\n        ret = component::Ciphertext(Buffer(out, op.cleartext.GetSize()));\n    }\n\nend:\n\n    free(out);\n\n    return ret;\n}\n\n\n"}
{"text_input": "Generate SymmetricEncrypt code for module.cpp", "output": "std::optional<component::Ciphertext> OpenSSL::OpSymmetricEncrypt(operation::SymmetricEncrypt& op) {\n#if defined(CRYPTOFUZZ_LIBRESSL)\n    /* LibreSSL will encrypt, but not decrypt, CHACHA20_POLY1305 with empty tag.\n     * See also https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=52890\n     */\n    if ( op.cipher.cipherType.Is(CF_CIPHER(\"CHACHA20_POLY1305\")) ) {\n        if ( op.tagSize == std::nullopt ) {\n            return std::nullopt;\n        }\n        if ( *op.tagSize == 0 ) {\n            return std::nullopt;\n        }\n    }\n#endif\n\n    Datasource ds(op.modifier.GetPtr(), op.modifier.GetSize());\n\n    if ( op.cipher.cipherType.Get() == CF_CIPHER(\"AES\") ) {\n        return AES_Encrypt(op, ds);\n    }\n\n#if defined(CRYPTOFUZZ_OPENSSL_110)\n    if ( repository::IsCCM( op.cipher.cipherType.Get() ) ) {\n        return std::nullopt;\n    }\n#endif\n\n#if defined(CRYPTOFUZZ_OPENSSL_102) || defined(CRYPTOFUZZ_OPENSSL_110)\n    /* Prevent OOB write for large keys in RC5.\n     * Fixed in OpenSSL master, but will not be fixed for OpenSSL 1.0.2 and 1.1.0\n     */\n    if ( op.cipher.key.GetSize() > 255 ) {\n        switch ( op.cipher.cipherType.Get() ) {\n            case CF_CIPHER(\"RC5_32_12_16_ECB\"):\n            case CF_CIPHER(\"RC5_32_12_16_CFB\"):\n            case CF_CIPHER(\"RC5_32_12_16_OFB\"):\n            case CF_CIPHER(\"RC5_32_12_16_CBC\"):\n                return std::nullopt;\n        }\n    }\n#endif\n\n    bool useEVP = true;\n    try {\n        useEVP = ds.Get<bool>();\n    } catch ( fuzzing::datasource::Datasource::OutOfData& ) {\n    }\n\n#if defined(CRYPTOFUZZ_BORINGSSL) || defined(CRYPTOFUZZ_LIBRESSL)\n    if ( toEVPAEAD(op.cipher.cipherType) != nullptr ) {\n        try {\n            if ( ds.Get<bool>() == true ) {\n                return AEAD_Encrypt(op, ds);\n            }\n\n            /* Fall through to OpSymmetricEncrypt_EVP/OpSymmetricEncrypt_BIO */\n\n        } catch ( fuzzing::datasource::Datasource::OutOfData& ) { }\n    }\n#endif\n\n    if ( useEVP == true ) {\n        return OpSymmetricEncrypt_EVP(op, ds);\n    } else {\n#if !defined(CRYPTOFUZZ_BORINGSSL)\n        return OpSymmetricEncrypt_BIO(op, ds);\n#else\n        return OpSymmetricEncrypt_EVP(op, ds);\n#endif\n    }\n}\n\n#if !defined(CRYPTOFUZZ_BORINGSSL)\n\n"}
{"text_input": "Generate SymmetricDecrypt_BIO code for module.cpp", "output": "std::optional<component::Cleartext> OpenSSL::OpSymmetricDecrypt_BIO(operation::SymmetricDecrypt& op, Datasource& ds) {\n    (void)ds;\n\n    std::optional<component::Cleartext> ret = std::nullopt;\n\n    /* No support for AEAD tags and AAD with BIO */\n    if ( op.aad != std::nullopt || op.tag != std::nullopt ) {\n        return ret;\n    }\n\n#if defined(CRYPTOFUZZ_OPENSSL_102)\n    /* WRAP ciphers crash in OpenSSL 1.0.2 */\n    if ( repository::IsWRAP(op.cipher.cipherType.Get()) ) {\n        return ret;\n    }\n#endif\n\n    util::Multipart parts;\n\n    const EVP_CIPHER* cipher = nullptr;\n    BIO* bio_cipher = nullptr;\n\n    uint8_t* out = util::malloc(op.cleartextSize);\n\n    /* Initialization */\n    {\n        CF_CHECK_NE(cipher = toEVPCIPHER(op.cipher.cipherType), nullptr);\n\n        /* TODO set key/iv size? */\n        CF_CHECK_EQ(static_cast<int>(op.cipher.key.GetSize()), EVP_CIPHER_key_length(cipher));\n        CF_CHECK_EQ(static_cast<int>(op.cipher.iv.GetSize()), EVP_CIPHER_iv_length(cipher));\n\n        CF_CHECK_NE(bio_cipher = BIO_new(BIO_f_cipher()), nullptr);\n#if !defined(CRYPTOFUZZ_OPENSSL_102) && !defined(CRYPTOFUZZ_OPENSSL_098)\n        /* In OpenSSL 1.0.2, BIO_set_cipher does not return a value */\n        CF_CHECK_EQ(\n#endif\n                BIO_set_cipher(bio_cipher, cipher, op.cipher.key.GetPtr(), op.cipher.iv.GetPtr(), 0 /* decrypt */)\n#if !defined(CRYPTOFUZZ_OPENSSL_102) && !defined(CRYPTOFUZZ_OPENSSL_098)\n        , 1)\n#endif\n           ;\n    }\n\n    /* Process */\n    {\n#if defined(CRYPTOFUZZ_OPENSSL_098)\n        BIO_push(bio_cipher, BIO_new_mem_buf((void*)op.ciphertext.GetPtr(), op.ciphertext.GetSize()));\n#else\n        BIO_push(bio_cipher, BIO_new_mem_buf(op.ciphertext.GetPtr(), op.ciphertext.GetSize()));\n#endif\n        //CF_CHECK_EQ(BIO_write(bio_out, op.cleartext.GetPtr(), op.cleartext.GetSize()), static_cast<int>(op.cleartext.GetSize()));\n    }\n\n    /* Finalize */\n    {\n        int num;\n        CF_CHECK_GTE(num = BIO_read(bio_cipher, out, op.cleartextSize), 0);\n\n        CF_ASSERT(\n                num <= (int)op.cleartextSize,\n                \"BIO_read reports more written bytes than the buffer can hold\");\n\n        {\n            /* Check if more data can be read. If yes, then the buffer is too small.\n             * BIO_eof doesn't seem to work as expected here. */\n            int num2;\n            uint8_t out2[1];\n            CF_CHECK_EQ(num2 = BIO_read(bio_cipher, out2, sizeof(out2)), 0);\n        }\n\n        /* Currently disabled to due length/padding mismatches with EVP, which are not necessarily OpenSSL's fault.\n         * (needs researching)\n         */\n        //ret = component::Cleartext(out, num);\n    }\n\nend:\n    BIO_free_all(bio_cipher);\n    util::free(out);\n\n    return ret;\n}\n#endif\n\n\n"}
{"text_input": "Generate SymmetricDecrypt_EVP code for module.cpp", "output": "std::optional<component::Cleartext> OpenSSL::OpSymmetricDecrypt_EVP(operation::SymmetricDecrypt& op, Datasource& ds) {\n    std::optional<component::Cleartext> ret = std::nullopt;\n\n    util::Multipart partsCiphertext, partsAAD;\n\n    const EVP_CIPHER* cipher = nullptr;\n    CF_EVP_CIPHER_CTX ctx(ds);\n\n    size_t out_size = op.cleartextSize;\n    size_t outIdx = 0;\n    uint8_t* out = util::malloc(out_size);\n\n    /* Initialize */\n    {\n        CF_CHECK_NE(cipher = toEVPCIPHER(op.cipher.cipherType), nullptr);\n        if ( op.tag != std::nullopt || op.aad != std::nullopt ) {\n            /* Trying to treat non-AEAD with AEAD-specific features (tag, aad)\n             * leads to all kinds of gnarly memory bugs in OpenSSL.\n             * It is quite arguably misuse of the OpenSSL API, so don't do this.\n             */\n            CF_CHECK_EQ(isAEAD(cipher, op.cipher.cipherType.Get()), true);\n        }\n\n        if ( repository::IsWRAP(op.cipher.cipherType.Get()) ) {\n#if defined(CRYPTOFUZZ_OPENSSL_098)\n            goto end;\n#else\n            /* noret */ EVP_CIPHER_CTX_set_flags(ctx.GetPtr(), EVP_CIPHER_CTX_FLAG_WRAP_ALLOW);\n#endif\n        }\n\n        CF_CHECK_EQ(EVP_DecryptInit_ex(ctx.GetPtr(), cipher, nullptr, nullptr, nullptr), 1);\n\n        if ( repository::IsWRAP(op.cipher.cipherType.Get()) ) {\n            partsCiphertext = util::Multipart{ {op.ciphertext.GetPtr(), op.ciphertext.GetSize()} };\n        } else {\n            /* Convert ciphertext to parts */\n            partsCiphertext = util::CipherInputTransform(ds, op.cipher.cipherType, out, out_size, op.ciphertext.GetPtr(), op.ciphertext.GetSize());\n        }\n\n        if ( op.aad != std::nullopt ) {\n            if ( repository::IsCCM( op.cipher.cipherType.Get() ) ) {\n                /* CCM does not support chunked AAD updating.\n                 * See: https://wiki.openssl.org/index.php/EVP_Authenticated_Encryption_and_Decryption#Authenticated_Encryption_using_CCM_mode\n                 */\n                partsAAD = { {op.aad->GetPtr(), op.aad->GetSize()} };\n            } else {\n                partsAAD = util::ToParts(ds, *(op.aad));\n            }\n        }\n\n        if ( op.cipher.cipherType.Get() != CF_CIPHER(\"CHACHA20\") ) {\n            CF_CHECK_EQ(checkSetIVLength(op.cipher.cipherType.Get(), cipher, ctx.GetPtr(), op.cipher.iv.GetSize()), true);\n        } else {\n            CF_CHECK_EQ(op.cipher.iv.GetSize(), 12);\n        }\n        CF_CHECK_EQ(checkSetKeyLength(cipher, ctx.GetPtr(), op.cipher.key.GetSize()), true);\n\n#if !defined(CRYPTOFUZZ_LIBRESSL) && !defined(CRYPTOFUZZ_OPENSSL_102) && !defined(CRYPTOFUZZ_OPENSSL_098)\n        /* Set tag.\n         *\n         * LibreSSL supports setting the tag via the EVP interface with EVP_CTRL_GCM_SET_TAG for GCM,\n         * and EVP_CTRL_CCM_SET_TAG for CCM, but does not provide a generic setter like EVP_CTRL_AEAD_SET_TAG\n         * that also sets the tag for chacha20-poly1305.\n         * At the moment, LibreSSL should never arrive here if tag is not nullopt; it is direct to AEAD_Decrypt\n         * in that case.\n         * Later, this can be changed to use the EVP interface for GCM and CCM ciphers.\n         */\n        if ( op.tag != std::nullopt ) {\n            CF_CHECK_EQ(EVP_CIPHER_CTX_ctrl(ctx.GetPtr(), EVP_CTRL_AEAD_SET_TAG, op.tag->GetSize(), (void*)op.tag->GetPtr()), 1);\n        }\n#endif\n        if ( op.cipher.cipherType.Get() != CF_CIPHER(\"CHACHA20\") ) {\n            CF_CHECK_EQ(EVP_DecryptInit_ex(ctx.GetPtr(), nullptr, nullptr, op.cipher.key.GetPtr(), op.cipher.iv.GetPtr()), 1);\n        } else {\n            /* Prepend the 32 bit counter (which is 0) to the iv */\n            uint8_t cc20IV[16];\n            memset(cc20IV, 0, 4);\n            memcpy(cc20IV + 4, op.cipher.iv.GetPtr(), op.cipher.iv.GetSize());\n            CF_CHECK_EQ(EVP_DecryptInit_ex(ctx.GetPtr(), nullptr, nullptr, op.cipher.key.GetPtr(), cc20IV), 1);\n        }\n\n        /* Disable ECB padding for consistency with mbed TLS */\n        if ( repository::IsECB(op.cipher.cipherType.Get()) ) {\n            CF_CHECK_EQ(EVP_CIPHER_CTX_set_padding(ctx.GetPtr(), 0), 1);\n        }\n    }\n\n    /* Process */\n    {\n        /* If the cipher is CCM, the total cleartext size needs to be indicated explicitly\n         * https://wiki.openssl.org/index.php/EVP_Authenticated_Encryption_and_Decryption\n         */\n        if ( repository::IsCCM(op.cipher.cipherType.Get()) == true ) {\n            int len;\n            CF_CHECK_EQ(EVP_DecryptUpdate(ctx.GetPtr(), nullptr, &len, nullptr, op.ciphertext.GetSize()), 1);\n        }\n\n        /* Set AAD */\n        if ( op.aad != std::nullopt ) {\n            for (const auto& part : partsAAD) {\n                int len;\n                CF_CHECK_EQ(EVP_DecryptUpdate(ctx.GetPtr(), nullptr, &len, part.first, part.second), 1);\n            }\n        }\n\n        /* Set ciphertext */\n        for (const auto& part : partsCiphertext) {\n            CF_CHECK_GTE(out_size, part.second + EVP_CIPHER_block_size(cipher));\n\n            int len = -1;\n            CF_CHECK_EQ(EVP_DecryptUpdate(ctx.GetPtr(), out + outIdx, &len, part.first, part.second), 1);\n\n            outIdx += len;\n            out_size -= len;\n        }\n    }\n\n    /* Finalize */\n    {\n        CF_CHECK_GTE(out_size, static_cast<size_t>(EVP_CIPHER_block_size(cipher)));\n\n        int len = -1;\n        CF_CHECK_EQ(EVP_DecryptFinal_ex(ctx.GetPtr(), out + outIdx, &len), 1);\n        outIdx += len;\n\n        ret = component::Cleartext(out, outIdx);\n    }\n\nend:\n\n    util::free(out);\n\n    return ret;\n}\n\n#if defined(CRYPTOFUZZ_BORINGSSL) || defined(CRYPTOFUZZ_LIBRESSL)\nstd::optional<component::Cleartext> OpenSSL::AEAD_Decrypt(operation::SymmetricDecrypt& op, Datasource& ds) {\n    (void)ds;\n\n    std::optional<component::Cleartext> ret = std::nullopt;\n\n    const EVP_AEAD* aead = nullptr;\n    EVP_AEAD_CTX* ctx = nullptr;\n    size_t len;\n\n    size_t out_size = op.cleartextSize;\n    uint8_t* out = util::malloc(out_size);\n\n    const size_t tagSize = op.tag != std::nullopt ? op.tag->GetSize() : 0;\n\n    /* Initialize */\n    {\n        CF_CHECK_NE(aead = toEVPAEAD(op.cipher.cipherType), nullptr);\n#if defined(CRYPTOFUZZ_LIBRESSL)\n\t\tCF_CHECK_NE(ctx = EVP_AEAD_CTX_new(), nullptr);\n        CF_CHECK_NE(EVP_AEAD_CTX_init(\n                    ctx,\n                    aead,\n                    op.cipher.key.GetPtr(),\n                    op.cipher.key.GetSize(),\n                    tagSize,\n                    nullptr), 0);\n#else /* CRYPTOFUZZ_BORINGSSL */\n        CF_CHECK_NE(ctx = EVP_AEAD_CTX_new(\n                    aead,\n                    op.cipher.key.GetPtr(),\n                    op.cipher.key.GetSize(),\n                    tagSize), nullptr);\n#endif\n    }\n\n    /* Process */\n    {\n        /* OpenSSL and derivates consume the ciphertext + tag in concatenated form */\n        std::vector<uint8_t> ciphertextAndTag(op.ciphertext.GetSize() + tagSize);\n        memcpy(ciphertextAndTag.data(), op.ciphertext.GetPtr(), op.ciphertext.GetSize());\n        if ( tagSize > 0 ) {\n            memcpy(ciphertextAndTag.data() + op.ciphertext.GetSize(), op.tag->GetPtr(), tagSize);\n        }\n\n        CF_CHECK_NE(EVP_AEAD_CTX_open(ctx,\n                    out,\n                    &len,\n                    out_size,\n                    op.cipher.iv.GetPtr(),\n                    op.cipher.iv.GetSize(),\n                    ciphertextAndTag.data(),\n                    ciphertextAndTag.size(),\n                    op.aad != std::nullopt ? op.aad->GetPtr() : nullptr,\n                    op.aad != std::nullopt ? op.aad->GetSize() : 0),\n                0);\n    }\n\n    /* Finalize */\n    {\n        ret = component::Cleartext(out, len);\n    }\n\nend:\n    CF_NORET(EVP_AEAD_CTX_free(ctx));\n\n    util::free(out);\n\n    return ret;\n}\n#endif\n\nstd::optional<component::Cleartext> OpenSSL::AES_Decrypt(operation::SymmetricDecrypt& op, Datasource& ds) {\n    (void)ds;\n\n    std::optional<component::Cleartext> ret = std::nullopt;\n\n    AES_KEY key;\n    uint8_t* out = nullptr;\n\n    /* Initialize */\n    {\n        CF_CHECK_EQ(op.aad, std::nullopt);\n        CF_CHECK_EQ(op.tag, std::nullopt);\n        CF_CHECK_EQ(op.cipher.iv.GetSize(), 0);\n        CF_CHECK_GT(op.ciphertext.GetSize(), 0);\n        CF_CHECK_GTE(op.cleartextSize, op.ciphertext.GetSize());\n        CF_CHECK_EQ(op.ciphertext.GetSize() % 16, 0);\n        CF_CHECK_EQ(AES_set_decrypt_key(op.cipher.key.GetPtr(), op.cipher.key.GetSize() * 8, &key), 0);\n    }\n\n    /* Process */\n    {\n#if 0\n        bool useOverlap = false;\n        uint64_t ciphertextIndex;\n        try {\n            bool _useOverlap = ds.Get<bool>();\n            if ( _useOverlap == true ) {\n                ciphertextIndex = ds.Get<uint64_t>() % op.ciphertext.GetSize();\n                useOverlap = true;\n            }\n        } catch ( fuzzing::datasource::Datasource::OutOfData& ) {\n        }\n\n        if ( useOverlap == true ) {\n            /* in and out are allowed to overlap */\n            out = (uint8_t*)malloc(op.ciphertext.GetSize() + ciphertextIndex);\n            memcpy(out + ciphertextIndex, op.ciphertext.GetPtr(), op.ciphertext.GetSize());\n\n            for (size_t i = 0; i < op.ciphertext.GetSize(); i += 16) {\n                AES_decrypt(out + ciphertextIndex + i, out + i, &key);\n            }\n        } else\n#endif\n        {\n            out = (uint8_t*)malloc(op.cleartextSize);\n\n            for (size_t i = 0; i < op.ciphertext.GetSize(); i += 16) {\n                AES_decrypt(op.ciphertext.GetPtr() + i, out + i, &key);\n            }\n        }\n    }\n\n    /* Finalize */\n    {\n        ret = component::Cleartext(out, op.ciphertext.GetSize());\n    }\n\nend:\n\n    free(out);\n\n    return ret;\n}\n\n\n"}
{"text_input": "Generate SymmetricDecrypt code for module.cpp", "output": "std::optional<component::Cleartext> OpenSSL::OpSymmetricDecrypt(operation::SymmetricDecrypt& op) {\n    Datasource ds(op.modifier.GetPtr(), op.modifier.GetSize());\n\n    if ( op.cipher.cipherType.Get() == CF_CIPHER(\"AES\") ) {\n        return AES_Decrypt(op, ds);\n    }\n\n#if defined(CRYPTOFUZZ_OPENSSL_102) || defined(CRYPTOFUZZ_OPENSSL_110)\n    /* Prevent OOB write for large keys in RC5.\n     * Fixed in OpenSSL master, but will not be fixed for OpenSSL 1.0.2 and 1.1.0\n     */\n    if ( op.cipher.key.GetSize() > 255 ) {\n        switch ( op.cipher.cipherType.Get() ) {\n            case CF_CIPHER(\"RC5_32_12_16_ECB\"):\n            case CF_CIPHER(\"RC5_32_12_16_CFB\"):\n            case CF_CIPHER(\"RC5_32_12_16_OFB\"):\n            case CF_CIPHER(\"RC5_32_12_16_CBC\"):\n                return std::nullopt;\n        }\n    }\n#endif\n\n    bool useEVP = true;\n    try {\n        useEVP = ds.Get<bool>();\n    } catch ( fuzzing::datasource::Datasource::OutOfData& ) {\n    }\n\n#if defined(CRYPTOFUZZ_BORINGSSL) || defined(CRYPTOFUZZ_LIBRESSL)\n    if ( toEVPAEAD(op.cipher.cipherType) != nullptr ) {\n        if ( op.tag != std::nullopt || op.aad != std::nullopt ) {\n            /* See comment at OpSymmetricEncrypt */\n            return AEAD_Decrypt(op, ds);\n        }\n    }\n#endif\n\n    if ( useEVP == true ) {\n        return OpSymmetricDecrypt_EVP(op, ds);\n    } else {\n#if !defined(CRYPTOFUZZ_BORINGSSL)\n        return OpSymmetricDecrypt_BIO(op, ds);\n#else\n        return OpSymmetricDecrypt_EVP(op, ds);\n#endif\n    }\n}\n\n#if !defined(CRYPTOFUZZ_BORINGSSL) && !defined(CRYPTOFUZZ_LIBRESSL) && !defined(CRYPTOFUZZ_OPENSSL_102) && !defined(CRYPTOFUZZ_OPENSSL_110) && !defined(CRYPTOFUZZ_OPENSSL_098)\n\n"}
{"text_input": "Generate KDF_SCRYPT_EVP_PKEY code for module.cpp", "output": "std::optional<component::Key> OpenSSL::OpKDF_SCRYPT_EVP_PKEY(operation::KDF_SCRYPT& op) const {\n    std::optional<component::Key> ret = std::nullopt;\n    EVP_PKEY_CTX* pctx = nullptr;\n\n    size_t out_size = op.keySize;\n    uint8_t* out = util::malloc(out_size);\n\n    /* Initialize */\n    {\n        CF_CHECK_NE(pctx = EVP_PKEY_CTX_new_id(EVP_PKEY_SCRYPT, nullptr), nullptr);\n        CF_CHECK_EQ(EVP_PKEY_derive_init(pctx), 1);\n        CF_CHECK_EQ(EVP_PKEY_CTX_set1_pbe_pass(pctx, (const char*)op.password.GetPtr(), op.password.GetSize()), 1);\n        CF_CHECK_EQ(EVP_PKEY_CTX_set1_scrypt_salt(pctx, op.salt.GetPtr(), op.salt.GetSize()), 1);\n        CF_CHECK_EQ(EVP_PKEY_CTX_set_scrypt_N(pctx, op.N) , 1);\n        CF_CHECK_EQ(EVP_PKEY_CTX_set_scrypt_r(pctx, op.r) , 1);\n        CF_CHECK_EQ(EVP_PKEY_CTX_set_scrypt_p(pctx, op.p) , 1);\n    }\n\n    /* Process/finalize */\n    {\n        CF_CHECK_EQ(EVP_PKEY_derive(pctx, out, &out_size) , 1);\n\n        CF_CHECK_NE(out, nullptr);\n\n        ret = component::Key(out, out_size);\n    }\n\nend:\n    EVP_PKEY_CTX_free(pctx);\n    util::free(out);\n\n    return ret;\n}\n#endif\n\n#if !defined(CRYPTOFUZZ_BORINGSSL) && !defined(CRYPTOFUZZ_LIBRESSL) && !defined(CRYPTOFUZZ_OPENSSL_102) && !defined(CRYPTOFUZZ_OPENSSL_110) && !defined(CRYPTOFUZZ_OPENSSL_098)\n\n"}
{"text_input": "Generate KDF_SCRYPT_EVP_KDF code for module.cpp", "output": "std::optional<component::Key> OpenSSL::OpKDF_SCRYPT_EVP_KDF(operation::KDF_SCRYPT& op) const {\n    std::optional<component::Key> ret = std::nullopt;\n    EVP_KDF_CTX* kctx = nullptr;\n    OSSL_PARAM params[7], *p = params;\n    uint8_t* out = util::malloc(op.keySize);\n\n    {\n\n        auto passwordCopy = op.password.Get();\n        *p++ = OSSL_PARAM_construct_octet_string(\n                OSSL_KDF_PARAM_PASSWORD,\n                passwordCopy.data(),\n                passwordCopy.size());\n\n        auto saltCopy = op.salt.Get();\n        *p++ = OSSL_PARAM_construct_octet_string(\n                OSSL_KDF_PARAM_SALT,\n                saltCopy.data(),\n                saltCopy.size());\n\n        unsigned int N = op.N;\n        *p++ = OSSL_PARAM_construct_uint(OSSL_KDF_PARAM_SCRYPT_N, &N);\n\n        unsigned int r = op.r;\n        *p++ = OSSL_PARAM_construct_uint(OSSL_KDF_PARAM_SCRYPT_R, &r);\n\n        unsigned int p_ = op.p;\n        *p++ = OSSL_PARAM_construct_uint(OSSL_KDF_PARAM_SCRYPT_P, &p_);\n\n        unsigned int maxmem = 1024;\n        *p++ = OSSL_PARAM_construct_uint(OSSL_KDF_PARAM_SCRYPT_MAXMEM, &maxmem);\n\n        *p = OSSL_PARAM_construct_end();\n\n        {\n            EVP_KDF* kdf = EVP_KDF_fetch(nullptr, OSSL_KDF_NAME_SCRYPT, nullptr);\n            CF_CHECK_NE(kdf, nullptr);\n            kctx = EVP_KDF_CTX_new(kdf);\n            EVP_KDF_free(kdf);\n            CF_CHECK_NE(kctx, nullptr);\n        }\n\n        CF_CHECK_GT(EVP_KDF_derive(kctx, out, op.keySize, params), 0);\n    }\n\n    /* Finalize */\n    {\n        ret = component::Key(out, op.keySize);\n    }\n\nend:\n    EVP_KDF_CTX_free(kctx);\n\n    util::free(out);\n    return ret;\n}\n#endif\n\n#if !defined(CRYPTOFUZZ_LIBRESSL) && !defined(CRYPTOFUZZ_OPENSSL_102) && !defined(CRYPTOFUZZ_OPENSSL_110) && !defined(CRYPTOFUZZ_OPENSSL_098)\n\n"}
{"text_input": "Generate KDF_SCRYPT code for module.cpp", "output": "std::optional<component::Key> OpenSSL::OpKDF_SCRYPT(operation::KDF_SCRYPT& op) {\n #if defined(CRYPTOFUZZ_BORINGSSL)\n    Datasource ds(op.modifier.GetPtr(), op.modifier.GetSize());\n    std::optional<component::Key> ret = std::nullopt;\n\n    size_t outSize = op.keySize;\n    uint8_t* out = util::malloc(outSize);\n\n    size_t maxMem = 0;\n    try {\n        maxMem = ds.Get<uint64_t>() % (64*1024*1024);\n    } catch ( fuzzing::datasource::Datasource::OutOfData& ) {\n    }\n\n    CF_CHECK_EQ(EVP_PBE_scrypt(\n                (const char*)(op.password.GetPtr()),\n                op.password.GetSize(),\n                op.salt.GetPtr(),\n                op.salt.GetSize(),\n                op.N,\n                op.r,\n                op.p,\n                maxMem,\n                out,\n                outSize), 1);\n\n    ret = component::Key(out, outSize);\n\nend:\n    util::free(out);\n\n    return ret;\n #else\n    Datasource ds(op.modifier.GetPtr(), op.modifier.GetSize());\n\n    bool useEVP_PKEY = true;\n    try {\n        useEVP_PKEY = ds.Get<bool>();\n    } catch ( fuzzing::datasource::Datasource::OutOfData& ) {\n    }\n\n    if ( useEVP_PKEY == true ) {\n        return OpKDF_SCRYPT_EVP_PKEY(op);\n    } else {\n        return OpKDF_SCRYPT_EVP_KDF(op);\n    }\n #endif\n}\n#endif\n\n#if !defined(CRYPTOFUZZ_LIBRESSL) && !defined(CRYPTOFUZZ_OPENSSL_102) && !defined(CRYPTOFUZZ_OPENSSL_098)\n\n"}
{"text_input": "Generate KDF_HKDF code for module.cpp", "output": "std::optional<component::Key> OpenSSL::OpKDF_HKDF(operation::KDF_HKDF& op) {\n #if defined(CRYPTOFUZZ_BORINGSSL)\n    std::optional<component::Key> ret = std::nullopt;\n    const EVP_MD* md = nullptr;\n\n    const size_t outSize = op.keySize;\n    uint8_t* out = util::malloc(outSize);\n\n    CF_CHECK_NE(md = toEVPMD(op.digestType), nullptr);\n    CF_CHECK_EQ(\n            HKDF(out,\n                outSize,\n                md,\n                op.password.GetPtr(),\n                op.password.GetSize(),\n                op.salt.GetPtr(),\n                op.salt.GetSize(),\n                op.info.GetPtr(),\n                op.info.GetSize()), 1);\n\n    ret = component::Key(out, outSize);\n\nend:\n    util::free(out);\n\n    return ret;\n #else\n    std::optional<component::Key> ret = std::nullopt;\n    EVP_PKEY_CTX* pctx = nullptr;\n    const EVP_MD* md = nullptr;\n\n    size_t out_size = op.keySize;\n    uint8_t* out = util::malloc(out_size);\n\n    /* Initialize */\n    {\n        CF_CHECK_NE(md = toEVPMD(op.digestType), nullptr);\n        CF_CHECK_NE(pctx = EVP_PKEY_CTX_new_id(EVP_PKEY_HKDF, nullptr), nullptr);\n        CF_CHECK_EQ(EVP_PKEY_derive_init(pctx), 1);\n        CF_CHECK_EQ(EVP_PKEY_CTX_set_hkdf_md(pctx, md), 1);\n        CF_CHECK_EQ(EVP_PKEY_CTX_set1_hkdf_key(pctx, op.password.GetPtr(), op.password.GetSize()), 1);\n        CF_CHECK_EQ(EVP_PKEY_CTX_set1_hkdf_salt(pctx, op.salt.GetPtr(), op.salt.GetSize()), 1);\n        CF_CHECK_EQ(EVP_PKEY_CTX_add1_hkdf_info(pctx, op.info.GetPtr(), op.info.GetSize()), 1);\n    }\n\n    /* Process/finalize */\n    {\n        CF_CHECK_EQ(EVP_PKEY_derive(pctx, out, &out_size) , 1);\n\n        CF_CHECK_NE(out, nullptr);\n\n        ret = component::Key(out, out_size);\n    }\n\nend:\n    EVP_PKEY_CTX_free(pctx);\n\n    util::free(out);\n\n    return ret;\n #endif\n}\n#endif\n\n#if !defined(CRYPTOFUZZ_BORINGSSL) && !defined(CRYPTOFUZZ_LIBRESSL) && !defined(CRYPTOFUZZ_OPENSSL_102) && !defined(CRYPTOFUZZ_OPENSSL_098)\n\n"}
{"text_input": "Generate KDF_TLS1_PRF code for module.cpp", "output": "std::optional<component::Key> OpenSSL::OpKDF_TLS1_PRF(operation::KDF_TLS1_PRF& op) {\n    std::optional<component::Key> ret = std::nullopt;\n    EVP_PKEY_CTX* pctx = nullptr;\n    const EVP_MD* md = nullptr;\n\n    size_t out_size = op.keySize;\n    uint8_t* out = util::malloc(out_size);\n\n    /* Initialize */\n    {\n        CF_CHECK_NE(md = toEVPMD(op.digestType), nullptr);\n        CF_CHECK_NE(pctx = EVP_PKEY_CTX_new_id(EVP_PKEY_TLS1_PRF, nullptr), nullptr);\n        CF_CHECK_EQ(EVP_PKEY_derive_init(pctx), 1);\n        CF_CHECK_EQ(EVP_PKEY_CTX_set_tls1_prf_md(pctx, md), 1);\n        CF_CHECK_EQ(EVP_PKEY_CTX_set1_tls1_prf_secret(pctx, op.secret.GetPtr(), op.secret.GetSize()), 1);\n        CF_CHECK_EQ(EVP_PKEY_CTX_add1_tls1_prf_seed(pctx, op.seed.GetPtr(), op.seed.GetSize()), 1);\n    }\n\n    /* Process/finalize */\n    {\n        CF_CHECK_EQ(EVP_PKEY_derive(pctx, out, &out_size) , 1);\n\n        /* Documentation:\n         *\n         * \"If key is NULL then the maximum size of the output buffer is written to the keylen parameter.\"\n         *\n         * So in this case 'out_size' should not be interpreted as containing the output size,\n         * and we shouldn't attempt to construct a result from it.\n         */\n        CF_CHECK_NE(out, nullptr);\n\n        ret = component::Key(out, out_size);\n    }\n\nend:\n    EVP_PKEY_CTX_free(pctx);\n\n    util::free(out);\n\n    return ret;\n}\n#endif\n\n#if !defined(CRYPTOFUZZ_LIBRESSL) && !defined(CRYPTOFUZZ_BORINGSSL) && !defined(CRYPTOFUZZ_OPENSSL_102) && !defined(CRYPTOFUZZ_OPENSSL_111) && !defined(CRYPTOFUZZ_OPENSSL_110) && !defined(CRYPTOFUZZ_OPENSSL_098)\n\n"}
{"text_input": "Generate KDF_PBKDF code for module.cpp", "output": "std::optional<component::Key> OpenSSL::OpKDF_PBKDF(operation::KDF_PBKDF& op) {\n    std::optional<component::Key> ret = std::nullopt;\n    EVP_KDF_CTX* kctx = nullptr;\n    const EVP_MD* md = nullptr;\n    OSSL_PARAM params[7], *p = params;\n    uint8_t* out = util::malloc(op.keySize);\n\n    {\n        CF_CHECK_NE(md = toEVPMD(op.digestType), nullptr);\n\n        auto passwordCopy = op.password.Get();\n        *p++ = OSSL_PARAM_construct_octet_string(\n                OSSL_KDF_PARAM_PASSWORD,\n                passwordCopy.data(),\n                passwordCopy.size());\n\n        auto saltCopy = op.salt.Get();\n        *p++ = OSSL_PARAM_construct_octet_string(\n                OSSL_KDF_PARAM_SALT,\n                saltCopy.data(),\n                saltCopy.size());\n\n        unsigned int iterations = op.iterations;\n        *p++ = OSSL_PARAM_construct_uint(OSSL_KDF_PARAM_ITER, &iterations);\n\n        unsigned int id = 1;\n        *p++ = OSSL_PARAM_construct_uint(OSSL_KDF_PARAM_PKCS12_ID, &id);\n\n        std::string mdName(EVP_MD_name(md));\n        *p++ = OSSL_PARAM_construct_utf8_string(OSSL_KDF_PARAM_DIGEST, mdName.data(), mdName.size() + 1);\n\n        int pkcs5 = 0;\n        *p++ = OSSL_PARAM_construct_int(OSSL_KDF_PARAM_PKCS5, &pkcs5);\n\n        *p = OSSL_PARAM_construct_end();\n\n        {\n            EVP_KDF* kdf = EVP_KDF_fetch(nullptr, \"PKCS12KDF\", nullptr);\n            CF_CHECK_NE(kdf, nullptr);\n            kctx = EVP_KDF_CTX_new(kdf);\n            EVP_KDF_free(kdf);\n            CF_CHECK_NE(kctx, nullptr);\n        }\n\n        CF_CHECK_GT(EVP_KDF_derive(kctx, out, op.keySize, params), 0);\n    }\n\n    /* Finalize */\n    {\n        ret = component::Key(out, op.keySize);\n    }\nend:\n    EVP_KDF_CTX_free(kctx);\n\n    util::free(out);\n\n    return ret;\n}\n#endif\n\n#if !defined(CRYPTOFUZZ_LIBRESSL) && !defined(CRYPTOFUZZ_OPENSSL_102) && !defined(CRYPTOFUZZ_OPENSSL_111) && !defined(CRYPTOFUZZ_OPENSSL_110) && !defined(CRYPTOFUZZ_OPENSSL_098)\n\n"}
{"text_input": "Generate KDF_PBKDF2 code for module.cpp", "output": "std::optional<component::Key> OpenSSL::OpKDF_PBKDF2(operation::KDF_PBKDF2& op) {\n #if defined(CRYPTOFUZZ_BORINGSSL)\n    std::optional<component::Key> ret = std::nullopt;\n    const EVP_MD* md = nullptr;\n\n    const size_t outSize = op.keySize;\n    uint8_t* out = util::malloc(outSize);\n\n    CF_CHECK_NE(md = toEVPMD(op.digestType), nullptr);\n    CF_CHECK_EQ(PKCS5_PBKDF2_HMAC(\n                (const char*)(op.password.GetPtr()),\n                op.password.GetSize(),\n                op.salt.GetPtr(),\n                op.salt.GetSize(),\n                op.iterations,\n                md,\n                outSize,\n                out), 1);\n\n    ret = component::Key(out, outSize);\nend:\n    util::free(out);\n\n    return ret;\n #else\n    std::optional<component::Key> ret = std::nullopt;\n    EVP_KDF_CTX* kctx = nullptr;\n    const EVP_MD* md = nullptr;\n    OSSL_PARAM params[6], *p = params;\n    uint8_t* out = util::malloc(op.keySize);\n\n    {\n        CF_CHECK_NE(md = toEVPMD(op.digestType), nullptr);\n\n        auto passwordCopy = op.password.Get();\n        *p++ = OSSL_PARAM_construct_octet_string(\n                OSSL_KDF_PARAM_PASSWORD,\n                passwordCopy.data(),\n                passwordCopy.size());\n\n        auto saltCopy = op.salt.Get();\n        *p++ = OSSL_PARAM_construct_octet_string(\n                OSSL_KDF_PARAM_SALT,\n                saltCopy.data(),\n                saltCopy.size());\n\n        unsigned int iterations = op.iterations;\n        *p++ = OSSL_PARAM_construct_uint(OSSL_KDF_PARAM_ITER, &iterations);\n\n        std::string mdName(EVP_MD_name(md));\n        *p++ = OSSL_PARAM_construct_utf8_string(OSSL_KDF_PARAM_DIGEST, mdName.data(), mdName.size() + 1);\n\n        int pkcs5 = 0;\n        *p++ = OSSL_PARAM_construct_int(OSSL_KDF_PARAM_PKCS5, &pkcs5);\n\n        *p = OSSL_PARAM_construct_end();\n\n        {\n            EVP_KDF* kdf = EVP_KDF_fetch(nullptr, OSSL_KDF_NAME_PBKDF2, nullptr);\n            CF_CHECK_NE(kdf, nullptr);\n            kctx = EVP_KDF_CTX_new(kdf);\n            EVP_KDF_free(kdf);\n            CF_CHECK_NE(kctx, nullptr);\n        }\n\n        CF_CHECK_GT(EVP_KDF_derive(kctx, out, op.keySize, params), 0);\n    }\n\n    /* Finalize */\n    {\n        ret = component::Key(out, op.keySize);\n    }\n\nend:\n    EVP_KDF_CTX_free(kctx);\n\n    util::free(out);\n\n    return ret;\n #endif\n}\n#endif\n\n#if !defined(CRYPTOFUZZ_BORINGSSL) && !defined(CRYPTOFUZZ_LIBRESSL) && !defined(CRYPTOFUZZ_OPENSSL_102) && !defined(CRYPTOFUZZ_OPENSSL_111) && !defined(CRYPTOFUZZ_OPENSSL_110)\n\n"}
{"text_input": "Generate KDF_ARGON2 code for module.cpp", "output": "std::optional<component::Key> OpenSSL::OpKDF_ARGON2(operation::KDF_ARGON2& op) {\n    (void)op;\n    std::optional<component::Key> ret = std::nullopt;\n\n    /* Pending https://github.com/openssl/openssl/pull/12256 */\n#if 0\n    uint8_t* out = util::malloc(op.keySize);\n    EVP_KDF_CTX *kctx = nullptr;\n    OSSL_PARAM params[7], *p = params;\n\n    /* Initialize */\n    {\n        const char* type = nullptr;\n        switch ( op.type ) {\n            case    0:\n                type = SN_argon2d;\n                break;\n            case    1:\n                type = SN_argon2i;\n                break;\n            case    2:\n                type = SN_argon2id;\n                break;\n            default:\n                goto end;\n        }\n\n        CF_CHECK_GTE(op.keySize, 64);\n        CF_CHECK_EQ(op.threads, 1);\n\n        {\n            EVP_KDF* kdf = EVP_KDF_fetch(nullptr, type, nullptr);\n            CF_CHECK_NE(kdf, nullptr);\n            kctx = EVP_KDF_CTX_new(kdf);\n            EVP_KDF_free(kdf);\n            CF_CHECK_NE(kctx, nullptr);\n        }\n\n        {\n            int threads = 1;\n            int m_cost = op.memory;\n            unsigned int iterations = op.iterations;\n\n            auto passwordCopy = op.password.Get();\n            p[0] = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_PASSWORD, passwordCopy.data(), passwordCopy.size());\n\n            auto saltCopy = op.salt.Get();\n            p[1] = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_SALT, saltCopy.data(), saltCopy.size());\n\n            p[2] = OSSL_PARAM_construct_int(OSSL_KDF_PARAM_ARGON2_LANES, &threads);\n            p[3] = OSSL_PARAM_construct_int(OSSL_KDF_PARAM_THREADS, &threads);\n            p[4] = OSSL_PARAM_construct_int(OSSL_KDF_PARAM_ARGON2_MEMCOST, &m_cost);\n            p[5] = OSSL_PARAM_construct_uint(OSSL_KDF_PARAM_ITER, &iterations);\n            p[6] = OSSL_PARAM_construct_end();\n            CF_CHECK_EQ(EVP_KDF_CTX_set_params(kctx, params), 1);\n        }\n    }\n    /* Process/finalize */\n    {\n        CF_CHECK_EQ(EVP_KDF_derive(kctx, out, op.keySize), 1);\n\n        ret = component::Key(out, op.keySize);\n    }\n\nend:\n    EVP_KDF_CTX_free(kctx);\n\n    util::free(out);\n#endif\n\n    return ret;\n}\n#endif\n\n#if !defined(CRYPTOFUZZ_BORINGSSL) && !defined(CRYPTOFUZZ_LIBRESSL) && !defined(CRYPTOFUZZ_OPENSSL_102) && !defined(CRYPTOFUZZ_OPENSSL_111) && !defined(CRYPTOFUZZ_OPENSSL_110) && !defined(CRYPTOFUZZ_OPENSSL_098)\n\n"}
{"text_input": "Generate KDF_SSH code for module.cpp", "output": "std::optional<component::Key> OpenSSL::OpKDF_SSH(operation::KDF_SSH& op) {\n    std::optional<component::Key> ret = std::nullopt;\n    EVP_KDF_CTX* kctx = nullptr;\n    const EVP_MD* md = nullptr;\n    OSSL_PARAM params[6], *p = params;\n    uint8_t* out = util::malloc(op.keySize);\n\n    {\n        CF_CHECK_NE(md = toEVPMD(op.digestType), nullptr);\n        CF_CHECK_EQ(op.type.GetSize(), 1);\n\n        std::string mdName(EVP_MD_name(md));\n        *p++ = OSSL_PARAM_construct_utf8_string(OSSL_KDF_PARAM_DIGEST, mdName.data(), mdName.size() + 1);\n\n        auto keyCopy = op.key.Get();\n        *p++ = OSSL_PARAM_construct_octet_string(\n                OSSL_KDF_PARAM_PASSWORD,\n                keyCopy.data(),\n                keyCopy.size());\n\n        auto xcghashCopy = op.xcghash.Get();\n        *p++ = OSSL_PARAM_construct_octet_string(\n                OSSL_KDF_PARAM_SSHKDF_XCGHASH,\n                xcghashCopy.data(),\n                xcghashCopy.size());\n\n        auto session_idCopy = op.session_id.Get();\n        *p++ = OSSL_PARAM_construct_octet_string(\n                OSSL_KDF_PARAM_SSHKDF_SESSION_ID,\n                session_idCopy.data(),\n                session_idCopy.size());\n\n\n        /* Must be null-terminated even if size is specified.\n         *\n         * See also https://github.com/openssl/openssl/issues/14027\n         */\n        char type[2];\n        type[0] = *(op.type.GetPtr());\n        type[1] = 0;\n\n        *p++ = OSSL_PARAM_construct_utf8_string(OSSL_KDF_PARAM_SSHKDF_TYPE,\n                type, sizeof(type));\n\n        *p = OSSL_PARAM_construct_end();\n\n        {\n            EVP_KDF* kdf = EVP_KDF_fetch(nullptr, OSSL_KDF_NAME_SSHKDF, nullptr);\n            CF_CHECK_NE(kdf, nullptr);\n            kctx = EVP_KDF_CTX_new(kdf);\n            EVP_KDF_free(kdf);\n            CF_CHECK_NE(kctx, nullptr);\n        }\n\n        CF_CHECK_GT(EVP_KDF_derive(kctx, out, op.keySize, params), 0);\n    }\n\n    /* Finalize */\n    {\n        ret = component::Key(out, op.keySize);\n    }\n\nend:\n    EVP_KDF_CTX_free(kctx);\n\n    util::free(out);\n\n    return ret;\n}\n\n\n"}
{"text_input": "Generate KDF_X963 code for module.cpp", "output": "std::optional<component::Key> OpenSSL::OpKDF_X963(operation::KDF_X963& op) {\n    std::optional<component::Key> ret = std::nullopt;\n    EVP_KDF_CTX* kctx = nullptr;\n    const EVP_MD* md = nullptr;\n    OSSL_PARAM params[4], *p = params;\n    uint8_t* out = util::malloc(op.keySize);\n\n    {\n        CF_CHECK_NE(md = toEVPMD(op.digestType), nullptr);\n\n        std::string mdName(EVP_MD_name(md));\n        *p++ = OSSL_PARAM_construct_utf8_string(OSSL_KDF_PARAM_DIGEST, mdName.data(), mdName.size() + 1);\n\n        auto secretCopy = op.secret.Get();\n        *p++ = OSSL_PARAM_construct_octet_string(\n                OSSL_KDF_PARAM_SECRET,\n                secretCopy.data(),\n                secretCopy.size());\n\n        auto infoCopy = op.info.Get();\n        *p++ = OSSL_PARAM_construct_octet_string(\n                OSSL_KDF_PARAM_INFO,\n                infoCopy.data(),\n                infoCopy.size());\n\n        *p = OSSL_PARAM_construct_end();\n\n        {\n            EVP_KDF* kdf = EVP_KDF_fetch(nullptr, \"X963KDF\", nullptr);\n            CF_CHECK_NE(kdf, nullptr);\n            kctx = EVP_KDF_CTX_new(kdf);\n            EVP_KDF_free(kdf);\n            CF_CHECK_NE(kctx, nullptr);\n        }\n\n        CF_CHECK_GT(EVP_KDF_derive(kctx, out, op.keySize, params), 0);\n    }\n\n    /* Finalize */\n    {\n        ret = component::Key(out, op.keySize);\n    }\n\nend:\n    EVP_KDF_CTX_free(kctx);\n\n    util::free(out);\n\n    return ret;\n}\n\n\n"}
{"text_input": "Generate KDF_SP_800_108 code for module.cpp", "output": "std::optional<component::Key> OpenSSL::OpKDF_SP_800_108(operation::KDF_SP_800_108& op) {\n    std::optional<component::Key> ret = std::nullopt;\n    EVP_KDF_CTX* kctx = nullptr;\n    const EVP_MD* md = nullptr;\n    OSSL_PARAM params[7], *p = params;\n    uint8_t* out = util::malloc(op.keySize);\n\n    std::string hmacStr = \"HMAC\";\n    std::string counterStr = \"COUNTER\";\n    std::string feedbackStr = \"FEEDBACK\";\n\n    {\n        if ( op.mode != 0 && op.mode != 1 ) {\n            goto end;\n        }\n\n        if ( op.mode == 1 ) {\n            /* XXX Salt is ignored in feedback mode\n             * https://github.com/openssl/openssl/issues/12409#issuecomment-701645838\n             */\n            CF_CHECK_EQ(op.salt.GetSize(), 0);\n        }\n\n        CF_CHECK_EQ(op.mech.mode, true); /* Currently only HMAC supported, not CMAC */\n\n        CF_CHECK_NE(md = toEVPMD(op.mech.type), nullptr);\n\n        std::string mdName(EVP_MD_name(md));\n        *p++ = OSSL_PARAM_construct_utf8_string(OSSL_KDF_PARAM_DIGEST, mdName.data(), 0);\n        *p++ = OSSL_PARAM_construct_utf8_string(OSSL_KDF_PARAM_MAC, hmacStr.data(), 0);\n\n        if ( op.mode == 0 ) {\n            *p++ = OSSL_PARAM_construct_utf8_string(OSSL_KDF_PARAM_MODE, counterStr.data(), 0);\n        } else if ( op.mode == 1 ) {\n            *p++ = OSSL_PARAM_construct_utf8_string(OSSL_KDF_PARAM_MODE, feedbackStr.data(), 0);\n        } else {\n            CF_UNREACHABLE();\n        }\n\n        auto secretCopy = op.secret.Get();\n        *p++ = OSSL_PARAM_construct_octet_string(\n                OSSL_KDF_PARAM_KEY,\n                secretCopy.data(),\n                secretCopy.size());\n\n        auto labelCopy = op.label.Get();\n        *p++ = OSSL_PARAM_construct_octet_string(\n                OSSL_KDF_PARAM_SALT,\n                labelCopy.data(),\n                labelCopy.size());\n\n        auto saltCopy = op.salt.Get();\n        *p++ = OSSL_PARAM_construct_octet_string(\n                OSSL_KDF_PARAM_INFO,\n                saltCopy.data(),\n                saltCopy.size());\n\n        *p = OSSL_PARAM_construct_end();\n\n        {\n            EVP_KDF* kdf = EVP_KDF_fetch(nullptr, \"KBKDF\", nullptr);\n            CF_CHECK_NE(kdf, nullptr);\n            kctx = EVP_KDF_CTX_new(kdf);\n            EVP_KDF_free(kdf);\n            CF_CHECK_NE(kctx, nullptr);\n        }\n\n        CF_CHECK_GT(EVP_KDF_derive(kctx, out, op.keySize, params), 0);\n    }\n\n    /* Finalize */\n    {\n        ret = component::Key(out, op.keySize);\n    }\n\nend:\n    EVP_KDF_CTX_free(kctx);\n\n    util::free(out);\n\n    return ret;\n}\n#endif\n\n#if !defined(CRYPTOFUZZ_OPENSSL_098)\n\n"}
{"text_input": "Generate CMAC code for module.cpp", "output": "std::optional<component::MAC> OpenSSL::OpCMAC(operation::CMAC& op) {\n    std::optional<component::MAC> ret = std::nullopt;\n    Datasource ds(op.modifier.GetPtr(), op.modifier.GetSize());\n\n    util::Multipart parts;\n\n    CF_CMAC_CTX ctx(ds);\n    const EVP_CIPHER* cipher = nullptr;\n\n    /* Initialize */\n    {\n        parts = util::ToParts(ds, op.cleartext);\n\n        CF_CHECK_NE(cipher = toEVPCIPHER(op.cipher.cipherType), nullptr);\n        CF_CHECK_EQ(CMAC_Init(ctx.GetPtr(), op.cipher.key.GetPtr(), op.cipher.key.GetSize(), cipher, nullptr), 1);\n    }\n\n    /* Process */\n    for (const auto& part : parts) {\n        CF_CHECK_EQ(CMAC_Update(ctx.GetPtr(), part.first, part.second), 1);\n    }\n\n    /* Finalize */\n    {\n        size_t len = 0;\n        uint8_t out[EVP_MAX_MD_SIZE];\n        CF_CHECK_EQ(CMAC_Final(ctx.GetPtr(), out, &len), 1);\n        ret = component::MAC(out, len);\n    }\n\nend:\n    return ret;\n}\n#endif\n\n/* LibreSSL uses getentropy() in ECC operations.\n * MemorySanitizer erroneously does not unpoison the destination buffer.\n * https://github.com/google/sanitizers/issues/1173\n */\n#if !(defined(CRYPTOFUZZ_LIBRESSL) && defined(SANITIZER_MSAN))\nstatic std::optional<int> toCurveNID(const component::CurveType& curveType) {\n    static const std::map<uint64_t, int> LUT = {\n#if !defined(CRYPTOFUZZ_OPENSSL_098)\n        { CF_ECC_CURVE(\"brainpool160r1\"), NID_brainpoolP160r1 },\n        { CF_ECC_CURVE(\"brainpool160t1\"), NID_brainpoolP160t1 },\n        { CF_ECC_CURVE(\"brainpool192r1\"), NID_brainpoolP192r1 },\n        { CF_ECC_CURVE(\"brainpool192t1\"), NID_brainpoolP192t1 },\n        { CF_ECC_CURVE(\"brainpool224r1\"), NID_brainpoolP224r1 },\n        { CF_ECC_CURVE(\"brainpool224t1\"), NID_brainpoolP224t1 },\n        { CF_ECC_CURVE(\"brainpool256r1\"), NID_brainpoolP256r1 },\n        { CF_ECC_CURVE(\"brainpool256t1\"), NID_brainpoolP256t1 },\n        { CF_ECC_CURVE(\"brainpool320r1\"), NID_brainpoolP320r1 },\n        { CF_ECC_CURVE(\"brainpool320t1\"), NID_brainpoolP320t1 },\n        { CF_ECC_CURVE(\"brainpool384r1\"), NID_brainpoolP384r1 },\n        { CF_ECC_CURVE(\"brainpool384t1\"), NID_brainpoolP384t1 },\n        { CF_ECC_CURVE(\"brainpool512r1\"), NID_brainpoolP512r1 },\n        { CF_ECC_CURVE(\"brainpool512t1\"), NID_brainpoolP512t1 },\n#endif\n        { CF_ECC_CURVE(\"secp112r1\"), NID_secp112r1 },\n        { CF_ECC_CURVE(\"secp112r2\"), NID_secp112r2 },\n        { CF_ECC_CURVE(\"secp128r1\"), NID_secp128r1 },\n        { CF_ECC_CURVE(\"secp128r2\"), NID_secp128r2 },\n        { CF_ECC_CURVE(\"secp160k1\"), NID_secp160k1 },\n        { CF_ECC_CURVE(\"secp160r1\"), NID_secp160r1 },\n        { CF_ECC_CURVE(\"secp160r2\"), NID_secp160r2 },\n        { CF_ECC_CURVE(\"secp192k1\"), NID_secp192k1 },\n        { CF_ECC_CURVE(\"secp224k1\"), NID_secp224k1 },\n        { CF_ECC_CURVE(\"secp224r1\"), NID_secp224r1 },\n        { CF_ECC_CURVE(\"secp256k1\"), NID_secp256k1 },\n        { CF_ECC_CURVE(\"secp384r1\"), NID_secp384r1 },\n        { CF_ECC_CURVE(\"secp521r1\"), NID_secp521r1 },\n        { CF_ECC_CURVE(\"sect113r1\"), NID_sect113r1 },\n        { CF_ECC_CURVE(\"sect113r2\"), NID_sect113r2 },\n        { CF_ECC_CURVE(\"sect131r1\"), NID_sect131r1 },\n        { CF_ECC_CURVE(\"sect131r2\"), NID_sect131r2 },\n        { CF_ECC_CURVE(\"sect163k1\"), NID_sect163k1 },\n        { CF_ECC_CURVE(\"sect163r1\"), NID_sect163r1 },\n        { CF_ECC_CURVE(\"sect163r2\"), NID_sect163r2 },\n        { CF_ECC_CURVE(\"sect193r1\"), NID_sect193r1 },\n        { CF_ECC_CURVE(\"sect193r2\"), NID_sect193r2 },\n        { CF_ECC_CURVE(\"sect233k1\"), NID_sect233k1 },\n        { CF_ECC_CURVE(\"sect233r1\"), NID_sect233r1 },\n        { CF_ECC_CURVE(\"sect239k1\"), NID_sect239k1 },\n        { CF_ECC_CURVE(\"sect283k1\"), NID_sect283k1 },\n        { CF_ECC_CURVE(\"sect283r1\"), NID_sect283r1 },\n        { CF_ECC_CURVE(\"sect409k1\"), NID_sect409k1 },\n        { CF_ECC_CURVE(\"sect409r1\"), NID_sect409r1 },\n        { CF_ECC_CURVE(\"sect571k1\"), NID_sect571k1 },\n        { CF_ECC_CURVE(\"sect571r1\"), NID_sect571r1 },\n#if !defined(CRYPTOFUZZ_BORINGSSL) && !defined(CRYPTOFUZZ_LIBRESSL) && !defined(CRYPTOFUZZ_OPENSSL_102) && !defined(CRYPTOFUZZ_OPENSSL_110) && !defined(CRYPTOFUZZ_OPENSSL_098)\n        { CF_ECC_CURVE(\"sm2p256v1\"), NID_sm2 },\n#endif\n        { CF_ECC_CURVE(\"wap_wsg_idm_ecid_wtls1\"), NID_wap_wsg_idm_ecid_wtls1 },\n        { CF_ECC_CURVE(\"wap_wsg_idm_ecid_wtls10\"), NID_wap_wsg_idm_ecid_wtls10 },\n        { CF_ECC_CURVE(\"wap_wsg_idm_ecid_wtls11\"), NID_wap_wsg_idm_ecid_wtls11 },\n        { CF_ECC_CURVE(\"wap_wsg_idm_ecid_wtls12\"), NID_wap_wsg_idm_ecid_wtls12 },\n        { CF_ECC_CURVE(\"wap_wsg_idm_ecid_wtls3\"), NID_wap_wsg_idm_ecid_wtls3 },\n        { CF_ECC_CURVE(\"wap_wsg_idm_ecid_wtls4\"), NID_wap_wsg_idm_ecid_wtls4 },\n        { CF_ECC_CURVE(\"wap_wsg_idm_ecid_wtls5\"), NID_wap_wsg_idm_ecid_wtls5 },\n        { CF_ECC_CURVE(\"wap_wsg_idm_ecid_wtls6\"), NID_wap_wsg_idm_ecid_wtls6 },\n#if 0\n        /* Incorrectly implemented by OpenSSL:\n         * https://github.com/openssl/openssl/issues/6317\n         */\n        { CF_ECC_CURVE(\"wap_wsg_idm_ecid_wtls7\"), NID_wap_wsg_idm_ecid_wtls7 },\n#endif\n        { CF_ECC_CURVE(\"wap_wsg_idm_ecid_wtls8\"), NID_wap_wsg_idm_ecid_wtls8 },\n        { CF_ECC_CURVE(\"wap_wsg_idm_ecid_wtls9\"), NID_wap_wsg_idm_ecid_wtls9 },\n        { CF_ECC_CURVE(\"x962_c2pnb163v1\"), NID_X9_62_c2pnb163v1 },\n        { CF_ECC_CURVE(\"x962_c2pnb163v2\"), NID_X9_62_c2pnb163v2 },\n        { CF_ECC_CURVE(\"x962_c2pnb163v3\"), NID_X9_62_c2pnb163v3 },\n        { CF_ECC_CURVE(\"x962_c2pnb176v1\"), NID_X9_62_c2pnb176v1 },\n        { CF_ECC_CURVE(\"x962_c2pnb208w1\"), NID_X9_62_c2pnb208w1 },\n        { CF_ECC_CURVE(\"x962_c2pnb272w1\"), NID_X9_62_c2pnb272w1 },\n        { CF_ECC_CURVE(\"x962_c2pnb304w1\"), NID_X9_62_c2pnb304w1 },\n        { CF_ECC_CURVE(\"x962_c2pnb368w1\"), NID_X9_62_c2pnb368w1 },\n        { CF_ECC_CURVE(\"x962_c2tnb191v1\"), NID_X9_62_c2tnb191v1 },\n        { CF_ECC_CURVE(\"x962_c2tnb191v2\"), NID_X9_62_c2tnb191v2 },\n        { CF_ECC_CURVE(\"x962_c2tnb191v3\"), NID_X9_62_c2tnb191v3 },\n        { CF_ECC_CURVE(\"x962_c2tnb239v1\"), NID_X9_62_c2tnb239v1 },\n        { CF_ECC_CURVE(\"x962_c2tnb239v2\"), NID_X9_62_c2tnb239v2 },\n        { CF_ECC_CURVE(\"x962_c2tnb239v3\"), NID_X9_62_c2tnb239v3 },\n        { CF_ECC_CURVE(\"x962_c2tnb359v1\"), NID_X9_62_c2tnb359v1 },\n        { CF_ECC_CURVE(\"x962_c2tnb431r1\"), NID_X9_62_c2tnb431r1 },\n        { CF_ECC_CURVE(\"secp192r1\"), NID_X9_62_prime192v1 },\n        { CF_ECC_CURVE(\"x962_p192v1\"), NID_X9_62_prime192v1 },\n        { CF_ECC_CURVE(\"x962_p192v2\"), NID_X9_62_prime192v2 },\n        { CF_ECC_CURVE(\"x962_p192v3\"), NID_X9_62_prime192v3 },\n        { CF_ECC_CURVE(\"x962_p239v1\"), NID_X9_62_prime239v1 },\n        { CF_ECC_CURVE(\"x962_p239v2\"), NID_X9_62_prime239v2 },\n        { CF_ECC_CURVE(\"x962_p239v3\"), NID_X9_62_prime239v3 },\n        { CF_ECC_CURVE(\"secp256r1\"), NID_X9_62_prime256v1 },\n        { CF_ECC_CURVE(\"x962_p256v1\"), NID_X9_62_prime256v1 },\n#if defined(CRYPTOFUZZ_LIBRESSL)\n        { CF_ECC_CURVE(\"ipsec3\"), NID_ipsec3 },\n        { CF_ECC_CURVE(\"ipsec4\"), NID_ipsec4 },\n        { CF_ECC_CURVE(\"gostr3410_2001_test\"), NID_id_GostR3410_2001_TestParamSet },\n        { CF_ECC_CURVE(\"gostr3410_2001_cryptopro_a\"), NID_id_GostR3410_2001_CryptoPro_A_ParamSet },\n        { CF_ECC_CURVE(\"gostr3410_2001_cryptopro_b\"), NID_id_GostR3410_2001_CryptoPro_B_ParamSet },\n        { CF_ECC_CURVE(\"gostr3410_2001_cryptopro_c\"), NID_id_GostR3410_2001_CryptoPro_C_ParamSet },\n        { CF_ECC_CURVE(\"gostr3410_2001_cryptopro_xcha\"), NID_id_GostR3410_2001_CryptoPro_XchA_ParamSet },\n        { CF_ECC_CURVE(\"gostr3410_2001_cryptopro_xchb\"), NID_id_GostR3410_2001_CryptoPro_XchB_ParamSet },\n        { CF_ECC_CURVE(\"tc26_gost_3410_12_256_a\"), NID_id_tc26_gost_3410_12_256_paramSetA },\n        { CF_ECC_CURVE(\"tc26_gost_3410_12_256_b\"), NID_id_tc26_gost_3410_12_256_paramSetB },\n        { CF_ECC_CURVE(\"tc26_gost_3410_12_256_c\"), NID_id_tc26_gost_3410_12_256_paramSetC },\n        { CF_ECC_CURVE(\"tc26_gost_3410_12_256_d\"), NID_id_tc26_gost_3410_12_256_paramSetD },\n        { CF_ECC_CURVE(\"tc26_gost_3410_12_512_test\"), NID_id_tc26_gost_3410_12_512_paramSetTest },\n        { CF_ECC_CURVE(\"tc26_gost_3410_12_512_a\"), NID_id_tc26_gost_3410_12_512_paramSetA },\n        { CF_ECC_CURVE(\"tc26_gost_3410_12_512_b\"), NID_id_tc26_gost_3410_12_512_paramSetB },\n        { CF_ECC_CURVE(\"tc26_gost_3410_12_512_c\"), NID_id_tc26_gost_3410_12_512_paramSetC },\n#endif\n    };\n\n    if ( LUT.find(curveType.Get()) == LUT.end() ) {\n        return std::nullopt;\n    }\n\n    return LUT.at(curveType.Get());\n}\n\n/* TODO OpenSSL 1.0.2, 0.9.8 */\n#if !defined(CRYPTOFUZZ_OPENSSL_102) && !defined(CRYPTOFUZZ_OPENSSL_098)\n\n"}
{"text_input": "Generate ECC_PrivateToPublic code for module.cpp", "output": "std::optional<component::ECC_PublicKey> OpenSSL::OpECC_PrivateToPublic(operation::ECC_PrivateToPublic& op) {\n    std::optional<component::ECC_PublicKey> ret = std::nullopt;\n    Datasource ds(op.modifier.GetPtr(), op.modifier.GetSize());\n\n    global_ds = &ds;\n\n    char* pub_x_str = nullptr;\n    char* pub_y_str = nullptr;\n\n    try {\n        if ( op.curveType.Get() == CF_ECC_CURVE(\"x25519\") ) {\n            uint8_t priv_bytes[32];\n            uint8_t pub_bytes[32];\n            OpenSSL_bignum::Bignum priv(ds), pub(ds);\n            CF_CHECK_EQ(pub.New(), true);\n\n            CF_CHECK_EQ(priv.Set(op.priv.ToString(ds)), true);\n\n            /* Load private key */\n            CF_CHECK_NE(BN_bn2binpad(priv.GetPtr(), priv_bytes, sizeof(priv_bytes)), -1);\n\n            /* Private -> public */\n            /* noret */ X25519_public_from_private(pub_bytes, priv_bytes);\n\n            /* Convert public key */\n            CF_CHECK_NE(BN_bin2bn(pub_bytes, sizeof(pub_bytes), pub.GetDestPtr()), nullptr);\n\n            CF_CHECK_NE(pub_x_str = BN_bn2dec(pub.GetPtr()), nullptr);\n\n            /* Save bignum x/y */\n            ret = { std::string(pub_x_str), \"0\" };\n#if !defined(CRYPTOFUZZ_BORINGSSL) && !defined(CRYPTOFUZZ_LIBRESSL)\n        } else if ( op.curveType.Get() == CF_ECC_CURVE(\"x448\") ) {\n            uint8_t priv_bytes[56];\n            uint8_t pub_bytes[56];\n            OpenSSL_bignum::Bignum priv(ds), pub(ds);\n            CF_CHECK_EQ(pub.New(), true);\n\n            CF_CHECK_EQ(priv.Set(op.priv.ToString(ds)), true);\n\n            /* Load private key */\n            CF_CHECK_NE(BN_bn2binpad(priv.GetPtr(), priv_bytes, sizeof(priv_bytes)), -1);\n\n            /* Private -> public */\n            /* noret */ X448_public_from_private(pub_bytes, priv_bytes);\n\n            /* Convert public key */\n            CF_CHECK_NE(BN_bin2bn(pub_bytes, sizeof(pub_bytes), pub.GetDestPtr()), nullptr);\n\n            CF_CHECK_NE(pub_x_str = BN_bn2dec(pub.GetPtr()), nullptr);\n\n            /* Save bignum x/y */\n            ret = { std::string(pub_x_str), \"0\" };\n#endif\n        } else {\n            CF_EC_KEY key(ds);\n            std::shared_ptr<CF_EC_GROUP> group = nullptr;\n            OpenSSL_bignum::Bignum prv(ds);\n            std::unique_ptr<CF_EC_POINT> pub = nullptr;\n            OpenSSL_bignum::Bignum pub_x(ds);\n            OpenSSL_bignum::Bignum pub_y(ds);\n\n            {\n                std::optional<int> curveNID;\n                CF_CHECK_NE(curveNID = toCurveNID(op.curveType), std::nullopt);\n                CF_CHECK_NE(group = std::make_shared<CF_EC_GROUP>(ds, *curveNID), nullptr);\n                group->Lock();\n                CF_CHECK_NE(group->GetPtr(), nullptr);\n            }\n\n            CF_CHECK_EQ(EC_KEY_set_group(key.GetPtr(), group->GetPtr()), 1);\n\n            /* Load private key */\n            CF_CHECK_EQ(prv.Set(op.priv.ToString(ds)), true);\n\n            /* Set private key */\n            CF_CHECK_EQ(EC_KEY_set_private_key(key.GetPtr(), prv.GetPtr()), 1);\n\n            /* Compute public key */\n            CF_CHECK_NE(pub = std::make_unique<CF_EC_POINT>(ds, group, op.curveType.Get()), nullptr);\n            CF_CHECK_EQ(EC_POINT_mul(group->GetPtr(), pub->GetPtr(), prv.GetPtr(), nullptr, nullptr, nullptr), 1);\n\n            CF_CHECK_EQ(pub_x.New(), true);\n            CF_CHECK_EQ(pub_y.New(), true);\n\n#if !defined(CRYPTOFUZZ_BORINGSSL) && !defined(CRYPTOFUZZ_LIBRESSL) && !defined(CRYPTOFUZZ_OPENSSL_102) && !defined(CRYPTOFUZZ_OPENSSL_110)\n            CF_CHECK_NE(EC_POINT_get_affine_coordinates(group->GetPtr(), pub->GetPtr(), pub_x.GetDestPtr(), pub_y.GetDestPtr(), nullptr), 0);\n#else\n            CF_CHECK_NE(EC_POINT_get_affine_coordinates_GFp(group->GetPtr(), pub->GetPtr(), pub_x.GetDestPtr(), pub_y.GetDestPtr(), nullptr), 0);\n#endif\n\n            /* Convert bignum x/y to strings */\n            CF_CHECK_NE(pub_x_str = BN_bn2dec(pub_x.GetPtr()), nullptr);\n            CF_CHECK_NE(pub_y_str = BN_bn2dec(pub_y.GetPtr()), nullptr);\n\n            /* Save bignum x/y */\n            ret = { std::string(pub_x_str), std::string(pub_y_str) };\n        }\n    } catch ( ... ) { }\n\nend:\n    OPENSSL_free(pub_x_str);\n    OPENSSL_free(pub_y_str);\n\n    global_ds = nullptr;\n\n    return ret;\n}\n#endif /* CRYPTOFUZZ_OPENSSL_102, CRYPTOFUZZ_OPENSSL_098 */\n\n\n"}
{"text_input": "Generate ECC_GenerateKeyPair code for module.cpp", "output": "std::optional<component::ECC_KeyPair> OpenSSL::OpECC_GenerateKeyPair(operation::ECC_GenerateKeyPair& op) {\n    std::optional<component::ECC_KeyPair> ret = std::nullopt;\n    Datasource ds(op.modifier.GetPtr(), op.modifier.GetSize());\n\n    global_ds = &ds;\n\n    EC_KEY* key = nullptr;\n    char* priv_str = nullptr;\n    BIGNUM* pub_x = nullptr;\n    BIGNUM* pub_y = nullptr;\n    char* pub_x_str = nullptr;\n    char* pub_y_str = nullptr;\n\n    try {\n        const BIGNUM* priv = nullptr;\n        std::shared_ptr<CF_EC_GROUP> group = nullptr;\n        std::unique_ptr<CF_EC_POINT> pub = nullptr;\n\n        std::optional<int> curveNID;\n        CF_CHECK_NE(curveNID = toCurveNID(op.curveType), std::nullopt);\n        CF_CHECK_NE(key = EC_KEY_new_by_curve_name(*curveNID), nullptr);\n        CF_CHECK_EQ(EC_KEY_generate_key(key), 1);\n\n        /* Private key */\n        {\n            CF_CHECK_NE(priv = EC_KEY_get0_private_key(key), nullptr);\n            CF_CHECK_NE(priv_str = BN_bn2dec(priv), nullptr);\n        }\n\n        /* Public key */\n        {\n            CF_CHECK_NE(pub_x = BN_new(), nullptr);\n            CF_CHECK_NE(pub_y = BN_new(), nullptr);\n            CF_CHECK_NE(group = std::make_shared<CF_EC_GROUP>(ds, *curveNID), nullptr);\n            group->Lock();\n            CF_CHECK_NE(group->GetPtr(), nullptr);\n            CF_CHECK_NE(pub = std::make_unique<CF_EC_POINT>(ds, group, op.curveType.Get()), nullptr);\n            CF_CHECK_EQ(EC_POINT_mul(group->GetPtr(), pub->GetPtr(), priv, nullptr, nullptr, nullptr), 1);\n\n#if !defined(CRYPTOFUZZ_BORINGSSL) && !defined(CRYPTOFUZZ_LIBRESSL) && !defined(CRYPTOFUZZ_OPENSSL_102) && !defined(CRYPTOFUZZ_OPENSSL_110) && !defined(CRYPTOFUZZ_OPENSSL_098)\n            CF_CHECK_NE(EC_POINT_get_affine_coordinates(group->GetPtr(), pub->GetPtr(), pub_x, pub_y, nullptr), 0);\n#else\n            CF_CHECK_NE(EC_POINT_get_affine_coordinates_GFp(group->GetPtr(), pub->GetPtr(), pub_x, pub_y, nullptr), 0);\n#endif\n\n            CF_CHECK_NE(pub_x_str = BN_bn2dec(pub_x), nullptr);\n            CF_CHECK_NE(pub_y_str = BN_bn2dec(pub_y), nullptr);\n        }\n\n        {\n            ret = {\n                std::string(priv_str),\n                { std::string(pub_x_str), std::string(pub_y_str) }\n            };\n        }\n    } catch ( ... ) { }\n\nend:\n    EC_KEY_free(key);\n    OPENSSL_free(priv_str);\n    BN_free(pub_x);\n    BN_free(pub_y);\n    OPENSSL_free(pub_x_str);\n    OPENSSL_free(pub_y_str);\n\n    global_ds = nullptr;\n\n    return ret;\n}\n\n\n"}
{"text_input": "Generate ECC_ValidatePubkey code for module.cpp", "output": "std::optional<bool> OpenSSL::OpECC_ValidatePubkey(operation::ECC_ValidatePubkey& op) {\n    std::optional<bool> ret = std::nullopt;\n    Datasource ds(op.modifier.GetPtr(), op.modifier.GetSize());\n\n    CF_EC_KEY key(ds);\n    std::shared_ptr<CF_EC_GROUP> group = nullptr;\n\n    std::unique_ptr<CF_EC_POINT> pub = nullptr;\n\n    {\n        std::optional<int> curveNID;\n        CF_CHECK_NE(curveNID = toCurveNID(op.curveType), std::nullopt);\n        CF_CHECK_NE(group = std::make_shared<CF_EC_GROUP>(ds, *curveNID), nullptr);\n        group->Lock();\n        CF_CHECK_NE(group->GetPtr(), nullptr);\n    }\n\n    CF_CHECK_EQ(EC_KEY_set_group(key.GetPtr(), group->GetPtr()), 1);\n\n    /* Construct key */\n    CF_CHECK_NE(pub = std::make_unique<CF_EC_POINT>(ds, group, op.curveType.Get()), nullptr);\n    CF_CHECK_TRUE(pub->Set(op.pub.first, op.pub.second, false,\n                /* allowProjective */\n#if defined(CRYPTOFUZZ_LIBRESSL)\n                /* https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=55750 */\n                true\n#else\n                false\n#endif\n    ));\n\n    /* Reject oversized pubkeys until it is fixed in OpenSSL\n     * https://github.com/openssl/openssl/issues/17590\n     */\n    {\n        const auto order = cryptofuzz::repository::ECC_CurveToOrder(op.curveType.Get());\n        CF_CHECK_NE(order, std::nullopt);\n        CF_CHECK_TRUE(op.pub.first.IsLessThan(*order));\n        CF_CHECK_TRUE(op.pub.second.IsLessThan(*order));\n    }\n\n    ret = EC_KEY_set_public_key(key.GetPtr(), pub->GetPtr()) == 1;\n\n    /* https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=66667 */\n    /* Curves with cofactor > 1 need additional validation */\n    if (    op.curveType.Is(CF_ECC_CURVE(\"secp112r2\")) ||\n            op.curveType.Is(CF_ECC_CURVE(\"secp128r2\")) ) {\n        if ( *ret ) {\n            ret = EC_KEY_check_key(key.GetPtr()) == 1;\n        }\n    }\n\nend:\n    return ret;\n}\n\n/* TODO OpenSSL 1.0.2, 0.9.8 */\n#if !defined(CRYPTOFUZZ_OPENSSL_102) && !defined(CRYPTOFUZZ_OPENSSL_098)\n\n"}
{"text_input": "Generate ECDSA_Sign code for module.cpp", "output": "std::optional<component::ECDSA_Signature> OpenSSL::OpECDSA_Sign(operation::ECDSA_Sign& op) {\n    std::optional<component::ECDSA_Signature> ret = std::nullopt;\n    Datasource ds(op.modifier.GetPtr(), op.modifier.GetSize());\n\n    global_ds = &ds;\n\n    ECDSA_SIG* signature = nullptr;\n    char* pub_x_str = nullptr;\n    char* pub_y_str = nullptr;\n    char* sig_r_str = nullptr;\n    char* sig_s_str = nullptr;\n\n    try {\n        CF_EC_KEY key(ds);\n        std::shared_ptr<CF_EC_GROUP> group = nullptr;\n        OpenSSL_bignum::Bignum prv(ds);\n        std::unique_ptr<CF_EC_POINT> pub = nullptr;\n        OpenSSL_bignum::Bignum pub_x(ds);\n        OpenSSL_bignum::Bignum pub_y(ds);\n        const BIGNUM *R = nullptr, *S = nullptr;\n\n#if defined(CRYPTOFUZZ_BORINGSSL)\n        CF_CHECK_TRUE(op.UseRandomNonce() || op.UseSpecifiedNonce());\n#else\n        CF_CHECK_TRUE(op.UseRandomNonce());\n#endif\n        CF_CHECK_TRUE(op.digestType.Is(CF_DIGEST(\"NULL\")));\n\n        {\n            std::optional<int> curveNID;\n            CF_CHECK_NE(curveNID = toCurveNID(op.curveType), std::nullopt);\n            CF_CHECK_NE(group = std::make_shared<CF_EC_GROUP>(ds, *curveNID), nullptr);\n            group->Lock();\n            CF_CHECK_NE(group->GetPtr(), nullptr);\n        }\n\n        CF_CHECK_EQ(EC_KEY_set_group(key.GetPtr(), group->GetPtr()), 1);\n\n        /* Load private key */\n        CF_CHECK_EQ(prv.Set(op.priv.ToString(ds)), true);\n\n        /* Set private key */\n        CF_CHECK_EQ(EC_KEY_set_private_key(key.GetPtr(), prv.GetPtr()), 1);\n\n        /* Compute public key */\n        CF_CHECK_NE(pub = std::make_unique<CF_EC_POINT>(ds, group, op.curveType.Get()), nullptr);\n        CF_CHECK_EQ(EC_POINT_mul(group->GetPtr(), pub->GetPtr(), prv.GetPtr(), nullptr, nullptr, nullptr), 1);\n\n        CF_CHECK_EQ(pub_x.New(), true);\n        CF_CHECK_EQ(pub_y.New(), true);\n\n#if !defined(CRYPTOFUZZ_BORINGSSL) && !defined(CRYPTOFUZZ_LIBRESSL) && !defined(CRYPTOFUZZ_OPENSSL_102) && !defined(CRYPTOFUZZ_OPENSSL_110)\n        CF_CHECK_NE(EC_POINT_get_affine_coordinates(group->GetPtr(), pub->GetPtr(), pub_x.GetDestPtr(), pub_y.GetDestPtr(), nullptr), 0);\n#else\n        CF_CHECK_NE(EC_POINT_get_affine_coordinates_GFp(group->GetPtr(), pub->GetPtr(), pub_x.GetDestPtr(), pub_y.GetDestPtr(), nullptr), 0);\n#endif\n\n        CF_CHECK_NE(pub_x_str = BN_bn2dec(pub_x.GetPtr()), nullptr);\n        CF_CHECK_NE(pub_y_str = BN_bn2dec(pub_y.GetPtr()), nullptr);\n\n        const auto CT = op.cleartext.ECDSA_RandomPad(ds, op.curveType);\n\n#if defined(CRYPTOFUZZ_BORINGSSL)\n        if ( op.UseSpecifiedNonce() ) {\n            std::optional<std::vector<uint8_t>> nonce_bytes;\n            CF_CHECK_NE(nonce_bytes = util::DecToBin(op.nonce.ToTrimmedString()), std::nullopt);\n\n            CF_CHECK_NE(signature = ECDSA_sign_with_nonce_and_leak_private_key_for_testing(CT.GetPtr(), CT.GetSize(), key.GetPtr(), nonce_bytes->data(), nonce_bytes->size()), nullptr);\n        }\n        else\n#endif\n        CF_CHECK_NE(signature = ECDSA_do_sign(CT.GetPtr(), CT.GetSize(), key.GetPtr()), nullptr);\n\n#if defined(CRYPTOFUZZ_LIBRESSL)\n        /* noret */ ECDSA_SIG_get0(signature, &R, &S);\n        CF_CHECK_NE(R, nullptr);\n        CF_CHECK_NE(S, nullptr);\n#else\n        CF_CHECK_NE(R = ECDSA_SIG_get0_r(signature), nullptr);\n        CF_CHECK_NE(S = ECDSA_SIG_get0_s(signature), nullptr);\n#endif\n\n        /* Convert bignum x/y to strings */\n        CF_CHECK_NE(sig_r_str = BN_bn2dec(R), nullptr);\n        CF_CHECK_NE(sig_s_str = BN_bn2dec(S), nullptr);\n\n\n        component::Bignum S_corrected{std::string(sig_s_str)};\n        CF_NORET(util::AdjustECDSASignature(op.curveType.Get(), S_corrected));\n\n        ret = { {sig_r_str, S_corrected.ToTrimmedString()}, {pub_x_str, pub_y_str} };\n    } catch ( ... ) { }\n\nend:\n    if ( signature != nullptr ) {\n        ECDSA_SIG_free(signature);\n    }\n    OPENSSL_free(pub_x_str);\n    OPENSSL_free(pub_y_str);\n    OPENSSL_free(sig_r_str);\n    OPENSSL_free(sig_s_str);\n\n    global_ds = nullptr;\n\n    return ret;\n}\n#endif /* CRYPTOFUZZ_OPENSSL_102, CRYPTOFUZZ_OPENSSL_098 */\n\n\n"}
{"text_input": "Generate ECDSA_Verify code for module.cpp", "output": "std::optional<bool> OpenSSL::OpECDSA_Verify(operation::ECDSA_Verify& op) {\n    std::optional<bool> ret = std::nullopt;\n    Datasource ds(op.modifier.GetPtr(), op.modifier.GetSize());\n\n    global_ds = &ds;\n\n    ECDSA_SIG* signature = nullptr;\n\n    try {\n        CF_EC_KEY key(ds);\n        std::shared_ptr<CF_EC_GROUP> group = nullptr;\n\n        std::unique_ptr<CF_EC_POINT> pub = nullptr;\n\n        OpenSSL_bignum::Bignum sig_s(ds);\n        OpenSSL_bignum::Bignum sig_r(ds);\n\n        /* Initialize */\n        {\n            {\n                std::optional<int> curveNID;\n                CF_CHECK_NE(curveNID = toCurveNID(op.curveType), std::nullopt);\n                CF_CHECK_NE(group = std::make_shared<CF_EC_GROUP>(ds, *curveNID), nullptr);\n                group->Lock();\n                CF_CHECK_NE(group->GetPtr(), nullptr);\n            }\n            CF_CHECK_EQ(EC_KEY_set_group(key.GetPtr(), group->GetPtr()), 1);\n\n            /* Construct signature */\n            CF_CHECK_EQ(sig_r.Set(op.signature.signature.first.ToString(ds)), true);\n            CF_CHECK_EQ(sig_s.Set(op.signature.signature.second.ToString(ds)), true);\n            CF_CHECK_NE(signature = ECDSA_SIG_new(), nullptr);\n#if defined(CRYPTOFUZZ_OPENSSL_102) || defined(CRYPTOFUZZ_OPENSSL_098)\n            BN_free(signature->r);\n            BN_free(signature->s);\n            signature->r = sig_r.GetPtrConst();\n            signature->s = sig_s.GetPtrConst();\n#else\n            CF_CHECK_EQ(ECDSA_SIG_set0(signature, sig_r.GetDestPtr(false), sig_s.GetDestPtr(false)), 1);\n#endif\n            /* 'signature' now has ownership, and the BIGNUMs will be freed by ECDSA_SIG_free */\n            sig_r.ReleaseOwnership();\n            sig_s.ReleaseOwnership();\n\n            /* Construct key */\n            CF_CHECK_NE(pub = std::make_unique<CF_EC_POINT>(ds, group, op.curveType.Get()), nullptr);\n            CF_CHECK_TRUE(pub->Set(op.signature.pub.first, op.signature.pub.second, false));\n            CF_CHECK_EQ(EC_KEY_set_public_key(key.GetPtr(), pub->GetPtr()), 1);\n        }\n\n        /* Process */\n        {\n            int res;\n            if ( op.digestType.Get() == CF_DIGEST(\"NULL\") ) {\n                const auto CT = op.cleartext.ECDSA_RandomPad(ds, op.curveType);\n                res = ECDSA_do_verify(CT.GetPtr(), CT.GetSize(), signature, key.GetPtr());\n            } else if ( op.digestType.Get() == CF_DIGEST(\"SHA256\") ) {\n                uint8_t CT[32];\n                SHA256(op.cleartext.GetPtr(), op.cleartext.GetSize(), CT);\n                res = ECDSA_do_verify(CT, sizeof(CT), signature, key.GetPtr());\n            } else {\n                /* TODO other digests */\n                goto end;\n            }\n\n            if ( res == 0 ) {\n                ret = false;\n            } else if ( res == 1 ) {\n                ret = true;\n            } else {\n                /* ECDSA_do_verify failed -- don't set ret */\n            }\n\n        }\n    } catch ( ... ) { }\n\nend:\n    if ( signature != nullptr ) {\n        ECDSA_SIG_free(signature);\n    }\n\n    global_ds = nullptr;\n\n    return ret;\n}\n\n\n"}
{"text_input": "Generate ECDH_Derive code for module.cpp", "output": "std::optional<component::Secret> OpenSSL::OpECDH_Derive(operation::ECDH_Derive& op) {\n    std::optional<component::Secret> ret = std::nullopt;\n    Datasource ds(op.modifier.GetPtr(), op.modifier.GetSize());\n\n\n    CF_EC_KEY key(ds);\n    OpenSSL_bignum::Bignum prv(ds);\n    std::shared_ptr<CF_EC_GROUP> group = nullptr;\n    std::unique_ptr<CF_EC_POINT> pub = nullptr;\n    uint8_t* secret = nullptr;\n    int secret_len;\n\n    {\n        std::optional<int> curveNID;\n        CF_CHECK_NE(curveNID = toCurveNID(op.curveType), std::nullopt);\n        CF_CHECK_NE(group = std::make_shared<CF_EC_GROUP>(ds, *curveNID), nullptr);\n        group->Lock();\n        CF_CHECK_NE(group->GetPtr(), nullptr);\n    }\n\n    /* Load private key */\n    {\n        CF_CHECK_EQ(EC_KEY_set_group(key.GetPtr(), group->GetPtr()), 1);\n\n        /* Load private key */\n        CF_CHECK_EQ(prv.Set(op.priv.ToString(ds)), true);\n\n        /* Set private key */\n        CF_CHECK_EQ(EC_KEY_set_private_key(key.GetPtr(), prv.GetPtr()), 1);\n    }\n\n    /* Load public key */\n    {\n        CF_CHECK_NE(pub = std::make_unique<CF_EC_POINT>(ds, group, op.curveType.Get()), nullptr);\n        CF_CHECK_TRUE(pub->Set(op.pub.first, op.pub.second, false, false));\n    }\n\n#if 0\n    secret_len = ECDH_compute_key(\n            nullptr, 0, pub->GetPtr(), key.GetPtr(), nullptr);\n    CF_CHECK_GT(secret_len, 0);\n    abort();\n#endif\n\n    secret_len = 1024;\n    secret = util::malloc(secret_len);\n\n    secret_len = ECDH_compute_key(\n             secret,\n             1024,\n             pub->GetPtr(),\n             key.GetPtr(), nullptr);\n    CF_CHECK_GT(secret_len, 0);\n\n    ret = component::Secret(Buffer(secret, secret_len));\n\nend:\n    util::free(secret);\n\n    return ret;\n}\n\n/* TODO OpenSSL 1.0.2, 0.9.8 */\n#if !defined(CRYPTOFUZZ_OPENSSL_102) && !defined(CRYPTOFUZZ_OPENSSL_098)\n\n"}
{"text_input": "Generate DH_GenerateKeyPair code for module.cpp", "output": "std::optional<component::DH_KeyPair> OpenSSL::OpDH_GenerateKeyPair(operation::DH_GenerateKeyPair& op) {\n    std::optional<component::DH_KeyPair> ret = std::nullopt;\n    Datasource ds(op.modifier.GetPtr(), op.modifier.GetSize());\n\n    global_ds = &ds;\n\n    DH* dh = nullptr;\n    char* priv_str = nullptr;\n    char* pub_str = nullptr;\n\n    CF_CHECK_NE(dh = DH_new(), nullptr);\n\n    try {\n        OpenSSL_bignum::Bignum prime(ds), base(ds);\n        /* Set prime and base */\n        {\n            CF_CHECK_EQ(prime.Set(op.prime.ToString(ds)), true);\n            CF_CHECK_EQ(base.Set(op.base.ToString(ds)), true);\n\n            CF_CHECK_EQ(DH_set0_pqg(dh, prime.GetPtrConst(), nullptr, base.GetPtrConst()), 1);\n            prime.ReleaseOwnership();\n            base.ReleaseOwnership();\n        }\n\n        CF_CHECK_EQ(DH_generate_key(dh), 1);\n\n        {\n            const BIGNUM* priv = nullptr, *pub = nullptr;\n            /* noret */ DH_get0_key(dh, &priv, &pub);\n            CF_CHECK_NE(priv, nullptr);\n            CF_CHECK_NE(pub, nullptr);\n\n            CF_CHECK_NE(priv_str = BN_bn2dec(priv), nullptr);\n            CF_CHECK_NE(pub_str = BN_bn2dec(pub), nullptr);\n        }\n\n        ret = { std::string(priv_str), std::string(pub_str) };\n    } catch ( ... ) { }\n\nend:\n    DH_free(dh);\n    OPENSSL_free(priv_str);\n    OPENSSL_free(pub_str);\n\n    global_ds = nullptr;\n\n    return ret;\n}\n#endif /* CRYPTOFUZZ_OPENSSL_102, CRYPTOFUZZ_OPENSSL_098 */\n\n/* TODO OpenSSL 1.0.2, 0.9.8 */\n#if !defined(CRYPTOFUZZ_OPENSSL_102) && !defined(CRYPTOFUZZ_OPENSSL_098)\n\n"}
{"text_input": "Generate DH_Derive code for module.cpp", "output": "std::optional<component::Bignum> OpenSSL::OpDH_Derive(operation::DH_Derive& op) {\n    std::optional<component::Bignum> ret = std::nullopt;\n    Datasource ds(op.modifier.GetPtr(), op.modifier.GetSize());\n\n    DH* dh = nullptr;\n    OpenSSL_bignum::Bignum prime(ds), base(ds), priv(ds), pub(ds), derived(ds);\n    uint8_t* derived_bytes = nullptr;\n    int derived_size;\n\n    CF_CHECK_NE(op.priv.ToTrimmedString(), \"0\");\n    CF_CHECK_NE(dh = DH_new(), nullptr);\n\n    /* Set prime, base and private key */\n    {\n        CF_CHECK_EQ(prime.Set(op.prime.ToString(ds)), true);\n        CF_CHECK_EQ(base.Set(op.base.ToString(ds)), true);\n\n        CF_CHECK_EQ(DH_set0_pqg(dh, prime.GetPtrConst(), nullptr, base.GetPtrConst()), 1);\n        prime.ReleaseOwnership();\n        base.ReleaseOwnership();\n\n        CF_CHECK_EQ(priv.Set(op.priv.ToString(ds)), true);\n        CF_CHECK_EQ(DH_set0_key(dh, nullptr, priv.GetPtrConst()), 1);\n        priv.ReleaseOwnership();\n    }\n\n    derived_size = DH_size(dh);\n    derived_bytes = util::malloc(derived_size);\n\n    CF_CHECK_EQ(pub.Set(op.pub.ToString(ds)), true);\n\n    CF_CHECK_NE(derived_size = DH_compute_key(derived_bytes, pub.GetPtr(), dh), -1);\n\n    CF_CHECK_EQ(derived.New(), true);\n    CF_CHECK_NE(BN_bin2bn(derived_bytes, derived_size, derived.GetDestPtr()), nullptr);\n\n    CF_CHECK_EQ(BN_is_zero(derived.GetPtr()), 0);\n\n    ret = derived.ToComponentBignum();\n\nend:\n    DH_free(dh);\n    util::free(derived_bytes);\n    return ret;\n}\n#endif /* CRYPTOFUZZ_OPENSSL_102, CRYPTOFUZZ_OPENSSL_098 */\n\n\n"}
{"text_input": "Generate DSA_PrivateToPublic code for module.cpp", "output": "std::optional<component::Bignum> OpenSSL::OpDSA_PrivateToPublic(operation::DSA_PrivateToPublic& op) {\n    std::optional<component::Bignum> ret = std::nullopt;\n    Datasource ds(op.modifier.GetPtr(), op.modifier.GetSize());\n\n    global_ds = &ds;\n    OpenSSL_bignum::Bignum priv(ds);\n    DSA* dsa = nullptr;\n    char* str;\n    const BIGNUM* pub = nullptr;\n    std::string pub_str;\n\n    CF_CHECK_EQ(priv.Set(op.priv.ToString(ds)), true);\n\n    CF_CHECK_NE(dsa = DSA_new(), nullptr);\n    CF_CHECK_NE(DSA_set0_key(dsa, nullptr, priv.GetDestPtr()), 0);\n    priv.ReleaseOwnership();\n\n    CF_CHECK_NE(DSA_generate_key(dsa), 0);\n    CF_NORET(DSA_get0_key(dsa, &pub, nullptr));\n    CF_CHECK_NE(str = BN_bn2dec(pub), nullptr);\n    pub_str = str;\n    OPENSSL_free(str);\n\n    ret = pub_str;\n\nend:\n\n    CF_NORET(DSA_free(dsa));\n\n    global_ds = nullptr;\n\n    return ret;\n}\n\n\n"}
{"text_input": "Generate DSA_GenerateParameters code for module.cpp", "output": "std::optional<component::DSA_Parameters> OpenSSL::OpDSA_GenerateParameters(operation::DSA_GenerateParameters& op) {\n    (void)op;\n    std::optional<component::DSA_Parameters> ret = std::nullopt;\n    Datasource ds(op.modifier.GetPtr(), op.modifier.GetSize());\n\n    global_ds = &ds;\n\n    DSA* dsa = nullptr;\n\n    CF_CHECK_NE(dsa = DSA_new(), nullptr);\n    CF_CHECK_NE(DSA_generate_parameters_ex(dsa, 1024, NULL, 0, NULL, NULL, NULL), 0);\n\n    {\n        std::string p_str, q_str, g_str;\n\n        char* str;\n\n        CF_CHECK_NE(str = BN_bn2dec(DSA_get0_p(dsa)), nullptr);\n        p_str = str;\n        OPENSSL_free(str);\n\n        CF_CHECK_NE(str = BN_bn2dec(DSA_get0_q(dsa)), nullptr);\n        q_str = str;\n        OPENSSL_free(str);\n\n        CF_CHECK_NE(str = BN_bn2dec(DSA_get0_g(dsa)), nullptr);\n        g_str = str;\n        OPENSSL_free(str);\n\n        ret = { p_str, q_str, g_str };\n    }\n\nend:\n    CF_NORET(DSA_free(dsa));\n\n    global_ds = nullptr;\n\n    return ret;\n}\n\n\n"}
{"text_input": "Generate DSA_Sign code for module.cpp", "output": "std::optional<component::DSA_Signature> OpenSSL::OpDSA_Sign(operation::DSA_Sign& op) {\n    std::optional<component::DSA_Signature> ret = std::nullopt;\n    Datasource ds(op.modifier.GetPtr(), op.modifier.GetSize());\n\n    global_ds = &ds;\n\n    DSA* dsa = nullptr;\n    DSA_SIG* dsa_sig = nullptr;\n    uint8_t* signature = nullptr;\n    unsigned int signature_len;\n    OpenSSL_bignum::Bignum p(ds), q(ds), g(ds), pub(ds), priv(ds);\n    std::string r_str, s_str, pub_str;\n\n    CF_CHECK_EQ(p.Set(op.parameters.p.ToString(ds)), true);\n    CF_CHECK_EQ(q.Set(op.parameters.q.ToString(ds)), true);\n    CF_CHECK_EQ(g.Set(op.parameters.g.ToString(ds)), true);\n\n    /* Prevent time-outs */\n    CF_CHECK_LTE(BN_num_bits(p.GetPtr()), 7000);\n    CF_CHECK_LTE(BN_num_bits(q.GetPtr()), 7000);\n    CF_CHECK_LTE(BN_num_bits(g.GetPtr()), 7000);\n\n    CF_CHECK_TRUE(pub.New());\n    CF_CHECK_EQ(priv.Set(op.priv.ToString(ds)), true);\n\n    CF_CHECK_NE(dsa = DSA_new(), nullptr);\n\n    CF_CHECK_NE(DSA_set0_pqg(dsa, p.GetDestPtr(), q.GetDestPtr(), g.GetDestPtr()), 0);\n\n    p.ReleaseOwnership();\n    q.ReleaseOwnership();\n    g.ReleaseOwnership();\n\n    CF_CHECK_NE(DSA_set0_key(dsa, pub.GetDestPtr(), priv.GetDestPtr()), 0);\n    pub.ReleaseOwnership();\n    priv.ReleaseOwnership();\n\n    signature = util::malloc(DSA_size(dsa));\n    CF_CHECK_NE(DSA_sign(\n                0,\n                op.cleartext.GetPtr(), op.cleartext.GetSize(),\n                signature, &signature_len,\n                dsa), 0);\n\n    {\n        const uint8_t* p = signature;\n        CF_CHECK_NE(dsa_sig = d2i_DSA_SIG(nullptr, &p, signature_len), nullptr);\n        const BIGNUM *r, *s;\n        CF_NORET(DSA_SIG_get0(dsa_sig, &r, &s));\n\n        char* str;\n        CF_CHECK_NE(str = BN_bn2dec(r), nullptr);\n        r_str = str;\n        OPENSSL_free(str);\n\n        CF_CHECK_NE(str = BN_bn2dec(s), nullptr);\n        s_str = str;\n        OPENSSL_free(str);\n\n        CF_CHECK_NE(DSA_generate_key(dsa), 0);\n        const BIGNUM* pub = nullptr;\n        CF_NORET(DSA_get0_key(dsa, &pub, nullptr));\n        CF_CHECK_NE(str = BN_bn2dec(pub), nullptr);\n        pub_str = str;\n        OPENSSL_free(str);\n\n        ret = component::DSA_Signature({r_str, s_str}, pub_str);\n    }\n\nend:\n    CF_NORET(DSA_free(dsa));\n    CF_NORET(DSA_SIG_free(dsa_sig));\n    util::free(signature);\n\n    global_ds = nullptr;\n\n    return ret;\n}\n\n\n"}
{"text_input": "Generate DSA_Verify code for module.cpp", "output": "std::optional<bool> OpenSSL::OpDSA_Verify(operation::DSA_Verify& op) {\n    std::optional<bool> ret = std::nullopt;\n    Datasource ds(op.modifier.GetPtr(), op.modifier.GetSize());\n\n    global_ds = &ds;\n\n    DSA* dsa = nullptr;\n    DSA_SIG* dsa_sig = nullptr;\n    uint8_t* signature = nullptr;\n    OpenSSL_bignum::Bignum p(ds), q(ds), g(ds), r(ds), s(ds), pub(ds);\n    std::string r_str, s_str, pub_str;\n\n    CF_CHECK_EQ(p.Set(op.parameters.p.ToString(ds)), true);\n    CF_CHECK_EQ(q.Set(op.parameters.q.ToString(ds)), true);\n    CF_CHECK_EQ(g.Set(op.parameters.g.ToString(ds)), true);\n    CF_CHECK_EQ(r.Set(op.signature.first.ToString(ds)), true);\n    CF_CHECK_EQ(s.Set(op.signature.second.ToString(ds)), true);\n    CF_CHECK_EQ(pub.Set(op.pub.ToString(ds)), true);\n\n    CF_CHECK_NE(dsa = DSA_new(), nullptr);\n\n    CF_CHECK_NE(DSA_set0_pqg(dsa, p.GetDestPtr(), q.GetDestPtr(), g.GetDestPtr()), 0);\n\n    p.ReleaseOwnership();\n    q.ReleaseOwnership();\n    g.ReleaseOwnership();\n\n    CF_CHECK_NE(DSA_set0_key(dsa, pub.GetDestPtr(), nullptr), 0);\n    pub.ReleaseOwnership();\n\n    {\n        CF_CHECK_NE(dsa_sig = DSA_SIG_new(), nullptr);\n\n        CF_CHECK_NE(DSA_SIG_set0(dsa_sig, r.GetDestPtr(), s.GetDestPtr()), 0);\n        r.ReleaseOwnership();\n        s.ReleaseOwnership();\n\n        const auto siglen = i2d_DSA_SIG(dsa_sig, &signature);\n        CF_CHECK_GT(siglen, 0);\n\n        const auto r = DSA_verify(\n                0,\n                op.cleartext.GetPtr(), op.cleartext.GetSize(),\n                signature, siglen,\n                dsa);\n\n        CF_CHECK_NE(r, -1);\n\n        ret = r;\n    }\n\nend:\n    CF_NORET(DSA_free(dsa));\n    CF_NORET(DSA_SIG_free(dsa_sig));\n    OPENSSL_free(signature);\n\n    global_ds = nullptr;\n\n    return ret;\n}\n\n\n"}
{"text_input": "Generate ECC_Point_Add code for module.cpp", "output": "std::optional<component::ECC_Point> OpenSSL::OpECC_Point_Add(operation::ECC_Point_Add& op) {\n    std::optional<component::ECC_Point> ret = std::nullopt;\n    Datasource ds(op.modifier.GetPtr(), op.modifier.GetSize());\n\n    global_ds = &ds;\n\n    std::shared_ptr<CF_EC_GROUP> group = nullptr;\n    std::unique_ptr<CF_EC_POINT> a = nullptr, b = nullptr, res = nullptr;\n    char* x_str = nullptr;\n    char* y_str = nullptr;\n\n    {\n        std::optional<int> curveNID;\n        CF_CHECK_NE(curveNID = toCurveNID(op.curveType), std::nullopt);\n        CF_CHECK_NE(group = std::make_shared<CF_EC_GROUP>(ds, *curveNID), nullptr);\n        group->Lock();\n        CF_CHECK_NE(group->GetPtr(), nullptr);\n    }\n\n    CF_CHECK_NE(a = std::make_unique<CF_EC_POINT>(ds, group, op.curveType.Get()), nullptr);\n    CF_CHECK_TRUE(a->Set(op.a.first, op.a.second));\n\n    CF_CHECK_NE(b = std::make_unique<CF_EC_POINT>(ds, group, op.curveType.Get()), nullptr);\n    CF_CHECK_TRUE(b->Set(op.b.first, op.b.second));\n\n    CF_CHECK_NE(res = std::make_unique<CF_EC_POINT>(ds, group, op.curveType.Get()), nullptr);\n\n    CF_CHECK_NE(EC_POINT_add(group->GetPtr(), res->GetPtr(), a->GetPtr(), b->GetPtr(), nullptr), 0);\n\n    if ( a->IsProjective() ) {\n        OpenSSL_bignum::BN_CTX ctx(ds);\n        if ( !EC_POINT_is_on_curve(group->GetPtr(), a->GetPtr(), ctx.GetPtr()) ) {\n            goto end;\n        }\n    }\n\n    if ( b->IsProjective() ) {\n        OpenSSL_bignum::BN_CTX ctx(ds);\n        if ( !EC_POINT_is_on_curve(group->GetPtr(), b->GetPtr(), ctx.GetPtr()) ) {\n            goto end;\n        }\n    }\n\n    {\n        OpenSSL_bignum::Bignum x(ds);\n        OpenSSL_bignum::Bignum y(ds);\n\n        CF_CHECK_EQ(x.New(), true);\n        CF_CHECK_EQ(y.New(), true);\n\n#if !defined(CRYPTOFUZZ_BORINGSSL) && !defined(CRYPTOFUZZ_LIBRESSL) && !defined(CRYPTOFUZZ_OPENSSL_102) && !defined(CRYPTOFUZZ_OPENSSL_110) && !defined(CRYPTOFUZZ_OPENSSL_098)\n        CF_CHECK_NE(EC_POINT_get_affine_coordinates(group->GetPtr(), res->GetPtr(), x.GetDestPtr(), y.GetDestPtr(), nullptr), 0);\n#else\n        CF_CHECK_NE(EC_POINT_get_affine_coordinates_GFp(group->GetPtr(), res->GetPtr(), x.GetDestPtr(), y.GetDestPtr(), nullptr), 0);\n#endif\n\n        /* Convert bignum x/y to strings */\n        CF_CHECK_NE(x_str = BN_bn2dec(x.GetPtr()), nullptr);\n        CF_CHECK_NE(y_str = BN_bn2dec(y.GetPtr()), nullptr);\n\n        ret = { std::string(x_str), std::string(y_str) };\n    }\n\nend:\n    OPENSSL_free(x_str);\n    OPENSSL_free(y_str);\n\n    global_ds = nullptr;\n\n    return ret;\n}\n\n\n"}
{"text_input": "Generate ECC_Point_Mul code for module.cpp", "output": "std::optional<component::ECC_Point> OpenSSL::OpECC_Point_Mul(operation::ECC_Point_Mul& op) {\n    std::optional<component::ECC_Point> ret = std::nullopt;\n    Datasource ds(op.modifier.GetPtr(), op.modifier.GetSize());\n\n    global_ds = &ds;\n\n    std::shared_ptr<CF_EC_GROUP> group = nullptr;\n    std::unique_ptr<CF_EC_POINT> a = nullptr, res = nullptr;\n    OpenSSL_bignum::Bignum b(ds);\n    char* x_str = nullptr;\n    char* y_str = nullptr;\n\n    {\n        std::optional<int> curveNID;\n        CF_CHECK_NE(curveNID = toCurveNID(op.curveType), std::nullopt);\n        CF_CHECK_NE(group = std::make_shared<CF_EC_GROUP>(ds, *curveNID), nullptr);\n        group->Lock();\n        CF_CHECK_NE(group->GetPtr(), nullptr);\n    }\n\n    CF_CHECK_NE(a = std::make_unique<CF_EC_POINT>(ds, group, op.curveType.Get()), nullptr);\n    CF_CHECK_TRUE(a->Set(op.a.first, op.a.second));\n\n    CF_CHECK_NE(res = std::make_unique<CF_EC_POINT>(ds, group, op.curveType.Get()), nullptr);\n\n    CF_CHECK_EQ(b.Set(op.b.ToString(ds)), true);\n\n#if !defined(CRYPTOFUZZ_BORINGSSL)\n    {\n        bool precompute = false;\n        try {\n            precompute = ds.Get<bool>();\n        } catch ( fuzzing::datasource::Datasource::OutOfData& ) {\n        }\n\n        if ( precompute == true ) {\n            CF_CHECK_NE(EC_GROUP_precompute_mult(group->GetPtr(), nullptr), 0);\n        }\n    }\n#endif\n\n    CF_CHECK_NE(EC_POINT_mul(group->GetPtr(), res->GetPtr(), nullptr, a->GetPtr(), b.GetPtr(), nullptr), 0);\n\n    if ( op.b.ToTrimmedString() == \"0\" ) {\n        if ( !a->IsProjective() ) {\n            CF_ASSERT(\n                    EC_POINT_is_at_infinity(group->GetPtr(), res->GetPtr()) == 1,\n                    \"Point multiplication by 0 does not yield point at infinity\");\n        }\n    }\n\n    /* Bug */\n#if !defined(CRYPTOFUZZ_OPENSSL_098)\n    {\n        if ( !a->IsProjective() ) {\n            OpenSSL_bignum::BN_CTX ctx(ds);\n\n            if ( !EC_POINT_is_on_curve(group->GetPtr(), a->GetPtr(), ctx.GetPtr()) ) {\n                CF_ASSERT(\n                        EC_POINT_is_on_curve(group->GetPtr(), res->GetPtr(), ctx.GetPtr()) == 0,\n                        \"Point multiplication of invalid point yields valid point\");\n            }\n        }\n    }\n#endif\n\n    if ( a->IsProjective() ) {\n        OpenSSL_bignum::BN_CTX ctx(ds);\n        if ( !EC_POINT_is_on_curve(group->GetPtr(), a->GetPtr(), ctx.GetPtr()) ) {\n            goto end;\n        }\n    }\n\n    ret = res->Get();\n\nend:\n    OPENSSL_free(x_str);\n    OPENSSL_free(y_str);\n\n    global_ds = nullptr;\n\n    return ret;\n}\n\n\n"}
{"text_input": "Generate ECC_Point_Neg code for module.cpp", "output": "std::optional<component::ECC_Point> OpenSSL::OpECC_Point_Neg(operation::ECC_Point_Neg& op) {\n    std::optional<component::ECC_Point> ret = std::nullopt;\n    Datasource ds(op.modifier.GetPtr(), op.modifier.GetSize());\n\n    std::shared_ptr<CF_EC_GROUP> group = nullptr;\n    std::unique_ptr<CF_EC_POINT> a = nullptr, res = nullptr;\n    char* x_str = nullptr;\n    char* y_str = nullptr;\n\n    {\n        std::optional<int> curveNID;\n        CF_CHECK_NE(curveNID = toCurveNID(op.curveType), std::nullopt);\n        CF_CHECK_NE(group = std::make_shared<CF_EC_GROUP>(ds, *curveNID), nullptr);\n        group->Lock();\n        CF_CHECK_NE(group->GetPtr(), nullptr);\n    }\n\n    CF_CHECK_NE(a = std::make_unique<CF_EC_POINT>(ds, group, op.curveType.Get()), nullptr);\n    CF_CHECK_TRUE(a->Set(op.a.first, op.a.second));\n\n    CF_CHECK_NE(EC_POINT_invert(group->GetPtr(), a->GetPtr(), nullptr), 0);\n\n    {\n        OpenSSL_bignum::Bignum x(ds);\n        OpenSSL_bignum::Bignum y(ds);\n\n        CF_CHECK_EQ(x.New(), true);\n        CF_CHECK_EQ(y.New(), true);\n\n#if !defined(CRYPTOFUZZ_BORINGSSL) && !defined(CRYPTOFUZZ_LIBRESSL) && !defined(CRYPTOFUZZ_OPENSSL_102) && !defined(CRYPTOFUZZ_OPENSSL_110) && !defined(CRYPTOFUZZ_OPENSSL_098)\n        CF_CHECK_NE(EC_POINT_get_affine_coordinates(group->GetPtr(), a->GetPtr(), x.GetDestPtr(), y.GetDestPtr(), nullptr), 0);\n#else\n        CF_CHECK_NE(EC_POINT_get_affine_coordinates_GFp(group->GetPtr(), a->GetPtr(), x.GetDestPtr(), y.GetDestPtr(), nullptr), 0);\n#endif\n\n        /* Convert bignum x/y to strings */\n        CF_CHECK_NE(x_str = BN_bn2dec(x.GetPtr()), nullptr);\n        CF_CHECK_NE(y_str = BN_bn2dec(y.GetPtr()), nullptr);\n\n        ret = { std::string(x_str), std::string(y_str) };\n    }\n\nend:\n    OPENSSL_free(x_str);\n    OPENSSL_free(y_str);\n\n    return ret;\n}\n\n\n"}
{"text_input": "Generate ECC_Point_Dbl code for module.cpp", "output": "std::optional<component::ECC_Point> OpenSSL::OpECC_Point_Dbl(operation::ECC_Point_Dbl& op) {\n    std::optional<component::ECC_Point> ret = std::nullopt;\n    Datasource ds(op.modifier.GetPtr(), op.modifier.GetSize());\n\n    global_ds = &ds;\n\n    std::shared_ptr<CF_EC_GROUP> group = nullptr;\n    std::unique_ptr<CF_EC_POINT> a = nullptr, res = nullptr;\n    char* x_str = nullptr;\n    char* y_str = nullptr;\n\n    {\n        std::optional<int> curveNID;\n        CF_CHECK_NE(curveNID = toCurveNID(op.curveType), std::nullopt);\n        CF_CHECK_NE(group = std::make_shared<CF_EC_GROUP>(ds, *curveNID), nullptr);\n        group->Lock();\n        CF_CHECK_NE(group->GetPtr(), nullptr);\n    }\n\n    CF_CHECK_NE(a = std::make_unique<CF_EC_POINT>(ds, group, op.curveType.Get()), nullptr);\n    CF_CHECK_TRUE(a->Set(op.a.first, op.a.second));\n\n    CF_CHECK_NE(res = std::make_unique<CF_EC_POINT>(ds, group, op.curveType.Get()), nullptr);\n\n    CF_CHECK_NE(EC_POINT_dbl(group->GetPtr(), res->GetPtr(), a->GetPtr(), nullptr), 0);\n\n    {\n        OpenSSL_bignum::Bignum x(ds);\n        OpenSSL_bignum::Bignum y(ds);\n\n        CF_CHECK_EQ(x.New(), true);\n        CF_CHECK_EQ(y.New(), true);\n\n#if !defined(CRYPTOFUZZ_BORINGSSL) && !defined(CRYPTOFUZZ_LIBRESSL) && !defined(CRYPTOFUZZ_OPENSSL_102) && !defined(CRYPTOFUZZ_OPENSSL_110) && !defined(CRYPTOFUZZ_OPENSSL_098)\n        CF_CHECK_NE(EC_POINT_get_affine_coordinates(group->GetPtr(), res->GetPtr(), x.GetDestPtr(), y.GetDestPtr(), nullptr), 0);\n#else\n        CF_CHECK_NE(EC_POINT_get_affine_coordinates_GFp(group->GetPtr(), res->GetPtr(), x.GetDestPtr(), y.GetDestPtr(), nullptr), 0);\n#endif\n\n        /* Convert bignum x/y to strings */\n        CF_CHECK_NE(x_str = BN_bn2dec(x.GetPtr()), nullptr);\n        CF_CHECK_NE(y_str = BN_bn2dec(y.GetPtr()), nullptr);\n\n        ret = { std::string(x_str), std::string(y_str) };\n    }\n\nend:\n    OPENSSL_free(x_str);\n    OPENSSL_free(y_str);\n\n    global_ds = nullptr;\n\n    return ret;\n}\n\n\n"}
{"text_input": "Generate ECC_Point_Cmp code for module.cpp", "output": "std::optional<bool> OpenSSL::OpECC_Point_Cmp(operation::ECC_Point_Cmp& op) {\n    std::optional<bool> ret = std::nullopt;\n    Datasource ds(op.modifier.GetPtr(), op.modifier.GetSize());\n\n    global_ds = &ds;\n\n    std::shared_ptr<CF_EC_GROUP> group = nullptr;\n    std::unique_ptr<CF_EC_POINT> a = nullptr, b = nullptr;\n\n    {\n        std::optional<int> curveNID;\n        CF_CHECK_NE(curveNID = toCurveNID(op.curveType), std::nullopt);\n        CF_CHECK_NE(group = std::make_shared<CF_EC_GROUP>(ds, *curveNID), nullptr);\n        group->Lock();\n        CF_CHECK_NE(group->GetPtr(), nullptr);\n    }\n\n    CF_CHECK_NE(a = std::make_unique<CF_EC_POINT>(ds, group, op.curveType.Get()), nullptr);\n    CF_CHECK_TRUE(a->Set(op.a.first, op.a.second));\n\n    CF_CHECK_NE(b = std::make_unique<CF_EC_POINT>(ds, group, op.curveType.Get()), nullptr);\n    CF_CHECK_TRUE(b->Set(op.b.first, op.b.second));\n\n    ret = EC_POINT_cmp(group->GetPtr(), a->GetPtr(), b->GetPtr(), nullptr) == 0;\n\nend:\n    global_ds = nullptr;\n\n    return ret;\n}\n\n\n"}
{"text_input": "Generate BignumCalc code for module.cpp", "output": "std::optional<component::Bignum> OpenSSL::OpBignumCalc(operation::BignumCalc& op) {\n    bool prime_modulus = false;\n\n    if ( op.modulo != std::nullopt ) {\n        if ( op.calcOp.Get() != CF_CALCOP(\"Sqrt(A)\") ) {\n            return std::nullopt;\n        }\n\n        if ( op.modulo->ToTrimmedString() == \"52435875175126190479447740508185965837690552500527637822603658699938581184513\" ) {\n            prime_modulus = true;\n        } else if ( op.modulo->ToTrimmedString() == \"4002409555221667393417789825735904156556882819939007885332058136124031650490837864442687629129015664037894272559787\" ) {\n            prime_modulus = true;\n        } else {\n            return std::nullopt;\n        }\n    }\n\n    std::optional<component::Bignum> ret = std::nullopt;\n    Datasource ds(op.modifier.GetPtr(), op.modifier.GetSize());\n\n    global_ds = &ds;\n\n    try {\n        OpenSSL_bignum::BN_CTX ctx(ds);\n        OpenSSL_bignum::BignumCluster bn(ds,\n                OpenSSL_bignum::Bignum(ds),\n                OpenSSL_bignum::Bignum(ds),\n                OpenSSL_bignum::Bignum(ds),\n                OpenSSL_bignum::Bignum(ds));\n\n        OpenSSL_bignum::Bignum res(ds);\n\n        std::unique_ptr<OpenSSL_bignum::Operation> opRunner = nullptr;\n\n        CF_CHECK_EQ(res.New(), true);\n        CF_CHECK_EQ(bn.New(0), true);\n        CF_CHECK_EQ(bn.New(1), true);\n        CF_CHECK_EQ(bn.New(2), true);\n        CF_CHECK_EQ(bn.New(3), true);\n\n        CF_NORET(res.Randomize());\n        CF_CHECK_EQ(bn.Set(0, op.bn0.ToString(ds)), true);\n        if ( prime_modulus == false ) {\n            CF_CHECK_EQ(bn.Set(1, op.bn1.ToString(ds)), true);\n        } else {\n            CF_CHECK_EQ(bn.Set(1, op.modulo->ToString(ds)), true);\n        }\n        CF_CHECK_EQ(bn.Set(2, op.bn2.ToString(ds)), true);\n        CF_CHECK_EQ(bn.Set(3, op.bn3.ToString(ds)), true);\n\n        switch ( op.calcOp.Get() ) {\n            case    CF_CALCOP(\"Add(A,B)\"):\n                opRunner = std::make_unique<OpenSSL_bignum::Add>();\n                break;\n            case    CF_CALCOP(\"Sub(A,B)\"):\n                opRunner = std::make_unique<OpenSSL_bignum::Sub>();\n                break;\n            case    CF_CALCOP(\"Mul(A,B)\"):\n                opRunner = std::make_unique<OpenSSL_bignum::Mul>();\n                break;\n            case    CF_CALCOP(\"Mod(A,B)\"):\n                opRunner = std::make_unique<OpenSSL_bignum::Mod>();\n                break;\n            case    CF_CALCOP(\"ExpMod(A,B,C)\"):\n                opRunner = std::make_unique<OpenSSL_bignum::ExpMod>();\n                break;\n            case    CF_CALCOP(\"Sqr(A)\"):\n                opRunner = std::make_unique<OpenSSL_bignum::Sqr>();\n                break;\n            case    CF_CALCOP(\"GCD(A,B)\"):\n                opRunner = std::make_unique<OpenSSL_bignum::GCD>();\n                break;\n            case    CF_CALCOP(\"AddMod(A,B,C)\"):\n                opRunner = std::make_unique<OpenSSL_bignum::AddMod>();\n                break;\n            case    CF_CALCOP(\"SubMod(A,B,C)\"):\n                opRunner = std::make_unique<OpenSSL_bignum::SubMod>();\n                break;\n            case    CF_CALCOP(\"MulMod(A,B,C)\"):\n                opRunner = std::make_unique<OpenSSL_bignum::MulMod>();\n                break;\n            case    CF_CALCOP(\"SqrMod(A,B)\"):\n                opRunner = std::make_unique<OpenSSL_bignum::SqrMod>();\n                break;\n            case    CF_CALCOP(\"InvMod(A,B)\"):\n                opRunner = std::make_unique<OpenSSL_bignum::InvMod>();\n                break;\n            case    CF_CALCOP(\"Cmp(A,B)\"):\n                opRunner = std::make_unique<OpenSSL_bignum::Cmp>();\n                break;\n            case    CF_CALCOP(\"Div(A,B)\"):\n                opRunner = std::make_unique<OpenSSL_bignum::Div>();\n                break;\n            case    CF_CALCOP(\"IsPrime(A)\"):\n                opRunner = std::make_unique<OpenSSL_bignum::IsPrime>();\n                break;\n            case    CF_CALCOP(\"Sqrt(A)\"):\n                if ( prime_modulus == false ) {\n                    opRunner = std::make_unique<OpenSSL_bignum::Sqrt>();\n                } else {\n                    opRunner = std::make_unique<OpenSSL_bignum::SqrtMod>();\n                }\n                break;\n            case    CF_CALCOP(\"IsNeg(A)\"):\n                opRunner = std::make_unique<OpenSSL_bignum::IsNeg>();\n                break;\n            case    CF_CALCOP(\"IsEq(A,B)\"):\n                opRunner = std::make_unique<OpenSSL_bignum::IsEq>();\n                break;\n            case    CF_CALCOP(\"IsEven(A)\"):\n                opRunner = std::make_unique<OpenSSL_bignum::IsEven>();\n                break;\n            case    CF_CALCOP(\"IsOdd(A)\"):\n                opRunner = std::make_unique<OpenSSL_bignum::IsOdd>();\n                break;\n            case    CF_CALCOP(\"IsZero(A)\"):\n                opRunner = std::make_unique<OpenSSL_bignum::IsZero>();\n                break;\n            case    CF_CALCOP(\"IsOne(A)\"):\n                opRunner = std::make_unique<OpenSSL_bignum::IsOne>();\n                break;\n            case    CF_CALCOP(\"Jacobi(A,B)\"):\n                opRunner = std::make_unique<OpenSSL_bignum::Jacobi>();\n                break;\n#if !defined(CRYPTOFUZZ_BORINGSSL) && !defined(CRYPTOFUZZ_OPENSSL_098) && !defined(CRYPTOFUZZ_LIBRESSL)\n            case    CF_CALCOP(\"Mod_NIST_192(A)\"):\n                opRunner = std::make_unique<OpenSSL_bignum::Mod_NIST_192>();\n                break;\n            case    CF_CALCOP(\"Mod_NIST_224(A)\"):\n                opRunner = std::make_unique<OpenSSL_bignum::Mod_NIST_224>();\n                break;\n            case    CF_CALCOP(\"Mod_NIST_256(A)\"):\n                opRunner = std::make_unique<OpenSSL_bignum::Mod_NIST_256>();\n                break;\n            case    CF_CALCOP(\"Mod_NIST_384(A)\"):\n                opRunner = std::make_unique<OpenSSL_bignum::Mod_NIST_384>();\n                break;\n            case    CF_CALCOP(\"Mod_NIST_521(A)\"):\n                opRunner = std::make_unique<OpenSSL_bignum::Mod_NIST_521>();\n                break;\n#endif\n#if defined(CRYPTOFUZZ_BORINGSSL)\n            case    CF_CALCOP(\"LCM(A,B)\"):\n                opRunner = std::make_unique<OpenSSL_bignum::LCM>();\n                break;\n#endif\n            case    CF_CALCOP(\"Exp(A,B)\"):\n                opRunner = std::make_unique<OpenSSL_bignum::Exp>();\n                break;\n            case    CF_CALCOP(\"Abs(A)\"):\n                opRunner = std::make_unique<OpenSSL_bignum::Abs>();\n                break;\n            case    CF_CALCOP(\"RShift(A,B)\"):\n                opRunner = std::make_unique<OpenSSL_bignum::RShift>();\n                break;\n            case    CF_CALCOP(\"LShift1(A)\"):\n                opRunner = std::make_unique<OpenSSL_bignum::LShift1>();\n                break;\n            case    CF_CALCOP(\"SetBit(A,B)\"):\n                opRunner = std::make_unique<OpenSSL_bignum::SetBit>();\n                break;\n            case    CF_CALCOP(\"ClearBit(A,B)\"):\n                opRunner = std::make_unique<OpenSSL_bignum::ClearBit>();\n                break;\n            case    CF_CALCOP(\"Bit(A,B)\"):\n                opRunner = std::make_unique<OpenSSL_bignum::Bit>();\n                break;\n            case    CF_CALCOP(\"CmpAbs(A,B)\"):\n                opRunner = std::make_unique<OpenSSL_bignum::CmpAbs>();\n                break;\n            case    CF_CALCOP(\"ModLShift(A,B,C)\"):\n                opRunner = std::make_unique<OpenSSL_bignum::ModLShift>();\n                break;\n            case    CF_CALCOP(\"IsPow2(A)\"):\n                opRunner = std::make_unique<OpenSSL_bignum::IsPow2>();\n                break;\n            case    CF_CALCOP(\"Mask(A,B)\"):\n                opRunner = std::make_unique<OpenSSL_bignum::Mask>();\n                break;\n            case    CF_CALCOP(\"IsCoprime(A,B)\"):\n                opRunner = std::make_unique<OpenSSL_bignum::IsCoprime>();\n                break;\n            case    CF_CALCOP(\"Rand()\"):\n                opRunner = std::make_unique<OpenSSL_bignum::Rand>();\n                break;\n            case    CF_CALCOP(\"IsSquare(A)\"):\n                opRunner = std::make_unique<OpenSSL_bignum::IsSquare>();\n                break;\n            case    CF_CALCOP(\"Neg(A)\"):\n                opRunner = std::make_unique<OpenSSL_bignum::Neg>();\n                break;\n            case    CF_CALCOP(\"RandRange(A,B)\"):\n                opRunner = std::make_unique<OpenSSL_bignum::RandRange>();\n                break;\n        }\n\n        CF_CHECK_NE(opRunner, nullptr);\n        CF_CHECK_EQ(opRunner->Run(ds, res, bn, ctx), true);\n\n        ret = res.ToComponentBignum();\n    } catch ( ... ) { }\n\nend:\n    global_ds = nullptr;\n\n    return ret;\n}\n"}
{"text_input": "Generate HMAC_EVP code for openssl_module.h", "output": "        std::optional<component::MAC> OpHMAC_EVP(operation::HMAC& op, Datasource& ds);"}
{"text_input": "Generate HMAC_HMAC code for openssl_module.h", "output": "        std::optional<component::MAC> OpHMAC_HMAC(operation::HMAC& op, Datasource& ds);"}
{"text_input": "Generate SymmetricEncrypt_BIO code for openssl_module.h", "output": "        std::optional<component::Ciphertext> OpSymmetricEncrypt_BIO(operation::SymmetricEncrypt& op, Datasource& ds);"}
{"text_input": "Generate SymmetricEncrypt_EVP code for openssl_module.h", "output": "        std::optional<component::Ciphertext> OpSymmetricEncrypt_EVP(operation::SymmetricEncrypt& op, Datasource& ds);"}
{"text_input": "Generate SymmetricDecrypt_BIO code for openssl_module.h", "output": "        std::optional<component::Cleartext> OpSymmetricDecrypt_BIO(operation::SymmetricDecrypt& op, Datasource& ds);"}
{"text_input": "Generate SymmetricDecrypt_EVP code for openssl_module.h", "output": "        std::optional<component::Cleartext> OpSymmetricDecrypt_EVP(operation::SymmetricDecrypt& op, Datasource& ds);"}
{"text_input": "Generate KDF_SCRYPT_EVP_PKEY code for openssl_module.h", "output": "        std::optional<component::Key> OpKDF_SCRYPT_EVP_PKEY(operation::KDF_SCRYPT& op) const;"}
{"text_input": "Generate KDF_SCRYPT_EVP_KDF code for openssl_module.h", "output": "        std::optional<component::Key> OpKDF_SCRYPT_EVP_KDF(operation::KDF_SCRYPT& op) const;"}
{"text_input": "Generate Digest code for openssl_module.h", "output": "        std::optional<component::Digest> OpDigest(operation::Digest& op) override;"}
{"text_input": "Generate HMAC code for openssl_module.h", "output": "        std::optional<component::MAC> OpHMAC(operation::HMAC& op) override;"}
{"text_input": "Generate SymmetricEncrypt code for openssl_module.h", "output": "        std::optional<component::Ciphertext> OpSymmetricEncrypt(operation::SymmetricEncrypt& op) override;"}
{"text_input": "Generate SymmetricDecrypt code for openssl_module.h", "output": "        std::optional<component::Cleartext> OpSymmetricDecrypt(operation::SymmetricDecrypt& op) override;"}
{"text_input": "Generate KDF_SCRYPT code for openssl_module.h", "output": "        std::optional<component::Key> OpKDF_SCRYPT(operation::KDF_SCRYPT& op) override;"}
{"text_input": "Generate KDF_HKDF code for openssl_module.h", "output": "        std::optional<component::Key> OpKDF_HKDF(operation::KDF_HKDF& op) override;"}
{"text_input": "Generate KDF_TLS1_PRF code for openssl_module.h", "output": "        std::optional<component::Key> OpKDF_TLS1_PRF(operation::KDF_TLS1_PRF& op) override;"}
{"text_input": "Generate KDF_PBKDF code for openssl_module.h", "output": "        std::optional<component::Key> OpKDF_PBKDF(operation::KDF_PBKDF& op) override;"}
{"text_input": "Generate KDF_PBKDF2 code for openssl_module.h", "output": "        std::optional<component::Key> OpKDF_PBKDF2(operation::KDF_PBKDF2& op) override;"}
{"text_input": "Generate KDF_ARGON2 code for openssl_module.h", "output": "        std::optional<component::Key> OpKDF_ARGON2(operation::KDF_ARGON2& op) override;"}
{"text_input": "Generate KDF_SSH code for openssl_module.h", "output": "        std::optional<component::Key> OpKDF_SSH(operation::KDF_SSH& op) override;"}
{"text_input": "Generate KDF_X963 code for openssl_module.h", "output": "        std::optional<component::Key> OpKDF_X963(operation::KDF_X963& op) override;"}
{"text_input": "Generate KDF_SP_800_108 code for openssl_module.h", "output": "        std::optional<component::Key> OpKDF_SP_800_108(operation::KDF_SP_800_108& op) override;"}
{"text_input": "Generate CMAC code for openssl_module.h", "output": "        std::optional<component::MAC> OpCMAC(operation::CMAC& op) override;"}
{"text_input": "Generate ECC_PrivateToPublic code for openssl_module.h", "output": "        std::optional<component::ECC_PublicKey> OpECC_PrivateToPublic(operation::ECC_PrivateToPublic& op) override;"}
{"text_input": "Generate ECC_ValidatePubkey code for openssl_module.h", "output": "        std::optional<bool> OpECC_ValidatePubkey(operation::ECC_ValidatePubkey& op) override;"}
{"text_input": "Generate ECC_GenerateKeyPair code for openssl_module.h", "output": "        std::optional<component::ECC_KeyPair> OpECC_GenerateKeyPair(operation::ECC_GenerateKeyPair& op) override;"}
{"text_input": "Generate ECDSA_Sign code for openssl_module.h", "output": "        std::optional<component::ECDSA_Signature> OpECDSA_Sign(operation::ECDSA_Sign& op) override;"}
{"text_input": "Generate ECDSA_Verify code for openssl_module.h", "output": "        std::optional<bool> OpECDSA_Verify(operation::ECDSA_Verify& op) override;"}
{"text_input": "Generate ECDH_Derive code for openssl_module.h", "output": "        std::optional<component::Secret> OpECDH_Derive(operation::ECDH_Derive& op) override;"}
{"text_input": "Generate DH_GenerateKeyPair code for openssl_module.h", "output": "        std::optional<component::DH_KeyPair> OpDH_GenerateKeyPair(operation::DH_GenerateKeyPair& op) override;"}
{"text_input": "Generate DH_Derive code for openssl_module.h", "output": "        std::optional<component::Bignum> OpDH_Derive(operation::DH_Derive& op) override;"}
{"text_input": "Generate DSA_GenerateParameters code for openssl_module.h", "output": "        std::optional<component::DSA_Parameters> OpDSA_GenerateParameters(operation::DSA_GenerateParameters& op) override;"}
{"text_input": "Generate DSA_PrivateToPublic code for openssl_module.h", "output": "        std::optional<component::Bignum> OpDSA_PrivateToPublic(operation::DSA_PrivateToPublic& op) override;"}
{"text_input": "Generate DSA_Sign code for openssl_module.h", "output": "        std::optional<component::DSA_Signature> OpDSA_Sign(operation::DSA_Sign& op) override;"}
{"text_input": "Generate DSA_Verify code for openssl_module.h", "output": "        std::optional<bool> OpDSA_Verify(operation::DSA_Verify& op) override;"}
{"text_input": "Generate ECC_Point_Add code for openssl_module.h", "output": "        std::optional<component::ECC_Point> OpECC_Point_Add(operation::ECC_Point_Add& op) override;"}
{"text_input": "Generate ECC_Point_Mul code for openssl_module.h", "output": "        std::optional<component::ECC_Point> OpECC_Point_Mul(operation::ECC_Point_Mul& op) override;"}
{"text_input": "Generate ECC_Point_Neg code for openssl_module.h", "output": "        std::optional<component::ECC_Point> OpECC_Point_Neg(operation::ECC_Point_Neg& op) override;"}
{"text_input": "Generate ECC_Point_Dbl code for openssl_module.h", "output": "        std::optional<component::ECC_Point> OpECC_Point_Dbl(operation::ECC_Point_Dbl& op) override;"}
{"text_input": "Generate ECC_Point_Cmp code for openssl_module.h", "output": "        std::optional<bool> OpECC_Point_Cmp(operation::ECC_Point_Cmp& op) override;"}
{"text_input": "Generate BignumCalc code for openssl_module.h", "output": "        std::optional<component::Bignum> OpBignumCalc(operation::BignumCalc& op) override;"}
{"text_input": "Generate BLS_Aggregate_G1 code for gen_repository.py", "output": "operations.Add( Operation(\"BLS_Aggregate_G1\") )"}
{"text_input": "Generate BLS_Aggregate_G2 code for gen_repository.py", "output": "operations.Add( Operation(\"BLS_Aggregate_G2\") )"}
{"text_input": "Generate BLS_BatchSign code for gen_repository.py", "output": "operations.Add( Operation(\"BLS_BatchSign\") )"}
{"text_input": "Generate BLS_BatchVerify code for gen_repository.py", "output": "operations.Add( Operation(\"BLS_BatchVerify\") )"}
{"text_input": "Generate BLS_Compress_G1 code for gen_repository.py", "output": "operations.Add( Operation(\"BLS_Compress_G1\") )"}
{"text_input": "Generate BLS_Compress_G2 code for gen_repository.py", "output": "operations.Add( Operation(\"BLS_Compress_G2\") )"}
{"text_input": "Generate BLS_Decompress_G1 code for gen_repository.py", "output": "operations.Add( Operation(\"BLS_Decompress_G1\") )"}
{"text_input": "Generate BLS_Decompress_G2 code for gen_repository.py", "output": "operations.Add( Operation(\"BLS_Decompress_G2\") )"}
{"text_input": "Generate BLS_FinalExp code for gen_repository.py", "output": "operations.Add( Operation(\"BLS_FinalExp\") )"}
{"text_input": "Generate BLS_G1_Add code for gen_repository.py", "output": "operations.Add( Operation(\"BLS_G1_Add\") )"}
{"text_input": "Generate BLS_G1_IsEq code for gen_repository.py", "output": "operations.Add( Operation(\"BLS_G1_IsEq\") )"}
{"text_input": "Generate BLS_G1_Mul code for gen_repository.py", "output": "operations.Add( Operation(\"BLS_G1_Mul\") )"}
{"text_input": "Generate BLS_G1_MultiExp code for gen_repository.py", "output": "operations.Add( Operation(\"BLS_G1_MultiExp\") )"}
{"text_input": "Generate BLS_G1_Neg code for gen_repository.py", "output": "operations.Add( Operation(\"BLS_G1_Neg\") )"}
{"text_input": "Generate BLS_G2_Add code for gen_repository.py", "output": "operations.Add( Operation(\"BLS_G2_Add\") )"}
{"text_input": "Generate BLS_G2_IsEq code for gen_repository.py", "output": "operations.Add( Operation(\"BLS_G2_IsEq\") )"}
{"text_input": "Generate BLS_G2_Mul code for gen_repository.py", "output": "operations.Add( Operation(\"BLS_G2_Mul\") )"}
{"text_input": "Generate BLS_G2_Neg code for gen_repository.py", "output": "operations.Add( Operation(\"BLS_G2_Neg\") )"}
{"text_input": "Generate BLS_GenerateKeyPair code for gen_repository.py", "output": "operations.Add( Operation(\"BLS_GenerateKeyPair\") )"}
{"text_input": "Generate BLS_HashToG1 code for gen_repository.py", "output": "operations.Add( Operation(\"BLS_HashToG1\") )"}
{"text_input": "Generate BLS_HashToG2 code for gen_repository.py", "output": "operations.Add( Operation(\"BLS_HashToG2\") )"}
{"text_input": "Generate BLS_IsG1OnCurve code for gen_repository.py", "output": "operations.Add( Operation(\"BLS_IsG1OnCurve\") )"}
{"text_input": "Generate BLS_IsG2OnCurve code for gen_repository.py", "output": "operations.Add( Operation(\"BLS_IsG2OnCurve\") )"}
{"text_input": "Generate BLS_MapToG1 code for gen_repository.py", "output": "operations.Add( Operation(\"BLS_MapToG1\") )"}
{"text_input": "Generate BLS_MapToG2 code for gen_repository.py", "output": "operations.Add( Operation(\"BLS_MapToG2\") )"}
{"text_input": "Generate BLS_MillerLoop code for gen_repository.py", "output": "operations.Add( Operation(\"BLS_MillerLoop\") )"}
{"text_input": "Generate BLS_Pairing code for gen_repository.py", "output": "operations.Add( Operation(\"BLS_Pairing\") )"}
{"text_input": "Generate BLS_PrivateToPublic code for gen_repository.py", "output": "operations.Add( Operation(\"BLS_PrivateToPublic\") )"}
{"text_input": "Generate BLS_PrivateToPublic_G2 code for gen_repository.py", "output": "operations.Add( Operation(\"BLS_PrivateToPublic_G2\") )"}
{"text_input": "Generate BLS_Sign code for gen_repository.py", "output": "operations.Add( Operation(\"BLS_Sign\") )"}
{"text_input": "Generate BLS_Verify code for gen_repository.py", "output": "operations.Add( Operation(\"BLS_Verify\") )"}
{"text_input": "Generate BignumCalc code for gen_repository.py", "output": "operations.Add( Operation(\"BignumCalc\") )"}
{"text_input": "Generate BignumCalc_Fp12 code for gen_repository.py", "output": "operations.Add( Operation(\"BignumCalc_Fp12\") )"}
{"text_input": "Generate BignumCalc_Fp2 code for gen_repository.py", "output": "operations.Add( Operation(\"BignumCalc_Fp2\") )"}
{"text_input": "Generate BignumCalc_Mod_2Exp128 code for gen_repository.py", "output": "operations.Add( Operation(\"BignumCalc_Mod_2Exp128\") )"}
{"text_input": "Generate BignumCalc_Mod_2Exp256 code for gen_repository.py", "output": "operations.Add( Operation(\"BignumCalc_Mod_2Exp256\") )"}
{"text_input": "Generate BignumCalc_Mod_2Exp512 code for gen_repository.py", "output": "operations.Add( Operation(\"BignumCalc_Mod_2Exp512\") )"}
{"text_input": "Generate BignumCalc_Mod_2Exp64 code for gen_repository.py", "output": "operations.Add( Operation(\"BignumCalc_Mod_2Exp64\") )"}
{"text_input": "Generate BignumCalc_Mod_BLS12_377_P code for gen_repository.py", "output": "operations.Add( Operation(\"BignumCalc_Mod_BLS12_377_P\") )"}
{"text_input": "Generate BignumCalc_Mod_BLS12_377_R code for gen_repository.py", "output": "operations.Add( Operation(\"BignumCalc_Mod_BLS12_377_R\") )"}
{"text_input": "Generate BignumCalc_Mod_BLS12_381_P code for gen_repository.py", "output": "operations.Add( Operation(\"BignumCalc_Mod_BLS12_381_P\") )"}
{"text_input": "Generate BignumCalc_Mod_BLS12_381_R code for gen_repository.py", "output": "operations.Add( Operation(\"BignumCalc_Mod_BLS12_381_R\") )"}
{"text_input": "Generate BignumCalc_Mod_BN128_P code for gen_repository.py", "output": "operations.Add( Operation(\"BignumCalc_Mod_BN128_P\") )"}
{"text_input": "Generate BignumCalc_Mod_BN128_R code for gen_repository.py", "output": "operations.Add( Operation(\"BignumCalc_Mod_BN128_R\") )"}
{"text_input": "Generate BignumCalc_Mod_ED25519 code for gen_repository.py", "output": "operations.Add( Operation(\"BignumCalc_Mod_ED25519\") )"}
{"text_input": "Generate BignumCalc_Mod_Edwards_P code for gen_repository.py", "output": "operations.Add( Operation(\"BignumCalc_Mod_Edwards_P\") )"}
{"text_input": "Generate BignumCalc_Mod_Edwards_R code for gen_repository.py", "output": "operations.Add( Operation(\"BignumCalc_Mod_Edwards_R\") )"}
{"text_input": "Generate BignumCalc_Mod_Goldilocks code for gen_repository.py", "output": "operations.Add( Operation(\"BignumCalc_Mod_Goldilocks\") )"}
{"text_input": "Generate BignumCalc_Mod_MNT4_P code for gen_repository.py", "output": "operations.Add( Operation(\"BignumCalc_Mod_MNT4_P\") )"}
{"text_input": "Generate BignumCalc_Mod_MNT4_R code for gen_repository.py", "output": "operations.Add( Operation(\"BignumCalc_Mod_MNT4_R\") )"}
{"text_input": "Generate BignumCalc_Mod_MNT6_P code for gen_repository.py", "output": "operations.Add( Operation(\"BignumCalc_Mod_MNT6_P\") )"}
{"text_input": "Generate BignumCalc_Mod_MNT6_R code for gen_repository.py", "output": "operations.Add( Operation(\"BignumCalc_Mod_MNT6_R\") )"}
{"text_input": "Generate BignumCalc_Mod_SECP256K1 code for gen_repository.py", "output": "operations.Add( Operation(\"BignumCalc_Mod_SECP256K1\") )"}
{"text_input": "Generate BignumCalc_Mod_SECP256K1_P code for gen_repository.py", "output": "operations.Add( Operation(\"BignumCalc_Mod_SECP256K1_P\") )"}
{"text_input": "Generate BignumCalc_Mod_Vesta_P code for gen_repository.py", "output": "operations.Add( Operation(\"BignumCalc_Mod_Vesta_P\") )"}
{"text_input": "Generate BignumCalc_Mod_Vesta_R code for gen_repository.py", "output": "operations.Add( Operation(\"BignumCalc_Mod_Vesta_R\") )"}
{"text_input": "Generate CMAC code for gen_repository.py", "output": "operations.Add( Operation(\"CMAC\") )"}
{"text_input": "Generate DH_Derive code for gen_repository.py", "output": "operations.Add( Operation(\"DH_Derive\") )"}
{"text_input": "Generate DH_GenerateKeyPair code for gen_repository.py", "output": "operations.Add( Operation(\"DH_GenerateKeyPair\") )"}
{"text_input": "Generate DSA_GenerateKeyPair code for gen_repository.py", "output": "operations.Add( Operation(\"DSA_GenerateKeyPair\") )"}
{"text_input": "Generate DSA_GenerateParameters code for gen_repository.py", "output": "operations.Add( Operation(\"DSA_GenerateParameters\") )"}
{"text_input": "Generate DSA_PrivateToPublic code for gen_repository.py", "output": "operations.Add( Operation(\"DSA_PrivateToPublic\") )"}
{"text_input": "Generate DSA_Sign code for gen_repository.py", "output": "operations.Add( Operation(\"DSA_Sign\") )"}
{"text_input": "Generate DSA_Verify code for gen_repository.py", "output": "operations.Add( Operation(\"DSA_Verify\") )"}
{"text_input": "Generate Digest code for gen_repository.py", "output": "operations.Add( Operation(\"Digest\") )"}
{"text_input": "Generate ECCSI_Sign code for gen_repository.py", "output": "operations.Add( Operation(\"ECCSI_Sign\") )"}
{"text_input": "Generate ECCSI_Verify code for gen_repository.py", "output": "operations.Add( Operation(\"ECCSI_Verify\") )"}
{"text_input": "Generate ECC_GenerateKeyPair code for gen_repository.py", "output": "operations.Add( Operation(\"ECC_GenerateKeyPair\") )"}
{"text_input": "Generate ECC_Point_Add code for gen_repository.py", "output": "operations.Add( Operation(\"ECC_Point_Add\") )"}
{"text_input": "Generate ECC_Point_Cmp code for gen_repository.py", "output": "operations.Add( Operation(\"ECC_Point_Cmp\") )"}
{"text_input": "Generate ECC_Point_Dbl code for gen_repository.py", "output": "operations.Add( Operation(\"ECC_Point_Dbl\") )"}
{"text_input": "Generate ECC_Point_Mul code for gen_repository.py", "output": "operations.Add( Operation(\"ECC_Point_Mul\") )"}
{"text_input": "Generate ECC_Point_Neg code for gen_repository.py", "output": "operations.Add( Operation(\"ECC_Point_Neg\") )"}
{"text_input": "Generate ECC_Point_Sub code for gen_repository.py", "output": "operations.Add( Operation(\"ECC_Point_Sub\") )"}
{"text_input": "Generate ECC_PrivateToPublic code for gen_repository.py", "output": "operations.Add( Operation(\"ECC_PrivateToPublic\") )"}
{"text_input": "Generate ECC_ValidatePubkey code for gen_repository.py", "output": "operations.Add( Operation(\"ECC_ValidatePubkey\") )"}
{"text_input": "Generate ECDH_Derive code for gen_repository.py", "output": "operations.Add( Operation(\"ECDH_Derive\") )"}
{"text_input": "Generate ECDSA_Recover code for gen_repository.py", "output": "operations.Add( Operation(\"ECDSA_Recover\") )"}
{"text_input": "Generate ECDSA_Sign code for gen_repository.py", "output": "operations.Add( Operation(\"ECDSA_Sign\") )"}
{"text_input": "Generate ECDSA_Verify code for gen_repository.py", "output": "operations.Add( Operation(\"ECDSA_Verify\") )"}
{"text_input": "Generate ECGDSA_Sign code for gen_repository.py", "output": "operations.Add( Operation(\"ECGDSA_Sign\") )"}
{"text_input": "Generate ECGDSA_Verify code for gen_repository.py", "output": "operations.Add( Operation(\"ECGDSA_Verify\") )"}
{"text_input": "Generate ECIES_Decrypt code for gen_repository.py", "output": "operations.Add( Operation(\"ECIES_Decrypt\") )"}
{"text_input": "Generate ECIES_Encrypt code for gen_repository.py", "output": "operations.Add( Operation(\"ECIES_Encrypt\") )"}
{"text_input": "Generate ECRDSA_Sign code for gen_repository.py", "output": "operations.Add( Operation(\"ECRDSA_Sign\") )"}
{"text_input": "Generate ECRDSA_Verify code for gen_repository.py", "output": "operations.Add( Operation(\"ECRDSA_Verify\") )"}
{"text_input": "Generate HMAC code for gen_repository.py", "output": "operations.Add( Operation(\"HMAC\") )"}
{"text_input": "Generate KDF_ARGON2 code for gen_repository.py", "output": "operations.Add( Operation(\"KDF_ARGON2\") )"}
{"text_input": "Generate KDF_BCRYPT code for gen_repository.py", "output": "operations.Add( Operation(\"KDF_BCRYPT\") )"}
{"text_input": "Generate KDF_HKDF code for gen_repository.py", "output": "operations.Add( Operation(\"KDF_HKDF\") )"}
{"text_input": "Generate KDF_PBKDF code for gen_repository.py", "output": "operations.Add( Operation(\"KDF_PBKDF\") )"}
{"text_input": "Generate KDF_PBKDF1 code for gen_repository.py", "output": "operations.Add( Operation(\"KDF_PBKDF1\") )"}
{"text_input": "Generate KDF_PBKDF2 code for gen_repository.py", "output": "operations.Add( Operation(\"KDF_PBKDF2\") )"}
{"text_input": "Generate KDF_SCRYPT code for gen_repository.py", "output": "operations.Add( Operation(\"KDF_SCRYPT\") )"}
{"text_input": "Generate KDF_SP_800_108 code for gen_repository.py", "output": "operations.Add( Operation(\"KDF_SP_800_108\") )"}
{"text_input": "Generate KDF_SRTCP code for gen_repository.py", "output": "operations.Add( Operation(\"KDF_SRTCP\") )"}
{"text_input": "Generate KDF_SRTP code for gen_repository.py", "output": "operations.Add( Operation(\"KDF_SRTP\") )"}
{"text_input": "Generate KDF_SSH code for gen_repository.py", "output": "operations.Add( Operation(\"KDF_SSH\") )"}
{"text_input": "Generate KDF_TLS1_PRF code for gen_repository.py", "output": "operations.Add( Operation(\"KDF_TLS1_PRF\") )"}
{"text_input": "Generate KDF_X963 code for gen_repository.py", "output": "operations.Add( Operation(\"KDF_X963\") )"}
{"text_input": "Generate Misc code for gen_repository.py", "output": "operations.Add( Operation(\"Misc\") )"}
{"text_input": "Generate SR25519_Verify code for gen_repository.py", "output": "operations.Add( Operation(\"SR25519_Verify\") )"}
{"text_input": "Generate Schnorr_Sign code for gen_repository.py", "output": "operations.Add( Operation(\"Schnorr_Sign\") )"}
{"text_input": "Generate Schnorr_Verify code for gen_repository.py", "output": "operations.Add( Operation(\"Schnorr_Verify\") )"}
{"text_input": "Generate SymmetricDecrypt code for gen_repository.py", "output": "operations.Add( Operation(\"SymmetricDecrypt\") )"}
{"text_input": "Generate SymmetricEncrypt code for gen_repository.py", "output": "operations.Add( Operation(\"SymmetricEncrypt\") )"}
{"text_input": "Generate UMAC code for gen_repository.py", "output": "operations.Add( Operation(\"UMAC\") )"}
{"text_input": "Generate Digest code for tests.h", "output": "void test(const operation::Digest& op, const std::optional<component::Digest>& result);"}
{"text_input": "Generate HMAC code for tests.h", "output": "void test(const operation::HMAC& op, const std::optional<component::MAC>& result);"}
{"text_input": "Generate UMAC code for tests.h", "output": "void test(const operation::UMAC& op, const std::optional<component::MAC>& result);"}
{"text_input": "Generate SymmetricEncrypt code for tests.h", "output": "void test(const operation::SymmetricEncrypt& op, const std::optional<component::Ciphertext>& result);"}
{"text_input": "Generate SymmetricDecrypt code for tests.h", "output": "void test(const operation::SymmetricDecrypt& op, const std::optional<component::Cleartext>& result);"}
{"text_input": "Generate CMAC code for tests.h", "output": "void test(const operation::CMAC& op, const std::optional<component::MAC>& result);"}
{"text_input": "Generate KDF_SCRYPT code for tests.h", "output": "void test(const operation::KDF_SCRYPT& op, const std::optional<component::Key>& result);"}
{"text_input": "Generate KDF_HKDF code for tests.h", "output": "void test(const operation::KDF_HKDF& op, const std::optional<component::Key>& result);"}
{"text_input": "Generate KDF_TLS1_PRF code for tests.h", "output": "void test(const operation::KDF_TLS1_PRF& op, const std::optional<component::Key>& result);"}
{"text_input": "Generate KDF_PBKDF code for tests.h", "output": "void test(const operation::KDF_PBKDF& op, const std::optional<component::Key>& result);"}
{"text_input": "Generate KDF_PBKDF1 code for tests.h", "output": "void test(const operation::KDF_PBKDF1& op, const std::optional<component::Key>& result);"}
{"text_input": "Generate KDF_PBKDF2 code for tests.h", "output": "void test(const operation::KDF_PBKDF2& op, const std::optional<component::Key>& result);"}
{"text_input": "Generate KDF_ARGON2 code for tests.h", "output": "void test(const operation::KDF_ARGON2& op, const std::optional<component::Key>& result);"}
{"text_input": "Generate KDF_SSH code for tests.h", "output": "void test(const operation::KDF_SSH& op, const std::optional<component::Key>& result);"}
{"text_input": "Generate KDF_X963 code for tests.h", "output": "void test(const operation::KDF_X963& op, const std::optional<component::Key>& result);"}
{"text_input": "Generate KDF_BCRYPT code for tests.h", "output": "void test(const operation::KDF_BCRYPT& op, const std::optional<component::Key>& result);"}
{"text_input": "Generate KDF_SP_800_108 code for tests.h", "output": "void test(const operation::KDF_SP_800_108& op, const std::optional<component::Key>& result);"}
{"text_input": "Generate KDF_SRTP code for tests.h", "output": "void test(const operation::KDF_SRTP& op, const std::optional<component::Key3>& result);"}
{"text_input": "Generate KDF_SRTCP code for tests.h", "output": "void test(const operation::KDF_SRTCP& op, const std::optional<component::Key3>& result);"}
{"text_input": "Generate ECC_PrivateToPublic code for tests.h", "output": "void test(const operation::ECC_PrivateToPublic& op, const std::optional<component::ECC_PublicKey>& result);"}
{"text_input": "Generate ECC_ValidatePubkey code for tests.h", "output": "void test(const operation::ECC_ValidatePubkey& op, const std::optional<bool>& result);"}
{"text_input": "Generate ECC_GenerateKeyPair code for tests.h", "output": "void test(const operation::ECC_GenerateKeyPair& op, const std::optional<component::ECC_KeyPair>& result);"}
{"text_input": "Generate ECCSI_Sign code for tests.h", "output": "void test(const operation::ECCSI_Sign& op, const std::optional<component::ECCSI_Signature>& result);"}
{"text_input": "Generate ECDSA_Sign code for tests.h", "output": "void test(const operation::ECDSA_Sign& op, const std::optional<component::ECDSA_Signature>& result);"}
{"text_input": "Generate ECGDSA_Sign code for tests.h", "output": "void test(const operation::ECGDSA_Sign& op, const std::optional<component::ECGDSA_Signature>& result);"}
{"text_input": "Generate ECRDSA_Sign code for tests.h", "output": "void test(const operation::ECRDSA_Sign& op, const std::optional<component::ECRDSA_Signature>& result);"}
{"text_input": "Generate Schnorr_Sign code for tests.h", "output": "void test(const operation::Schnorr_Sign& op, const std::optional<component::Schnorr_Signature>& result);"}
{"text_input": "Generate ECCSI_Verify code for tests.h", "output": "void test(const operation::ECCSI_Verify& op, const std::optional<bool>& result);"}
{"text_input": "Generate ECDSA_Verify code for tests.h", "output": "void test(const operation::ECDSA_Verify& op, const std::optional<bool>& result);"}
{"text_input": "Generate ECGDSA_Verify code for tests.h", "output": "void test(const operation::ECGDSA_Verify& op, const std::optional<bool>& result);"}
{"text_input": "Generate ECRDSA_Verify code for tests.h", "output": "void test(const operation::ECRDSA_Verify& op, const std::optional<bool>& result);"}
{"text_input": "Generate Schnorr_Verify code for tests.h", "output": "void test(const operation::Schnorr_Verify& op, const std::optional<bool>& result);"}
{"text_input": "Generate ECDSA_Recover code for tests.h", "output": "void test(const operation::ECDSA_Recover& op, const std::optional<component::ECC_PublicKey>& result);"}
{"text_input": "Generate DSA_Verify code for tests.h", "output": "void test(const operation::DSA_Verify& op, const std::optional<bool>& result);"}
{"text_input": "Generate DSA_Sign code for tests.h", "output": "void test(const operation::DSA_Sign& op, const std::optional<component::DSA_Signature>& result);"}
{"text_input": "Generate DSA_GenerateParameters code for tests.h", "output": "void test(const operation::DSA_GenerateParameters& op, const std::optional<component::DSA_Parameters>& result);"}
{"text_input": "Generate DSA_PrivateToPublic code for tests.h", "output": "void test(const operation::DSA_PrivateToPublic& op, const std::optional<component::Bignum>& result);"}
{"text_input": "Generate DSA_GenerateKeyPair code for tests.h", "output": "void test(const operation::DSA_GenerateKeyPair& op, const std::optional<component::DSA_KeyPair>& result);"}
{"text_input": "Generate ECDH_Derive code for tests.h", "output": "void test(const operation::ECDH_Derive& op, const std::optional<component::Secret>& result);"}
{"text_input": "Generate ECIES_Encrypt code for tests.h", "output": "void test(const operation::ECIES_Encrypt& op, const std::optional<component::Ciphertext>& result);"}
{"text_input": "Generate ECIES_Decrypt code for tests.h", "output": "void test(const operation::ECIES_Decrypt& op, const std::optional<component::Cleartext>& result);"}
{"text_input": "Generate ECC_Point_Add code for tests.h", "output": "void test(const operation::ECC_Point_Add& op, const std::optional<component::ECC_Point>& result);"}
{"text_input": "Generate ECC_Point_Sub code for tests.h", "output": "void test(const operation::ECC_Point_Sub& op, const std::optional<component::ECC_Point>& result);"}
{"text_input": "Generate ECC_Point_Mul code for tests.h", "output": "void test(const operation::ECC_Point_Mul& op, const std::optional<component::ECC_Point>& result);"}
{"text_input": "Generate ECC_Point_Neg code for tests.h", "output": "void test(const operation::ECC_Point_Neg& op, const std::optional<component::ECC_Point>& result);"}
{"text_input": "Generate ECC_Point_Dbl code for tests.h", "output": "void test(const operation::ECC_Point_Dbl& op, const std::optional<component::ECC_Point>& result);"}
{"text_input": "Generate ECC_Point_Cmp code for tests.h", "output": "void test(const operation::ECC_Point_Cmp& op, const std::optional<bool>& result);"}
{"text_input": "Generate DH_GenerateKeyPair code for tests.h", "output": "void test(const operation::DH_GenerateKeyPair& op, const std::optional<component::DH_KeyPair>& result);"}
{"text_input": "Generate DH_Derive code for tests.h", "output": "void test(const operation::DH_Derive& op, const std::optional<component::Bignum>& result);"}
{"text_input": "Generate BignumCalc code for tests.h", "output": "void test(const operation::BignumCalc& op, const std::optional<component::Bignum>& result);"}
{"text_input": "Generate BignumCalc_Fp2 code for tests.h", "output": "void test(const operation::BignumCalc_Fp2& op, const std::optional<component::Fp2>& result);"}
{"text_input": "Generate BignumCalc_Fp12 code for tests.h", "output": "void test(const operation::BignumCalc_Fp12& op, const std::optional<component::Fp12>& result);"}
{"text_input": "Generate BLS_PrivateToPublic code for tests.h", "output": "void test(const operation::BLS_PrivateToPublic& op, const std::optional<component::BLS_PublicKey>& result);"}
{"text_input": "Generate BLS_PrivateToPublic_G2 code for tests.h", "output": "void test(const operation::BLS_PrivateToPublic_G2& op, const std::optional<component::G2>& result);"}
{"text_input": "Generate BLS_Sign code for tests.h", "output": "void test(const operation::BLS_Sign& op, const std::optional<component::BLS_Signature>& result);"}
{"text_input": "Generate BLS_Verify code for tests.h", "output": "void test(const operation::BLS_Verify& op, const std::optional<bool>& result);"}
{"text_input": "Generate BLS_BatchSign code for tests.h", "output": "void test(const operation::BLS_BatchSign& op, const std::optional<component::BLS_BatchSignature>& result);"}
{"text_input": "Generate BLS_BatchVerify code for tests.h", "output": "void test(const operation::BLS_BatchVerify& op, const std::optional<bool>& result);"}
{"text_input": "Generate BLS_Aggregate_G1 code for tests.h", "output": "void test(const operation::BLS_Aggregate_G1& op, const std::optional<component::G1>& result);"}
{"text_input": "Generate BLS_Aggregate_G2 code for tests.h", "output": "void test(const operation::BLS_Aggregate_G2& op, const std::optional<component::G2>& result);"}
{"text_input": "Generate BLS_Pairing code for tests.h", "output": "void test(const operation::BLS_Pairing& op, const std::optional<component::Fp12>& result);"}
{"text_input": "Generate BLS_MillerLoop code for tests.h", "output": "void test(const operation::BLS_MillerLoop& op, const std::optional<component::Fp12>& result);"}
{"text_input": "Generate BLS_FinalExp code for tests.h", "output": "void test(const operation::BLS_FinalExp& op, const std::optional<component::Fp12>& result);"}
{"text_input": "Generate BLS_HashToG1 code for tests.h", "output": "void test(const operation::BLS_HashToG1& op, const std::optional<component::G1>& result);"}
{"text_input": "Generate BLS_HashToG2 code for tests.h", "output": "void test(const operation::BLS_HashToG2& op, const std::optional<component::G2>& result);"}
{"text_input": "Generate BLS_MapToG1 code for tests.h", "output": "void test(const operation::BLS_MapToG1& op, const std::optional<component::G1>& result);"}
{"text_input": "Generate BLS_MapToG2 code for tests.h", "output": "void test(const operation::BLS_MapToG2& op, const std::optional<component::G2>& result);"}
{"text_input": "Generate BLS_IsG1OnCurve code for tests.h", "output": "void test(const operation::BLS_IsG1OnCurve& op, const std::optional<bool>& result);"}
{"text_input": "Generate BLS_IsG2OnCurve code for tests.h", "output": "void test(const operation::BLS_IsG2OnCurve& op, const std::optional<bool>& result);"}
{"text_input": "Generate BLS_GenerateKeyPair code for tests.h", "output": "void test(const operation::BLS_GenerateKeyPair& op, const std::optional<component::BLS_KeyPair>& result);"}
{"text_input": "Generate BLS_Decompress_G1 code for tests.h", "output": "void test(const operation::BLS_Decompress_G1& op, const std::optional<component::G1>& result);"}
{"text_input": "Generate BLS_Compress_G1 code for tests.h", "output": "void test(const operation::BLS_Compress_G1& op, const std::optional<component::Bignum>& result);"}
{"text_input": "Generate BLS_Decompress_G2 code for tests.h", "output": "void test(const operation::BLS_Decompress_G2& op, const std::optional<component::G2>& result);"}
{"text_input": "Generate BLS_Compress_G2 code for tests.h", "output": "void test(const operation::BLS_Compress_G2& op, const std::optional<component::G1>& result);"}
{"text_input": "Generate BLS_G1_Add code for tests.h", "output": "void test(const operation::BLS_G1_Add& op, const std::optional<component::G1>& result);"}
{"text_input": "Generate BLS_G1_Mul code for tests.h", "output": "void test(const operation::BLS_G1_Mul& op, const std::optional<component::G1>& result);"}
{"text_input": "Generate BLS_G1_IsEq code for tests.h", "output": "void test(const operation::BLS_G1_IsEq& op, const std::optional<bool>& result);"}
{"text_input": "Generate BLS_G1_Neg code for tests.h", "output": "void test(const operation::BLS_G1_Neg& op, const std::optional<component::G1>& result);"}
{"text_input": "Generate BLS_G2_Add code for tests.h", "output": "void test(const operation::BLS_G2_Add& op, const std::optional<component::G2>& result);"}
{"text_input": "Generate BLS_G2_Mul code for tests.h", "output": "void test(const operation::BLS_G2_Mul& op, const std::optional<component::G2>& result);"}
{"text_input": "Generate BLS_G2_IsEq code for tests.h", "output": "void test(const operation::BLS_G2_IsEq& op, const std::optional<bool>& result);"}
{"text_input": "Generate BLS_G2_Neg code for tests.h", "output": "void test(const operation::BLS_G2_Neg& op, const std::optional<component::G2>& result);"}
{"text_input": "Generate BLS_G1_MultiExp code for tests.h", "output": "void test(const operation::BLS_G1_MultiExp& op, const std::optional<component::G1>& result);"}
{"text_input": "Generate Misc code for tests.h", "output": "void test(const operation::Misc& op, const std::optional<Buffer>& result);"}
{"text_input": "Generate SR25519_Verify code for tests.h", "output": "void test(const operation::SR25519_Verify& op, const std::optional<bool>& result);"}
{"text_input": "Generate Digest code for tests.cpp", "output": "void test(const operation::Digest& op, const std::optional<component::Digest>& result) {\n    if ( result == std::nullopt ) {\n        return;\n    }\n\n    {\n        const auto expectedSize = repository::DigestSize(op.digestType.Get());\n\n        if ( expectedSize != std::nullopt ) {\n            if ( result->GetSize() != *expectedSize ) {\n                printf(\"Expected vs actual digest size: %zu / %zu\\n\", *expectedSize, result->GetSize());\n                abort();\n            }\n        }\n    }\n\n#if 0\n    if ( op.digestType.Is(CF_DIGEST(\"SHA1\")) ) {\n        /* https://words.filippo.io/dispatches/seeds-bounty/ */\n\n        static const std::vector< std::vector<uint8_t> > hashes{\n            /* NIST P-192 */\n            {\n                0x30, 0x45, 0xAE, 0x6F, 0xC8, 0x42, 0x2F, 0x64, 0xED, 0x57,\n                    0x95, 0x28, 0xD3, 0x81, 0x20, 0xEA, 0xE1, 0x21, 0x96, 0xD5,\n            },\n            /* NIST P-224 */\n            {\n                0xBD, 0x71, 0x34, 0x47, 0x99, 0xD5, 0xC7, 0xFC, 0xDC, 0x45,\n                0xB5, 0x9F, 0xA3, 0xB9, 0xAB, 0x8F, 0x6A, 0x94, 0x8B, 0xC5,\n            },\n            /* NIST P-256 */\n            {\n                0xC4, 0x9D, 0x36, 0x08, 0x86, 0xE7, 0x04, 0x93, 0x6A, 0x66,\n                0x78, 0xE1, 0x13, 0x9D, 0x26, 0xB7, 0x81, 0x9F, 0x7E, 0x90,\n            },\n            /* NIST P-384 */\n            {\n                0xA3, 0x35, 0x92, 0x6A, 0xA3, 0x19, 0xA2, 0x7A, 0x1D, 0x00,\n                0x89, 0x6A, 0x67, 0x73, 0xA4, 0x82, 0x7A, 0xCD, 0xAC, 0x73,\n            },\n            /* NIST P-521 */\n            {\n                0xD0, 0x9E, 0x88, 0x00, 0x29, 0x1C, 0xB8, 0x53, 0x96, 0xCC,\n                0x67, 0x17, 0x39, 0x32, 0x84, 0xAA, 0xA0, 0xDA, 0x64, 0xBA,\n            },\n            /* ANSI prime192v2 */\n            {\n                0x31, 0xA9, 0x2E, 0xE2, 0x02, 0x9F, 0xD1, 0x0D, 0x90, 0x1B,\n                0x11, 0x3E, 0x99, 0x07, 0x10, 0xF0, 0xD2, 0x1A, 0xC6, 0xB6,\n            },\n            /* ANSI prime192v3 */\n            {\n                0xC4, 0x69, 0x68, 0x44, 0x35, 0xDE, 0xB3, 0x78, 0xC4, 0xB6,\n                0x5C, 0xA9, 0x59, 0x1E, 0x2A, 0x57, 0x63, 0x05, 0x9A, 0x2E,\n            },\n            /* ANSI prime239v1 */\n            {\n                0xE4, 0x3B, 0xB4, 0x60, 0xF0, 0xB8, 0x0C, 0xC0, 0xC0, 0xB0,\n                0x75, 0x79, 0x8E, 0x94, 0x80, 0x60, 0xF8, 0x32, 0x1B, 0x7D,\n            },\n            /* ANSI prime239v2 */\n            {\n                0xE8, 0xB4, 0x01, 0x16, 0x04, 0x09, 0x53, 0x03, 0xCA, 0x3B,\n                0x80, 0x99, 0x98, 0x2B, 0xE0, 0x9F, 0xCB, 0x9A, 0xE6, 0x16,\n            },\n            /* ANSI prime239v3 */\n            {\n                0x7D, 0x73, 0x74, 0x16, 0x8F, 0xFE, 0x34, 0x71, 0xB6, 0x0A,\n                0x85, 0x76, 0x86, 0xA1, 0x94, 0x75, 0xD3, 0xBF, 0xA2, 0xFF,\n            },\n            /* NIST B-163 */\n            {\n                0x85, 0xE2, 0x5B, 0xFE, 0x5C, 0x86, 0x22, 0x6C, 0xDB, 0x12,\n                0x01, 0x6F, 0x75, 0x53, 0xF9, 0xD0, 0xE6, 0x93, 0xA2, 0x68,\n            },\n            /* NIST B-233 */\n            {\n                0x74, 0xD5, 0x9F, 0xF0, 0x7F, 0x6B, 0x41, 0x3D, 0x0E, 0xA1,\n                0x4B, 0x34, 0x4B, 0x20, 0xA2, 0xDB, 0x04, 0x9B, 0x50, 0xC3,\n            },\n            /* NIST B-283 */\n            {\n                0x77, 0xE2, 0xB0, 0x73, 0x70, 0xEB, 0x0F, 0x83, 0x2A, 0x6D,\n                0xD5, 0xB6, 0x2D, 0xFC, 0x88, 0xCD, 0x06, 0xBB, 0x84, 0xBE,\n            },\n            /* NIST B-409 */\n            {\n                0x40, 0x99, 0xB5, 0xA4, 0x57, 0xF9, 0xD6, 0x9F, 0x79, 0x21,\n                0x3D, 0x09, 0x4C, 0x4B, 0xCD, 0x4D, 0x42, 0x62, 0x21, 0x0B,\n            },\n            /* NIST B-571 */\n            {\n                0x2A, 0xA0, 0x58, 0xF7, 0x3A, 0x0E, 0x33, 0xAB, 0x48, 0x6B,\n                0x0F, 0x61, 0x04, 0x10, 0xC5, 0x3A, 0x7F, 0x13, 0x23, 0x10,\n            },\n        };\n\n        for (const auto& hash : hashes) {\n            if ( result->Get() == hash ) abort();\n        }\n    }\n#endif\n\n    checkZeroResult(result);\n}\n\n"}
{"text_input": "Generate HMAC code for tests.cpp", "output": "void test(const operation::HMAC& op, const std::optional<component::MAC>& result) {\n    if ( result == std::nullopt ) {\n        return;\n    }\n\n    {\n        const auto expectedSize = repository::DigestSize(op.digestType.Get());\n\n        if ( expectedSize != std::nullopt ) {\n            if ( result->GetSize() != *expectedSize ) {\n                printf(\"Expected vs actual digest size: %zu / %zu\\n\", *expectedSize, result->GetSize());\n                abort();\n            }\n        }\n    }\n\n    checkZeroResult(result);\n}\n\n"}
{"text_input": "Generate UMAC code for tests.cpp", "output": "void test(const operation::UMAC& op, const std::optional<component::MAC>& result) {\n    if ( result == std::nullopt ) {\n        return;\n    }\n\n    if (\n            ( op.type == 0 && result->GetSize() > (32/8) ) ||\n            ( op.type == 1 && result->GetSize() > (64/8) ) ||\n            ( op.type == 2 && result->GetSize() > (96/8) ) ||\n            ( op.type == 3 && result->GetSize() > (128/8) )\n    ) {\n        printf(\"UMAC: Overlong result: %zu\\n\", result->GetSize());\n        abort();\n    }\n}\n\n    using fuzzing::datasource::ID;\n\n    if ( op.cipher.cipherType.Get() != CF_CIPHER(\"XCHACHA20_POLY1305\") ) {\n        return;\n    }\n\n    if ( result == std::nullopt ) {\n        return;\n    }\n\n    if ( op.cipher.iv.GetSize() != 24 ) {\n        printf(\"XChaCha20-Poly1305 succeeded with an IV of %zu bytes large, but only IVs of 24 bytes are valid\\n\", op.cipher.iv.GetSize());\n        abort();\n    }\n}\n\n    bool fail = false;\n\n    if ( result == std::nullopt ) {\n        return;\n    }\n\n    switch ( op.cipher.cipherType.Get() ) {\n        case CF_CIPHER(\"AES_128_GCM\"):\n        case CF_CIPHER(\"AES_192_GCM\"):\n        case CF_CIPHER(\"AES_256_GCM\"):\n            break;\n        default:\n            return;\n    }\n\n    if ( op.cipher.iv.GetSize() == 0 ) {\n        printf(\"AES GCM: Invalid IV size\\n\");\n        fail = true;\n    }\n\n    if ( fail == true ) {\n        printf(\"AES GCM tests based on Wycheproof: https://github.com/google/wycheproof/blob/4672ff74d68766e7785c2cac4c597effccef2c5c/testvectors/aes_gcm_test.json#L13\\n\");\n        abort();\n    }\n}\n\n"}
{"text_input": "Generate SymmetricEncrypt code for tests.cpp", "output": "void test(const operation::SymmetricEncrypt& op, const std::optional<component::Ciphertext>& result) {\n    test_ChaCha20_Poly1305_IV(op, result);\n    test_XChaCha20_Poly1305_IV(op, result);\n    test_AES_CCM_Wycheproof(op, result);\n    test_AES_GCM_Wycheproof(op, result);\n}\n\n\nstatic void test_ChaCha20_Poly1305_IV(const operation::SymmetricEncrypt& op, const std::optional<component::Ciphertext>& result) {\n    using fuzzing::datasource::ID;\n\n    /*\n     * OpenSSL CVE-2019-1543\n     * https://www.openssl.org/news/secadv/20190306.txt\n     */\n\n    if ( op.cipher.cipherType.Get() != CF_CIPHER(\"CHACHA20_POLY1305\") ) {\n        return;\n    }\n\n    if ( result == std::nullopt ) {\n        return;\n    }\n\n    if ( op.cipher.iv.GetSize() > 12 ) {\n        abort();\n    }\n}\n\n\n\nstatic void test_AES_CCM_Wycheproof(const operation::SymmetricEncrypt& op, const std::optional<component::Ciphertext>& result) {\n    bool fail = false;\n\n    if ( result == std::nullopt ) {\n        return;\n    }\n\n    switch ( op.cipher.cipherType.Get() ) {\n        case CF_CIPHER(\"AES_128_CCM\"):\n        case CF_CIPHER(\"AES_192_CCM\"):\n        case CF_CIPHER(\"AES_256_CCM\"):\n            break;\n        default:\n            return;\n    }\n\n    if ( op.cipher.iv.GetSize() < 7 || op.cipher.iv.GetSize() > 13 ) {\n        printf(\"AES CCM: Invalid IV size\\n\");\n        fail = true;\n    }\n\n    if ( result->tag != std::nullopt ) {\n        static const std::vector<size_t> validTagSizes = {4, 6, 8, 10, 12, 14, 16};\n\n        if ( std::find(validTagSizes.begin(), validTagSizes.end(), result->tag->GetSize()) == validTagSizes.end() ) {\n            printf(\"AES CCM: Invalid tag size\\n\");\n            fail = true;\n        }\n    }\n\n    if ( fail == true ) {\n        printf(\"AES CCM tests based on Wycheproof: https://github.com/google/wycheproof/blob/4672ff74d68766e7785c2cac4c597effccef2c5c/testvectors/aes_ccm_test.json#L11\\n\");\n        abort();\n    }\n}\n\n\n"}
{"text_input": "Generate SymmetricDecrypt code for tests.cpp", "output": "void test(const operation::SymmetricDecrypt& op, const std::optional<component::Cleartext>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}
{"text_input": "Generate CMAC code for tests.cpp", "output": "void test(const operation::CMAC& op, const std::optional<component::MAC>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}
{"text_input": "Generate KDF_SCRYPT code for tests.cpp", "output": "void test(const operation::KDF_SCRYPT& op, const std::optional<component::Key>& result) {\n    verifyKeySize(op, result);\n}\n\n"}
{"text_input": "Generate KDF_HKDF code for tests.cpp", "output": "void test(const operation::KDF_HKDF& op, const std::optional<component::Key>& result) {\n    verifyKeySize(op, result);\n\n    test_HKDF_OutputSize(op, result);\n}\n\n\nstatic void test_HKDF_OutputSize(const operation::KDF_HKDF& op, const std::optional<component::Key>& result) {\n    if ( result == std::nullopt ) {\n        return;\n    }\n\n    const auto expectedSize = repository::DigestSize(op.digestType.Get());\n\n    if ( expectedSize == std::nullopt ) {\n        return;\n    }\n\n    const size_t maxOutputSize = 255 * *expectedSize;\n\n    if ( result->GetSize() > maxOutputSize ) {\n        printf(\"The output size of HKDF (%zu) is more than 255 * the size of the hash digest (%zu)\\n\", result->GetSize(), maxOutputSize);\n        abort();\n    }\n}\n\n\n"}
{"text_input": "Generate KDF_TLS1_PRF code for tests.cpp", "output": "void test(const operation::KDF_TLS1_PRF& op, const std::optional<component::Key>& result) {\n    verifyKeySize(op, result);\n}\n\n"}
{"text_input": "Generate KDF_PBKDF code for tests.cpp", "output": "void test(const operation::KDF_PBKDF& op, const std::optional<component::Key>& result) {\n    verifyKeySize(op, result);\n}\n\n"}
{"text_input": "Generate KDF_PBKDF1 code for tests.cpp", "output": "void test(const operation::KDF_PBKDF1& op, const std::optional<component::Key>& result) {\n    verifyKeySize(op, result);\n}\n\n"}
{"text_input": "Generate KDF_PBKDF2 code for tests.cpp", "output": "void test(const operation::KDF_PBKDF2& op, const std::optional<component::Key>& result) {\n    verifyKeySize(op, result);\n}\n\n"}
{"text_input": "Generate KDF_ARGON2 code for tests.cpp", "output": "void test(const operation::KDF_ARGON2& op, const std::optional<component::Key>& result) {\n    verifyKeySize(op, result);\n}\n\n"}
{"text_input": "Generate KDF_SSH code for tests.cpp", "output": "void test(const operation::KDF_SSH& op, const std::optional<component::Key>& result) {\n    verifyKeySize(op, result);\n}\n\n"}
{"text_input": "Generate KDF_X963 code for tests.cpp", "output": "void test(const operation::KDF_X963& op, const std::optional<component::Key>& result) {\n    verifyKeySize(op, result);\n}\n\n"}
{"text_input": "Generate KDF_BCRYPT code for tests.cpp", "output": "void test(const operation::KDF_BCRYPT& op, const std::optional<component::Key>& result) {\n    verifyKeySize(op, result);\n}\n\n"}
{"text_input": "Generate KDF_SP_800_108 code for tests.cpp", "output": "void test(const operation::KDF_SP_800_108& op, const std::optional<component::Key>& result) {\n    verifyKeySize(op, result);\n}\n\n"}
{"text_input": "Generate KDF_SRTP code for tests.cpp", "output": "void test(const operation::KDF_SRTP& op, const std::optional<component::Key3>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}
{"text_input": "Generate KDF_SRTCP code for tests.cpp", "output": "void test(const operation::KDF_SRTCP& op, const std::optional<component::Key3>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}
{"text_input": "Generate ECC_PrivateToPublic code for tests.cpp", "output": "void test(const operation::ECC_PrivateToPublic& op, const std::optional<component::ECC_PublicKey>& result) {\n    if ( result != std::nullopt ) {\n        test_ECC_PrivateKey(op.curveType.Get(), op.priv.ToTrimmedString());\n    }\n}\n\n\nstatic void test_ECC_PrivateKey(const uint64_t curveID, const std::string priv) {\n    /* Disabled until all modules comply by default */\n    return;\n\n    /* Private key may be 0 with these curves */\n    if ( IsSpecialCurve(curveID) ) {\n        return;\n    }\n\n    if ( priv == \"0\" ) {\n        std::cout << \"0 is an invalid elliptic curve private key\" << std::endl;\n        ::abort();\n    }\n}\n\n\n"}
{"text_input": "Generate ECC_ValidatePubkey code for tests.cpp", "output": "void test(const operation::ECC_ValidatePubkey& op, const std::optional<bool>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}
{"text_input": "Generate ECC_GenerateKeyPair code for tests.cpp", "output": "void test(const operation::ECC_GenerateKeyPair& op, const std::optional<component::ECC_KeyPair>& result) {\n    if ( result != std::nullopt ) {\n        test_ECC_PrivateKey(op.curveType.Get(), result->priv.ToTrimmedString());\n    }\n}\n\n    boost::multiprecision::cpp_int r(R);\n    boost::multiprecision::cpp_int s(S);\n    if ( r < 1 ) {\n        std::cout << \"BIP340 Schnorr signature invalid: R < 1\" << std::endl;\n        ::abort();\n    }\n    if ( s < 1 ) {\n        std::cout << \"BIP340 Schnorr signature invalid: S < 1\" << std::endl;\n        ::abort();\n    }\n\n    const auto prime = cryptofuzz::repository::ECC_CurveToPrime(curveID);\n    if ( prime != std::nullopt ) {\n        const boost::multiprecision::cpp_int p(*prime);\n        CF_ASSERT(r < p, \"BIP340 Schnorr signature R should be less than curve P\");\n    }\n\n    const auto order = cryptofuzz::repository::ECC_CurveToOrder(curveID);\n    if ( order != std::nullopt ) {\n        const boost::multiprecision::cpp_int n(*order);\n        CF_ASSERT(s < n, \"BIP340 Schnorr signature S should be less than curve N\");\n    }\n}\n\n\nstatic void test_ECC_PrivateKey(const uint64_t curveID, const std::string priv) {\n    /* Disabled until all modules comply by default */\n    return;\n\n    /* Private key may be 0 with these curves */\n    if ( IsSpecialCurve(curveID) ) {\n        return;\n    }\n\n    if ( priv == \"0\" ) {\n        std::cout << \"0 is an invalid elliptic curve private key\" << std::endl;\n        ::abort();\n    }\n}\n\n\n"}
{"text_input": "Generate ECCSI_Sign code for tests.cpp", "output": "void test(const operation::ECCSI_Sign& op, const std::optional<component::ECCSI_Signature>& result) {\n    (void)op;\n    (void)result;\n}\n"}
{"text_input": "Generate ECDSA_Sign code for tests.cpp", "output": "void test(const operation::ECDSA_Sign& op, const std::optional<component::ECDSA_Signature>& result) {\n    if ( result != std::nullopt ) {\n        test_ECC_PrivateKey(op.curveType.Get(), op.priv.ToTrimmedString());\n\n        if (\n                op.UseSpecifiedNonce() == true &&\n                !IsSpecialCurve(op.curveType.Get()) &&\n                op.nonce.ToTrimmedString() == \"0\"\n           ) {\n            std::cout << \"0 is an invalid ECDSA nonce\" << std::endl;\n            ::abort();\n        }\n\n        test_ECDSA_Signature(op.curveType.Get(),\n                result->signature.first.ToTrimmedString(),\n                result->signature.second.ToTrimmedString());\n    }\n}\n\n\nstatic void test_ECC_PrivateKey(const uint64_t curveID, const std::string priv) {\n    /* Disabled until all modules comply by default */\n    return;\n\n    /* Private key may be 0 with these curves */\n    if ( IsSpecialCurve(curveID) ) {\n        return;\n    }\n\n    if ( priv == \"0\" ) {\n        std::cout << \"0 is an invalid elliptic curve private key\" << std::endl;\n        ::abort();\n    }\n}\n\n\n\nstatic void test_ECDSA_Signature(const uint64_t curveID, const std::string R, const std::string S) {\n    if ( IsSpecialCurve(curveID) ) {\n        return;\n    }\n\n    const boost::multiprecision::cpp_int r(R), s(S);\n\n    if ( r < 1 ) {\n        std::cout << \"ECDSA signature invalid: R < 1\" << std::endl;\n        ::abort();\n    }\n    if ( s < 1 ) {\n        std::cout << \"ECDSA signature invalid: S < 1\" << std::endl;\n        ::abort();\n    }\n\n    const auto O = cryptofuzz::repository::ECC_CurveToOrder(curveID);\n    if ( O == std::nullopt ) {\n        return;\n    }\n\n    const boost::multiprecision::cpp_int o(*O);\n\n    if ( r >= o ) {\n        std::cout << \"ECDSA signature invalid: R >= order\" << std::endl;\n        ::abort();\n    }\n\n    if ( s >= o ) {\n        std::cout << \"ECDSA signature invalid: S >= order\" << std::endl;\n        ::abort();\n    }\n}\n\n\n"}
{"text_input": "Generate ECGDSA_Sign code for tests.cpp", "output": "void test(const operation::ECGDSA_Sign& op, const std::optional<component::ECGDSA_Signature>& result) {\n    if ( result != std::nullopt ) {\n        test_ECC_PrivateKey(op.curveType.Get(), op.priv.ToTrimmedString());\n\n        if (\n                op.UseSpecifiedNonce() == true &&\n                !IsSpecialCurve(op.curveType.Get()) &&\n                op.nonce.ToTrimmedString() == \"0\"\n           ) {\n            std::cout << \"0 is an invalid ECGDSA nonce\" << std::endl;\n            ::abort();\n        }\n\n        test_ECDSA_Signature(op.curveType.Get(),\n                result->signature.first.ToTrimmedString(),\n                result->signature.second.ToTrimmedString());\n    }\n}\n\n\nstatic void test_ECC_PrivateKey(const uint64_t curveID, const std::string priv) {\n    /* Disabled until all modules comply by default */\n    return;\n\n    /* Private key may be 0 with these curves */\n    if ( IsSpecialCurve(curveID) ) {\n        return;\n    }\n\n    if ( priv == \"0\" ) {\n        std::cout << \"0 is an invalid elliptic curve private key\" << std::endl;\n        ::abort();\n    }\n}\n\n\n\nstatic void test_ECDSA_Signature(const uint64_t curveID, const std::string R, const std::string S) {\n    if ( IsSpecialCurve(curveID) ) {\n        return;\n    }\n\n    const boost::multiprecision::cpp_int r(R), s(S);\n\n    if ( r < 1 ) {\n        std::cout << \"ECDSA signature invalid: R < 1\" << std::endl;\n        ::abort();\n    }\n    if ( s < 1 ) {\n        std::cout << \"ECDSA signature invalid: S < 1\" << std::endl;\n        ::abort();\n    }\n\n    const auto O = cryptofuzz::repository::ECC_CurveToOrder(curveID);\n    if ( O == std::nullopt ) {\n        return;\n    }\n\n    const boost::multiprecision::cpp_int o(*O);\n\n    if ( r >= o ) {\n        std::cout << \"ECDSA signature invalid: R >= order\" << std::endl;\n        ::abort();\n    }\n\n    if ( s >= o ) {\n        std::cout << \"ECDSA signature invalid: S >= order\" << std::endl;\n        ::abort();\n    }\n}\n\n\n"}
{"text_input": "Generate ECRDSA_Sign code for tests.cpp", "output": "void test(const operation::ECRDSA_Sign& op, const std::optional<component::ECRDSA_Signature>& result) {\n    if ( result != std::nullopt ) {\n        test_ECC_PrivateKey(op.curveType.Get(), op.priv.ToTrimmedString());\n\n        if (\n                op.UseSpecifiedNonce() == true &&\n                !IsSpecialCurve(op.curveType.Get()) &&\n                op.nonce.ToTrimmedString() == \"0\"\n           ) {\n            std::cout << \"0 is an invalid ECRDSA nonce\" << std::endl;\n            ::abort();\n        }\n\n        test_ECDSA_Signature(op.curveType.Get(),\n                result->signature.first.ToTrimmedString(),\n                result->signature.second.ToTrimmedString());\n    }\n}\n\n\nstatic void test_ECC_PrivateKey(const uint64_t curveID, const std::string priv) {\n    /* Disabled until all modules comply by default */\n    return;\n\n    /* Private key may be 0 with these curves */\n    if ( IsSpecialCurve(curveID) ) {\n        return;\n    }\n\n    if ( priv == \"0\" ) {\n        std::cout << \"0 is an invalid elliptic curve private key\" << std::endl;\n        ::abort();\n    }\n}\n\n\n\nstatic void test_ECDSA_Signature(const uint64_t curveID, const std::string R, const std::string S) {\n    if ( IsSpecialCurve(curveID) ) {\n        return;\n    }\n\n    const boost::multiprecision::cpp_int r(R), s(S);\n\n    if ( r < 1 ) {\n        std::cout << \"ECDSA signature invalid: R < 1\" << std::endl;\n        ::abort();\n    }\n    if ( s < 1 ) {\n        std::cout << \"ECDSA signature invalid: S < 1\" << std::endl;\n        ::abort();\n    }\n\n    const auto O = cryptofuzz::repository::ECC_CurveToOrder(curveID);\n    if ( O == std::nullopt ) {\n        return;\n    }\n\n    const boost::multiprecision::cpp_int o(*O);\n\n    if ( r >= o ) {\n        std::cout << \"ECDSA signature invalid: R >= order\" << std::endl;\n        ::abort();\n    }\n\n    if ( s >= o ) {\n        std::cout << \"ECDSA signature invalid: S >= order\" << std::endl;\n        ::abort();\n    }\n}\n\n\n"}
{"text_input": "Generate Schnorr_Sign code for tests.cpp", "output": "void test(const operation::Schnorr_Sign& op, const std::optional<component::Schnorr_Signature>& result) {\n    if ( result != std::nullopt ) {\n        test_ECC_PrivateKey(op.curveType.Get(), op.priv.ToTrimmedString());\n\n        if (\n                op.UseSpecifiedNonce() == true &&\n                !IsSpecialCurve(op.curveType.Get()) &&\n                op.nonce.ToTrimmedString() == \"0\"\n           ) {\n            std::cout << \"0 is an invalid Schnorr nonce\" << std::endl;\n            ::abort();\n        }\n\n        test_BIP340_Schnorr_Signature(op.curveType.Get(),\n                result->signature.first.ToTrimmedString(),\n                result->signature.second.ToTrimmedString());\n    }\n}\n\n\nstatic void test_ECC_PrivateKey(const uint64_t curveID, const std::string priv) {\n    /* Disabled until all modules comply by default */\n    return;\n\n    /* Private key may be 0 with these curves */\n    if ( IsSpecialCurve(curveID) ) {\n        return;\n    }\n\n    if ( priv == \"0\" ) {\n        std::cout << \"0 is an invalid elliptic curve private key\" << std::endl;\n        ::abort();\n    }\n}\n\n\n"}
{"text_input": "Generate ECCSI_Verify code for tests.cpp", "output": "void test(const operation::ECCSI_Verify& op, const std::optional<bool>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}
{"text_input": "Generate ECDSA_Verify code for tests.cpp", "output": "void test(const operation::ECDSA_Verify& op, const std::optional<bool>& result) {\n    if ( result != std::nullopt && *result == true ) {\n        test_ECDSA_Signature(op.curveType.Get(),\n                op.signature.signature.first.ToTrimmedString(),\n                op.signature.signature.second.ToTrimmedString());\n    }\n}\n\n\nstatic void test_ECDSA_Signature(const uint64_t curveID, const std::string R, const std::string S) {\n    if ( IsSpecialCurve(curveID) ) {\n        return;\n    }\n\n    const boost::multiprecision::cpp_int r(R), s(S);\n\n    if ( r < 1 ) {\n        std::cout << \"ECDSA signature invalid: R < 1\" << std::endl;\n        ::abort();\n    }\n    if ( s < 1 ) {\n        std::cout << \"ECDSA signature invalid: S < 1\" << std::endl;\n        ::abort();\n    }\n\n    const auto O = cryptofuzz::repository::ECC_CurveToOrder(curveID);\n    if ( O == std::nullopt ) {\n        return;\n    }\n\n    const boost::multiprecision::cpp_int o(*O);\n\n    if ( r >= o ) {\n        std::cout << \"ECDSA signature invalid: R >= order\" << std::endl;\n        ::abort();\n    }\n\n    if ( s >= o ) {\n        std::cout << \"ECDSA signature invalid: S >= order\" << std::endl;\n        ::abort();\n    }\n}\n\n\n"}
{"text_input": "Generate ECGDSA_Verify code for tests.cpp", "output": "void test(const operation::ECGDSA_Verify& op, const std::optional<bool>& result) {\n    if ( result != std::nullopt && *result == true ) {\n        test_ECDSA_Signature(op.curveType.Get(),\n                op.signature.signature.first.ToTrimmedString(),\n                op.signature.signature.second.ToTrimmedString());\n    }\n}\n\n\nstatic void test_ECDSA_Signature(const uint64_t curveID, const std::string R, const std::string S) {\n    if ( IsSpecialCurve(curveID) ) {\n        return;\n    }\n\n    const boost::multiprecision::cpp_int r(R), s(S);\n\n    if ( r < 1 ) {\n        std::cout << \"ECDSA signature invalid: R < 1\" << std::endl;\n        ::abort();\n    }\n    if ( s < 1 ) {\n        std::cout << \"ECDSA signature invalid: S < 1\" << std::endl;\n        ::abort();\n    }\n\n    const auto O = cryptofuzz::repository::ECC_CurveToOrder(curveID);\n    if ( O == std::nullopt ) {\n        return;\n    }\n\n    const boost::multiprecision::cpp_int o(*O);\n\n    if ( r >= o ) {\n        std::cout << \"ECDSA signature invalid: R >= order\" << std::endl;\n        ::abort();\n    }\n\n    if ( s >= o ) {\n        std::cout << \"ECDSA signature invalid: S >= order\" << std::endl;\n        ::abort();\n    }\n}\n\n\n"}
{"text_input": "Generate ECRDSA_Verify code for tests.cpp", "output": "void test(const operation::ECRDSA_Verify& op, const std::optional<bool>& result) {\n    if ( result != std::nullopt && *result == true ) {\n        test_ECDSA_Signature(op.curveType.Get(),\n                op.signature.signature.first.ToTrimmedString(),\n                op.signature.signature.second.ToTrimmedString());\n    }\n}\n\n\nstatic void test_ECDSA_Signature(const uint64_t curveID, const std::string R, const std::string S) {\n    if ( IsSpecialCurve(curveID) ) {\n        return;\n    }\n\n    const boost::multiprecision::cpp_int r(R), s(S);\n\n    if ( r < 1 ) {\n        std::cout << \"ECDSA signature invalid: R < 1\" << std::endl;\n        ::abort();\n    }\n    if ( s < 1 ) {\n        std::cout << \"ECDSA signature invalid: S < 1\" << std::endl;\n        ::abort();\n    }\n\n    const auto O = cryptofuzz::repository::ECC_CurveToOrder(curveID);\n    if ( O == std::nullopt ) {\n        return;\n    }\n\n    const boost::multiprecision::cpp_int o(*O);\n\n    if ( r >= o ) {\n        std::cout << \"ECDSA signature invalid: R >= order\" << std::endl;\n        ::abort();\n    }\n\n    if ( s >= o ) {\n        std::cout << \"ECDSA signature invalid: S >= order\" << std::endl;\n        ::abort();\n    }\n}\n\n\n"}
{"text_input": "Generate Schnorr_Verify code for tests.cpp", "output": "void test(const operation::Schnorr_Verify& op, const std::optional<bool>& result) {\n    if ( result != std::nullopt && *result == true ) {\n        test_BIP340_Schnorr_Signature(op.curveType.Get(),\n                op.signature.signature.first.ToTrimmedString(),\n                op.signature.signature.second.ToTrimmedString());\n    }\n}\n\n"}
{"text_input": "Generate ECDSA_Recover code for tests.cpp", "output": "void test(const operation::ECDSA_Recover& op, const std::optional<component::ECC_PublicKey>& result) {\n    if ( result != std::nullopt ) {\n        if ( op.id > 3 ) {\n            std::cout << \"Invalid recovery ID\" << std::endl;\n            ::abort();\n        }\n    }\n    if ( result != std::nullopt ) {\n        test_ECDSA_Signature(op.curveType.Get(),\n                op.signature.first.ToTrimmedString(),\n                op.signature.second.ToTrimmedString());\n    }\n}\n\n\nstatic void test_ECDSA_Signature(const uint64_t curveID, const std::string R, const std::string S) {\n    if ( IsSpecialCurve(curveID) ) {\n        return;\n    }\n\n    const boost::multiprecision::cpp_int r(R), s(S);\n\n    if ( r < 1 ) {\n        std::cout << \"ECDSA signature invalid: R < 1\" << std::endl;\n        ::abort();\n    }\n    if ( s < 1 ) {\n        std::cout << \"ECDSA signature invalid: S < 1\" << std::endl;\n        ::abort();\n    }\n\n    const auto O = cryptofuzz::repository::ECC_CurveToOrder(curveID);\n    if ( O == std::nullopt ) {\n        return;\n    }\n\n    const boost::multiprecision::cpp_int o(*O);\n\n    if ( r >= o ) {\n        std::cout << \"ECDSA signature invalid: R >= order\" << std::endl;\n        ::abort();\n    }\n\n    if ( s >= o ) {\n        std::cout << \"ECDSA signature invalid: S >= order\" << std::endl;\n        ::abort();\n    }\n}\n\n\n"}
{"text_input": "Generate DSA_Verify code for tests.cpp", "output": "void test(const operation::DSA_Verify& op, const std::optional<bool>& result) {\n    (void)op;\n\n    if ( result == std::nullopt || *result == false ) {\n        return;\n    }\n\n    if ( !op.signature.first.IsPositive() ) {\n        std::cout << \"DSA signature must be rejected if R is smaller than 1\" << std::endl;\n        ::abort();\n    }\n    if ( !op.signature.second.IsPositive() ) {\n        std::cout << \"DSA signature must be rejected is S is smaller than 1\" << std::endl;\n        ::abort();\n    }\n\n    /* Q > R */\n    if ( op.signature.first.ToTrimmedString().size() > op.parameters.q.ToTrimmedString().size() ) {\n        std::cout << \"DSA signature must be rejected if R is larger than Q\" << std::endl;\n        ::abort();\n    }\n    /* Q > S */\n    if ( op.signature.second.ToTrimmedString().size() > op.parameters.q.ToTrimmedString().size() ) {\n        std::cout << \"DSA signature must be rejected if S is larger than Q\" << std::endl;\n        ::abort();\n    }\n}\n\n"}
{"text_input": "Generate DSA_Sign code for tests.cpp", "output": "void test(const operation::DSA_Sign& op, const std::optional<component::DSA_Signature>& result) {\n    if ( result == std::nullopt ) {\n        return;\n    }\n\n    if ( !result->signature.first.IsPositive() ) {\n        std::cout << \"DSA signature R must be larger than 0\" << std::endl;\n        ::abort();\n    }\n    if ( !result->signature.second.IsPositive() ) {\n        std::cout << \"DSA signature S must be larger than 0\" << std::endl;\n        ::abort();\n    }\n\n    /* Q > R */\n    if ( result->signature.first.ToTrimmedString().size() > op.parameters.q.ToTrimmedString().size() ) {\n        std::cout << \"DSA signature R must be smaller than P\" << std::endl;\n        ::abort();\n    }\n    /* Q > S */\n    if ( result->signature.second.ToTrimmedString().size() > op.parameters.q.ToTrimmedString().size() ) {\n        std::cout << \"DSA signature S must be smaller than Q\" << std::endl;\n        ::abort();\n    }\n\n    /* R > 0 */\n    if ( !result->signature.first.IsPositive() ) {\n        std::cout << \"DSA signature R must be larger than 0\" << std::endl;\n        ::abort();\n    }\n    /* S > 0 */\n    if ( !result->signature.second.IsPositive() ) {\n        std::cout << \"DSA signature R must be larger than 0\" << std::endl;\n        ::abort();\n    }\n}\n\n"}
{"text_input": "Generate DSA_GenerateParameters code for tests.cpp", "output": "void test(const operation::DSA_GenerateParameters& op, const std::optional<component::DSA_Parameters>& result) {\n    (void)op;\n\n    if ( result == std::nullopt ) {\n        return;\n    }\n\n    /* Larger than 0 */\n    if ( !result->p.IsPositive() ) {\n        std::cout << \"DSA P parameter must be larger than 0\" << std::endl;\n        ::abort();\n    }\n    if ( !result->q.IsPositive() ) {\n        std::cout << \"DSA Q parameter must be larger than 0\" << std::endl;\n        ::abort();\n    }\n    if ( !result->g.IsPositive() ) {\n        std::cout << \"DSA G parameter must be larger than 0\" << std::endl;\n        ::abort();\n    }\n\n    /* P > Q */\n    if ( result->q.ToTrimmedString().size() > result->p.ToTrimmedString().size() ) {\n        std::cout << \"DSA Q must be smaller than P\" << std::endl;\n        ::abort();\n    }\n\n    /* P > G */\n    if ( result->q.ToTrimmedString().size() > result->p.ToTrimmedString().size() ) {\n        std::cout << \"DSA G must be smaller than P\" << std::endl;\n        ::abort();\n    }\n\n    /* G != 1 */\n    if ( result->p.ToTrimmedString() == \"1\" ) {\n        std::cout << \"DSA G must not be 1\" << std::endl;\n        ::abort();\n    }\n\n    /* P, Q must be prime */\n    if ( isComposite(result->p.ToTrimmedString()) ) {\n        std::cout << \"DSA P must be prime\" << std::endl;\n        ::abort();\n    }\n\n    if ( isComposite(result->q.ToTrimmedString()) ) {\n        std::cout << \"DSA Q must be prime\" << std::endl;\n        ::abort();\n    }\n}\n\n"}
{"text_input": "Generate DSA_PrivateToPublic code for tests.cpp", "output": "void test(const operation::DSA_PrivateToPublic& op, const std::optional<component::Bignum>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}
{"text_input": "Generate DSA_GenerateKeyPair code for tests.cpp", "output": "void test(const operation::DSA_GenerateKeyPair& op, const std::optional<component::DSA_KeyPair>& result) {\n    if ( result == std::nullopt ) {\n        return;\n    }\n\n    if ( !result->first.IsPositive() ) {\n        std::cout << \"Private key must be larger than 0\" << std::endl;\n        ::abort();\n    }\n\n    /* Q > priv */\n    if ( result->first.ToTrimmedString().size() > op.q.ToTrimmedString().size() ) {\n        std::cout << \"Q must be larger than private key\" << std::endl;\n        ::abort();\n    }\n}\n\n"}
{"text_input": "Generate ECDH_Derive code for tests.cpp", "output": "void test(const operation::ECDH_Derive& op, const std::optional<component::Secret>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}
{"text_input": "Generate ECIES_Encrypt code for tests.cpp", "output": "void test(const operation::ECIES_Encrypt& op, const std::optional<component::Ciphertext>& result) {\n    /* TODO check minimum size? */\n    (void)op;\n    (void)result;\n}\n\n"}
{"text_input": "Generate ECIES_Decrypt code for tests.cpp", "output": "void test(const operation::ECIES_Decrypt& op, const std::optional<component::Cleartext>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}
{"text_input": "Generate ECC_Point_Add code for tests.cpp", "output": "void test(const operation::ECC_Point_Add& op, const std::optional<component::ECC_Point>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}
{"text_input": "Generate ECC_Point_Sub code for tests.cpp", "output": "void test(const operation::ECC_Point_Sub& op, const std::optional<component::ECC_Point>& result) {\n    if ( result == std::nullopt ) {\n        return;\n    }\n\n    if ( !(op.a.first == op.b.first) ) {\n        return;\n    }\n\n    if ( !(op.a.second == op.b.second) ) {\n        return;\n    }\n\n    if ( !result->first.IsZero() || !result->second.IsZero() ) {\n        std::cout << \"Subtracting equal points should result in point at infinity\" << std::endl;\n        ::abort();\n    }\n}\n\n"}
{"text_input": "Generate ECC_Point_Mul code for tests.cpp", "output": "void test(const operation::ECC_Point_Mul& op, const std::optional<component::ECC_Point>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}
{"text_input": "Generate ECC_Point_Neg code for tests.cpp", "output": "void test(const operation::ECC_Point_Neg& op, const std::optional<component::ECC_Point>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}
{"text_input": "Generate ECC_Point_Dbl code for tests.cpp", "output": "void test(const operation::ECC_Point_Dbl& op, const std::optional<component::ECC_Point>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}
{"text_input": "Generate ECC_Point_Cmp code for tests.cpp", "output": "void test(const operation::ECC_Point_Cmp& op, const std::optional<bool>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}
{"text_input": "Generate DH_GenerateKeyPair code for tests.cpp", "output": "void test(const operation::DH_GenerateKeyPair& op, const std::optional<component::DH_KeyPair>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}
{"text_input": "Generate DH_Derive code for tests.cpp", "output": "void test(const operation::DH_Derive& op, const std::optional<component::Bignum>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}
{"text_input": "Generate BLS_PrivateToPublic code for tests.cpp", "output": "void test(const operation::BLS_PrivateToPublic& op, const std::optional<component::BLS_PublicKey>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}
{"text_input": "Generate BLS_PrivateToPublic_G2 code for tests.cpp", "output": "void test(const operation::BLS_PrivateToPublic_G2& op, const std::optional<component::G2>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}
{"text_input": "Generate BLS_Sign code for tests.cpp", "output": "void test(const operation::BLS_Sign& op, const std::optional<component::BLS_Signature>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}
{"text_input": "Generate BLS_Verify code for tests.cpp", "output": "void test(const operation::BLS_Verify& op, const std::optional<bool>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}
{"text_input": "Generate BLS_BatchSign code for tests.cpp", "output": "void test(const operation::BLS_BatchSign& op, const std::optional<component::BLS_BatchSignature>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}
{"text_input": "Generate BLS_BatchVerify code for tests.cpp", "output": "void test(const operation::BLS_BatchVerify& op, const std::optional<bool>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}
{"text_input": "Generate BLS_Aggregate_G1 code for tests.cpp", "output": "void test(const operation::BLS_Aggregate_G1& op, const std::optional<component::G1>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}
{"text_input": "Generate BLS_Aggregate_G2 code for tests.cpp", "output": "void test(const operation::BLS_Aggregate_G2& op, const std::optional<component::G2>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}
{"text_input": "Generate BLS_Pairing code for tests.cpp", "output": "void test(const operation::BLS_Pairing& op, const std::optional<component::Fp12>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}
{"text_input": "Generate BLS_MillerLoop code for tests.cpp", "output": "void test(const operation::BLS_MillerLoop& op, const std::optional<component::Fp12>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}
{"text_input": "Generate BLS_FinalExp code for tests.cpp", "output": "void test(const operation::BLS_FinalExp& op, const std::optional<component::Fp12>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}
{"text_input": "Generate BLS_HashToG1 code for tests.cpp", "output": "void test(const operation::BLS_HashToG1& op, const std::optional<component::G1>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}
{"text_input": "Generate BLS_HashToG2 code for tests.cpp", "output": "void test(const operation::BLS_HashToG2& op, const std::optional<component::G2>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}
{"text_input": "Generate BLS_MapToG1 code for tests.cpp", "output": "void test(const operation::BLS_MapToG1& op, const std::optional<component::G1>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}
{"text_input": "Generate BLS_MapToG2 code for tests.cpp", "output": "void test(const operation::BLS_MapToG2& op, const std::optional<component::G2>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}
{"text_input": "Generate BLS_IsG1OnCurve code for tests.cpp", "output": "void test(const operation::BLS_IsG1OnCurve& op, const std::optional<bool>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}
{"text_input": "Generate BLS_IsG2OnCurve code for tests.cpp", "output": "void test(const operation::BLS_IsG2OnCurve& op, const std::optional<bool>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}
{"text_input": "Generate BLS_GenerateKeyPair code for tests.cpp", "output": "void test(const operation::BLS_GenerateKeyPair& op, const std::optional<component::BLS_KeyPair>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}
{"text_input": "Generate BLS_Decompress_G1 code for tests.cpp", "output": "void test(const operation::BLS_Decompress_G1& op, const std::optional<component::G1>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}
{"text_input": "Generate BLS_Compress_G1 code for tests.cpp", "output": "void test(const operation::BLS_Compress_G1& op, const std::optional<component::Bignum>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}
{"text_input": "Generate BLS_Decompress_G2 code for tests.cpp", "output": "void test(const operation::BLS_Decompress_G2& op, const std::optional<component::G2>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}
{"text_input": "Generate BLS_Compress_G2 code for tests.cpp", "output": "void test(const operation::BLS_Compress_G2& op, const std::optional<component::G1>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}
{"text_input": "Generate BLS_G1_Add code for tests.cpp", "output": "void test(const operation::BLS_G1_Add& op, const std::optional<component::G1>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}
{"text_input": "Generate BLS_G1_Mul code for tests.cpp", "output": "void test(const operation::BLS_G1_Mul& op, const std::optional<component::G1>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}
{"text_input": "Generate BLS_G1_IsEq code for tests.cpp", "output": "void test(const operation::BLS_G1_IsEq& op, const std::optional<bool>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}
{"text_input": "Generate BLS_G1_Neg code for tests.cpp", "output": "void test(const operation::BLS_G1_Neg& op, const std::optional<component::G1>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}
{"text_input": "Generate BLS_G2_Add code for tests.cpp", "output": "void test(const operation::BLS_G2_Add& op, const std::optional<component::G2>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}
{"text_input": "Generate BLS_G2_Mul code for tests.cpp", "output": "void test(const operation::BLS_G2_Mul& op, const std::optional<component::G2>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}
{"text_input": "Generate BLS_G2_IsEq code for tests.cpp", "output": "void test(const operation::BLS_G2_IsEq& op, const std::optional<bool>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}
{"text_input": "Generate BLS_G2_Neg code for tests.cpp", "output": "void test(const operation::BLS_G2_Neg& op, const std::optional<component::G2>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}
{"text_input": "Generate BLS_G1_MultiExp code for tests.cpp", "output": "void test(const operation::BLS_G1_MultiExp& op, const std::optional<component::G1>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}
{"text_input": "Generate Misc code for tests.cpp", "output": "void test(const operation::Misc& op, const std::optional<Buffer>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}
{"text_input": "Generate SR25519_Verify code for tests.cpp", "output": "void test(const operation::SR25519_Verify& op, const std::optional<bool>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}
{"text_input": "Generate BignumCalc code for tests.cpp", "output": "void test(const operation::BignumCalc& op, const std::optional<component::Bignum>& result) {\n    if ( result == std::nullopt ) {\n        return;\n    }\n\n    using namespace BignumCalc;\n\n    const auto calcOp = op.calcOp.Get();\n\n    if (\n            calcOp != CF_CALCOP(\"IsPrime(A)\") &&\n            calcOp != CF_CALCOP(\"Prime()\") ) {\n        /* Negative numbers are not supported yet */\n        if (    op.bn0.IsNegative() ||\n                op.bn1.IsNegative() ||\n                op.bn2.IsNegative() ) {\n            return;\n        }\n    }\n\n    /* Modular calculations are not supported yet */\n    if ( op.modulo != std::nullopt ) {\n        return;\n    }\n\n    switch ( calcOp ) {\n        case    CF_CALCOP(\"Add(A,B)\"):\n            if (    SmallerThan(*result, op.bn0) ||\n                    SmallerThan(*result, op.bn1) ) {\n                Abort(\"Result is smaller than its operands\", repository::CalcOpToString(calcOp));\n            }\n            break;\n        case    CF_CALCOP(\"Div(A,B)\"):\n            if ( IsZero(op.bn1) ) {\n                Abort(\"Division by zero should not produce a result\", repository::CalcOpToString(calcOp));\n            }\n\n            if ( LargerThan(*result, op.bn0) ) {\n                Abort(\"Result is larger than the dividend\", repository::CalcOpToString(calcOp));\n            }\n            break;\n        case    CF_CALCOP(\"Mul(A,B)\"):\n            if ( IsZero(op.bn0) || IsZero(op.bn1) ) {\n                if ( !IsZero(*result) ) {\n                    Abort(\"Result of Mul with zero operand is not zero\", repository::CalcOpToString(calcOp));\n                }\n            }\n            break;\n        case    CF_CALCOP(\"Mod(A,B)\"):\n            BignumCalc::AssertModResult(*result, op.bn1, \"Mod\");\n            break;\n        case    CF_CALCOP(\"ExpMod(A,B,C)\"):\n            BignumCalc::AssertModResult(*result, op.bn2, \"ExpMod\");\n            break;\n        case    CF_CALCOP(\"AddMod(A,B,C)\"):\n            BignumCalc::AssertModResult(*result, op.bn2, \"AddMod\");\n            break;\n        case    CF_CALCOP(\"SubMod(A,B,C)\"):\n            BignumCalc::AssertModResult(*result, op.bn2, \"SubMod\");\n            break;\n        case    CF_CALCOP(\"MulMod(A,B,C)\"):\n            BignumCalc::AssertModResult(*result, op.bn2, \"MulMod\");\n            break;\n        case    CF_CALCOP(\"SqrMod(A,B)\"):\n            BignumCalc::AssertModResult(*result, op.bn1, \"SqrMod\");\n            break;\n        case    CF_CALCOP(\"SqrtMod(A,B)\"):\n            BignumCalc::AssertModResult(*result, op.bn1, \"SqrtMod\");\n            break;\n        case    CF_CALCOP(\"ModLShift(A,B,C)\"):\n            BignumCalc::AssertModResult(*result, op.bn2, \"ModLShift\");\n            break;\n        case    CF_CALCOP(\"Bit(A,B)\"):\n            BignumCalc::AssertBinary(*result, \"Bit\");\n            break;\n        case    CF_CALCOP(\"IsCoprime(A,B)\"):\n            BignumCalc::AssertBinary(*result, \"IsCoprime\");\n            break;\n        case    CF_CALCOP(\"IsEq(A,B)\"):\n            BignumCalc::AssertBinary(*result, \"IsEq\");\n            break;\n        case    CF_CALCOP(\"IsGt(A,B)\"):\n            BignumCalc::AssertBinary(*result, \"IsGt\");\n            break;\n        case    CF_CALCOP(\"IsGte(A,B)\"):\n            BignumCalc::AssertBinary(*result, \"IsGte\");\n            break;\n        case    CF_CALCOP(\"IsLt(A,B)\"):\n            BignumCalc::AssertBinary(*result, \"IsLt\");\n            break;\n        case    CF_CALCOP(\"IsLte(A,B)\"):\n            BignumCalc::AssertBinary(*result, \"IsLte\");\n            break;\n        case    CF_CALCOP(\"IsEven(A)\"):\n            BignumCalc::AssertBinary(*result, \"IsEven\");\n            break;\n        case    CF_CALCOP(\"IsOdd(A)\"):\n            BignumCalc::AssertBinary(*result, \"IsOdd\");\n            break;\n        case    CF_CALCOP(\"IsOne(A)\"):\n            BignumCalc::AssertBinary(*result, \"IsOne\");\n            break;\n        case    CF_CALCOP(\"IsPow2(A)\"):\n            BignumCalc::AssertBinary(*result, \"IsPow2\");\n            break;\n        case    CF_CALCOP(\"IsPrime(A)\"):\n            BignumCalc::AssertBinary(*result, \"IsPrime\");\n            if ( !op.bn0.IsPositive() ) {\n                BignumCalc::AssertZero(*result, \"IsPrime\");\n            }\n            if ( result->IsOne() ) {\n                if ( op.bn0.ToTrimmedString() != \"2\" ) {\n                    BignumCalc::AssertOdd(op.bn0, \"IsPrime\");\n                }\n            }\n            break;\n        case    CF_CALCOP(\"IsZero(A)\"):\n            BignumCalc::AssertBinary(*result, \"IsZero\");\n            break;\n        case    CF_CALCOP(\"IsSquare(A)\"):\n            BignumCalc::AssertBinary(*result, \"IsSquare\");\n            break;\n        case    CF_CALCOP(\"IsPower(A)\"):\n            BignumCalc::AssertBinary(*result, \"IsPower\");\n            break;\n        case    CF_CALCOP(\"IsNeg(A)\"):\n            BignumCalc::AssertBinary(*result, \"IsNeg\");\n            break;\n        case    CF_CALCOP(\"IsNotZero(A)\"):\n            BignumCalc::AssertBinary(*result, \"IsNotZero\");\n            break;\n        case    CF_CALCOP(\"Cmp(A,B)\"):\n            BignumCalc::AssertTertiary(*result, \"Cmp\");\n            break;\n        case    CF_CALCOP(\"CmpAbs(A,B)\"):\n            BignumCalc::AssertTertiary(*result, \"CmpAbs\");\n            break;\n        case    CF_CALCOP(\"Jacobi(A,B)\"):\n            BignumCalc::AssertTertiary(*result, \"Jacobi\");\n            break;\n        case    CF_CALCOP(\"Sqr(A)\"):\n            AssertNotSmallerThan(*result, op.bn0, repository::CalcOpToString(calcOp));\n            break;\n        case    CF_CALCOP(\"RShift(A,B)\"):\n            if ( IsZero(op.bn0) || IsZero(op.bn1) ) {\n                if ( op.bn0.ToTrimmedString() != result->ToTrimmedString() ) {\n                    Abort(\"Zero operand should not alter input\", repository::CalcOpToString(calcOp));\n                }\n            }\n\n            AssertNotLargerThan(*result, op.bn0, repository::CalcOpToString(calcOp));\n            break;\n        case    CF_CALCOP(\"LShift1(A)\"):\n            if ( IsZero(op.bn0) ) {\n                if ( op.bn0.ToTrimmedString() != result->ToTrimmedString() ) {\n                    Abort(\"Zero input should remain zero\", repository::CalcOpToString(calcOp));\n                }\n            }\n\n            AssertNotSmallerThan(*result, op.bn0, repository::CalcOpToString(calcOp));\n            break;\n        case    CF_CALCOP(\"SetBit(A,B)\"):\n            AssertNotSmallerThan(*result, op.bn0, repository::CalcOpToString(calcOp));\n            break;\n        case    CF_CALCOP(\"ClearBit(A,B)\"):\n            AssertNotLargerThan(*result, op.bn0, repository::CalcOpToString(calcOp));\n            break;\n        case    CF_CALCOP(\"Sqrt(A)\"):\n            AssertNotLargerThan(*result, op.bn0, repository::CalcOpToString(calcOp));\n            break;\n        case    CF_CALCOP(\"Cbrt(A)\"):\n            AssertNotLargerThan(*result, op.bn0, repository::CalcOpToString(calcOp));\n            break;\n        case    CF_CALCOP(\"MulAdd(A,B,C)\"):\n            AssertNotSmallerThan(*result, op.bn2, repository::CalcOpToString(calcOp));\n            break;\n        case    CF_CALCOP(\"Min(A,B)\"):\n        case    CF_CALCOP(\"Max(A,B)\"):\n            if ( !IsEqual(*result, op.bn0) && !IsEqual(*result, op.bn1) ) {\n                Abort(\"Result is not an operand\", repository::CalcOpToString(calcOp));\n            }\n            break;\n        case    CF_CALCOP(\"Mask(A,B)\"):\n            if ( LargerThan(*result, op.bn0) ) {\n                Abort(\"Result is larger than input\", repository::CalcOpToString(calcOp));\n            }\n            break;\n        case    CF_CALCOP(\"And(A,B)\"):\n            AssertNotLargerThan(*result, op.bn0, repository::CalcOpToString(calcOp));\n            AssertNotLargerThan(*result, op.bn1, repository::CalcOpToString(calcOp));\n            break;\n        case    CF_CALCOP(\"Or(A,B)\"):\n            AssertNotSmallerThan(*result, op.bn0, repository::CalcOpToString(calcOp));\n            AssertNotSmallerThan(*result, op.bn1, repository::CalcOpToString(calcOp));\n            break;\n        case    CF_CALCOP(\"Nthrt(A,B)\"):\n        case    CF_CALCOP(\"NthrtRem(A,B)\"):\n            if ( IsZero(op.bn1) ) {\n                Abort(\"Root of zero should not produce a result\", repository::CalcOpToString(calcOp));\n            }\n            break;\n        case    CF_CALCOP(\"Zero()\"):\n            if ( !IsZero(*result) ) {\n                Abort(\"Result should be zero\", repository::CalcOpToString(calcOp));\n            }\n            break;\n        case    CF_CALCOP(\"GCD(A,B)\"):\n            AssertNotLargerThan(*result, op.bn0, op.bn1, repository::CalcOpToString(calcOp));\n            break;\n        case    CF_CALCOP(\"LCM(A,B)\"):\n            AssertNotSmallerThan(*result, op.bn0, op.bn1, repository::CalcOpToString(calcOp));\n            break;\n        case    CF_CALCOP(\"InvMod(A,B)\"):\n            if ( !IsZero(*result) ) {\n                AssertNotLargerThan(*result, op.bn1, repository::CalcOpToString(calcOp));\n            }\n            break;\n        case    CF_CALCOP(\"Exp(A,B)\"):\n            AssertNotSmallerThan(*result, op.bn0, op.bn1, repository::CalcOpToString(calcOp));\n            break;\n        case    CF_CALCOP(\"RandMod(A)\"):\n            BignumCalc::AssertModResult(*result, op.bn0, \"RandMod\");\n            break;\n        case    CF_CALCOP(\"Prime()\"):\n            BignumCalc::AssertPositive(*result, repository::CalcOpToString(calcOp));\n            if ( result->ToTrimmedString() != \"2\" ) {\n                BignumCalc::AssertOdd(*result, repository::CalcOpToString(calcOp));\n            }\n            break;\n        case    CF_CALCOP(\"RandRange(A,B)\"):\n            AssertNotLargerThan(*result, op.bn1, repository::CalcOpToString(calcOp));\n            break;\n    }\n}\n\n"}
{"text_input": "Generate BignumCalc_Fp2 code for tests.cpp", "output": "void test(const operation::BignumCalc_Fp2& op, const std::optional<component::Fp2>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}
{"text_input": "Generate BignumCalc_Fp12 code for tests.cpp", "output": "void test(const operation::BignumCalc_Fp12& op, const std::optional<component::Fp12>& result) {\n    (void)op;\n    (void)result;\n}\n"}
{"text_input": "Generate Digest code for operations.h", "output": "class Digest : public Operation {\n    public:\n        const component::Cleartext cleartext;\n        const component::DigestType digestType;\n\n        Digest(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            cleartext(ds),\n            digestType(ds)\n        { }\n\n        Digest(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            cleartext(json[\"cleartext\"]),\n            digestType(json[\"digestType\"])\n        { }\n\n\n        static size_t MaxOperations(void) { return 20; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        std::string GetAlgorithmString(void) const override {\n            return repository::DigestToString(digestType.Get());\n        }\n        inline bool operator==(const Digest& rhs) const {\n            return\n                (cleartext == rhs.cleartext) &&\n                (digestType == rhs.digestType) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            cleartext.Serialize(ds);\n            digestType.Serialize(ds);\n        }\n};\n\n"}
{"text_input": "Generate HMAC code for operations.h", "output": "class HMAC : public Operation {\n    public:\n        const component::Cleartext cleartext;\n        const component::DigestType digestType;\n        const component::SymmetricCipher cipher;\n\n        HMAC(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            cleartext(ds),\n            digestType(ds),\n            cipher(ds)\n        { }\n        HMAC(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            cleartext(json[\"cleartext\"]),\n            digestType(json[\"digestType\"]),\n            cipher(json[\"cipher\"])\n        { }\n\n        static size_t MaxOperations(void) { return 20; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        std::string GetAlgorithmString(void) const override {\n            return repository::DigestToString(digestType.Get());\n        }\n        inline bool operator==(const HMAC& rhs) const {\n            return\n                (cleartext == rhs.cleartext) &&\n                (digestType == rhs.digestType) &&\n                (cipher == rhs.cipher) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            cleartext.Serialize(ds);\n            digestType.Serialize(ds);\n            cipher.Serialize(ds);\n        }\n};\n\n"}
{"text_input": "Generate UMAC code for operations.h", "output": "class UMAC : public Operation {\n    public:\n        const component::Cleartext cleartext;\n        const component::Cleartext key;\n        const component::Cleartext iv;\n        uint8_t type;\n        const uint64_t outSize;\n\n        UMAC(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            cleartext(ds),\n            key(ds),\n            iv(ds),\n            type(ds.Get<uint64_t>() % 4),\n            outSize(ds.Get<uint64_t>() % 1024)\n        { }\n        UMAC(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            cleartext(json[\"cleartext\"]),\n            key(json[\"key\"]),\n            iv(json[\"iv\"]),\n            type(json[\"type\"].get<uint64_t>()),\n            outSize(json[\"outSize\"].get<uint64_t>())\n        { }\n\n        static size_t MaxOperations(void) { return 20; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const UMAC& rhs) const {\n            return\n                (cleartext == rhs.cleartext) &&\n                (key == rhs.key) &&\n                (iv == rhs.iv) &&\n                (type == rhs.type) &&\n                (outSize == rhs.outSize) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            cleartext.Serialize(ds);\n            key.Serialize(ds);\n            iv.Serialize(ds);\n            ds.Put<>(type);\n            ds.Put<>(outSize);\n        }\n};\n\n"}
{"text_input": "Generate SymmetricEncrypt code for operations.h", "output": "class SymmetricEncrypt : public Operation {\n    public:\n        const component::Cleartext cleartext;\n        const component::SymmetricCipher cipher;\n        const std::optional<component::AAD> aad;\n\n        const uint64_t ciphertextSize;\n        const std::optional<uint64_t> tagSize;\n\n        SymmetricEncrypt(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            cleartext(ds),\n            cipher(ds),\n            aad(ds.Get<bool>() ? std::nullopt : std::make_optional<component::AAD>(ds)),\n            ciphertextSize(ds.Get<uint64_t>() % (10*1024*1024)),\n            tagSize( ds.Get<bool>() ?\n                    std::nullopt :\n                    std::make_optional<uint64_t>(ds.Get<uint64_t>() % (10*1024*1024)) )\n        { }\n        SymmetricEncrypt(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            cleartext(json[\"cleartext\"]),\n            cipher(json[\"cipher\"]),\n            aad(\n                    json[\"aad_enabled\"].get<bool>() ?\n                        std::optional<component::AAD>(json[\"aad\"]) :\n                        std::optional<component::AAD>(std::nullopt)\n            ),\n            ciphertextSize(json[\"ciphertextSize\"].get<uint64_t>()),\n            tagSize(\n                    json[\"tagSize_enabled\"].get<bool>() ?\n                        std::optional<uint64_t>(json[\"tagSize\"].get<uint64_t>()) :\n                        std::optional<uint64_t>(std::nullopt)\n            )\n        { }\n\n        static size_t MaxOperations(void) { return 20; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        std::string GetAlgorithmString(void) const override {\n            return repository::CipherToString(cipher.cipherType.Get());\n        }\n        inline bool operator==(const SymmetricEncrypt& rhs) const {\n            return\n                (cleartext == rhs.cleartext) &&\n                (cipher == rhs.cipher) &&\n                (aad == rhs.aad) &&\n                (ciphertextSize == rhs.ciphertextSize) &&\n                (tagSize == rhs.tagSize) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            cleartext.Serialize(ds);\n            cipher.Serialize(ds);\n            if ( aad == std::nullopt ) {\n                ds.Put<bool>(true);\n            } else {\n                ds.Put<bool>(false);\n                aad->Serialize(ds);\n            }\n            ds.Put<>(ciphertextSize);\n            if ( tagSize == std::nullopt ) {\n                ds.Put<bool>(true);\n            } else {\n                ds.Put<bool>(false);\n                ds.Put<>(*tagSize);\n            }\n        }\n};\n\n"}
{"text_input": "Generate SymmetricDecrypt code for operations.h", "output": "class SymmetricDecrypt : public Operation {\n    public:\n        const Buffer ciphertext;\n        const component::SymmetricCipher cipher;\n        const std::optional<component::Tag> tag;\n        const std::optional<component::AAD> aad;\n\n        const uint64_t cleartextSize;\n\n        SymmetricDecrypt(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            ciphertext(ds),\n            cipher(ds),\n            tag(ds.Get<bool>() ? std::nullopt : std::make_optional<component::Tag>(ds)),\n            aad(ds.Get<bool>() ? std::nullopt : std::make_optional<component::AAD>(ds)),\n            cleartextSize(ds.Get<uint64_t>() % (10*1024*1024))\n        { }\n        SymmetricDecrypt(const SymmetricEncrypt& opSymmetricEncrypt, const component::Ciphertext ciphertext, const uint64_t cleartextSize, std::optional<component::AAD> aad, component::Modifier modifier);\n        SymmetricDecrypt(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            ciphertext(json[\"ciphertext\"]),\n            cipher(json[\"cipher\"]),\n            tag(\n                    json[\"tag_enabled\"].get<bool>() ?\n                        std::optional<component::Tag>(json[\"tag\"]) :\n                        std::optional<component::Tag>(std::nullopt)\n            ),\n            aad(\n                    json[\"aad_enabled\"].get<bool>() ?\n                        std::optional<component::AAD>(json[\"aad\"]) :\n                        std::optional<component::AAD>(std::nullopt)\n            ),\n            cleartextSize(json[\"cleartextSize\"].get<uint64_t>())\n        { }\n\n        static size_t MaxOperations(void) { return 20; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        std::string GetAlgorithmString(void) const override {\n            return repository::CipherToString(cipher.cipherType.Get());\n        }\n        inline bool operator==(const SymmetricDecrypt& rhs) const {\n            return\n                (ciphertext == rhs.ciphertext) &&\n                (cipher == rhs.cipher) &&\n                (tag == rhs.tag) &&\n                (aad == rhs.aad) &&\n                (cleartextSize == rhs.cleartextSize) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            ciphertext.Serialize(ds);\n            cipher.Serialize(ds);\n            if ( tag == std::nullopt ) {\n                ds.Put<bool>(true);\n            } else {\n                ds.Put<bool>(false);\n                tag->Serialize(ds);\n            }\n            if ( aad == std::nullopt ) {\n                ds.Put<bool>(true);\n            } else {\n                ds.Put<bool>(false);\n                aad->Serialize(ds);\n            }\n            ds.Put<>(cleartextSize);\n        }\n};\n\n"}
{"text_input": "Generate KDF_SCRYPT code for operations.h", "output": "class KDF_SCRYPT : public Operation {\n    public:\n        const component::Cleartext password;\n        const component::Cleartext salt;\n        const uint64_t N;\n        const uint64_t r;\n        const uint64_t p;\n\n        const uint64_t keySize;\n\n        KDF_SCRYPT(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            password(ds),\n            salt(ds),\n            N(ds.Get<uint64_t>() % 5),\n            r(ds.Get<uint64_t>() % 9),\n            p(ds.Get<uint64_t>() % 5),\n            keySize(ds.Get<uint64_t>() % 1024)\n        { }\n        KDF_SCRYPT(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            password(json[\"password\"]),\n            salt(json[\"salt\"]),\n            N(json[\"N\"].get<uint64_t>()),\n            r(json[\"r\"].get<uint64_t>()),\n            p(json[\"p\"].get<uint64_t>()),\n            keySize(json[\"keySize\"].get<uint64_t>())\n        { }\n\n        static size_t MaxOperations(void) { return 20; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const KDF_SCRYPT& rhs) const {\n            return\n                (password == rhs.password) &&\n                (salt == rhs.salt) &&\n                (N == rhs.N) &&\n                (r == rhs.r) &&\n                (p == rhs.p) &&\n                (keySize == rhs.keySize) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            password.Serialize(ds);\n            salt.Serialize(ds);\n            ds.Put<>(N);\n            ds.Put<>(r);\n            ds.Put<>(p);\n            ds.Put<>(keySize);\n        }\n};\n\n"}
{"text_input": "Generate KDF_HKDF code for operations.h", "output": "class KDF_HKDF : public Operation {\n    public:\n        const component::DigestType digestType;\n        const component::Cleartext password;\n        const component::Cleartext salt;\n        const component::Cleartext info;\n\n        const uint64_t keySize;\n\n        KDF_HKDF(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            digestType(ds),\n            password(ds),\n            salt(ds),\n            info(ds),\n            keySize(ds.Get<uint64_t>() % 17000)\n        { }\n        KDF_HKDF(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            digestType(json[\"digestType\"]),\n            password(json[\"password\"]),\n            salt(json[\"salt\"]),\n            info(json[\"info\"]),\n            keySize(json[\"keySize\"].get<uint64_t>())\n        { }\n\n        static size_t MaxOperations(void) { return 20; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const KDF_HKDF& rhs) const {\n            return\n                (digestType == rhs.digestType) &&\n                (password == rhs.password) &&\n                (salt == rhs.salt) &&\n                (info == rhs.info) &&\n                (keySize == rhs.keySize) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            digestType.Serialize(ds);\n            password.Serialize(ds);\n            salt.Serialize(ds);\n            info.Serialize(ds);\n            ds.Put<>(keySize);\n        }\n};\n\n"}
{"text_input": "Generate KDF_TLS1_PRF code for operations.h", "output": "class KDF_TLS1_PRF : public Operation {\n    public:\n        const component::DigestType digestType;\n        const component::Cleartext secret;\n        const component::Cleartext seed;\n\n        const uint64_t keySize;\n\n        KDF_TLS1_PRF(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            digestType(ds),\n            secret(ds),\n            seed(ds),\n            keySize(ds.Get<uint64_t>() % 1024)\n        { }\n        KDF_TLS1_PRF(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            digestType(json[\"digestType\"]),\n            secret(json[\"secret\"]),\n            seed(json[\"seed\"]),\n            keySize(json[\"keySize\"].get<uint64_t>())\n        { }\n\n        static size_t MaxOperations(void) { return 20; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const KDF_TLS1_PRF& rhs) const {\n            return\n                (digestType == rhs.digestType) &&\n                (secret == rhs.secret) &&\n                (seed == rhs.seed) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            digestType.Serialize(ds);\n            secret.Serialize(ds);\n            seed.Serialize(ds);\n            ds.Put<>(keySize);\n        }\n};\n\n"}
{"text_input": "Generate KDF_PBKDF code for operations.h", "output": "class KDF_PBKDF : public Operation {\n    public:\n        const component::DigestType digestType;\n        const component::Cleartext password;\n        const component::Cleartext salt;\n        const uint64_t iterations;\n\n        const uint64_t keySize;\n\n        KDF_PBKDF(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            digestType(ds),\n            password(ds),\n            salt(ds),\n            iterations(ds.Get<uint64_t>() % 5),\n            keySize(ds.Get<uint64_t>() % 1024)\n        { }\n        KDF_PBKDF(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            digestType(json[\"digestType\"]),\n            password(json[\"password\"]),\n            salt(json[\"salt\"]),\n            iterations(json[\"iterations\"].get<uint64_t>()),\n            keySize(json[\"keySize\"].get<uint64_t>())\n        { }\n\n        static size_t MaxOperations(void) { return 20; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const KDF_PBKDF& rhs) const {\n            return\n                (digestType == rhs.digestType) &&\n                (password == rhs.password) &&\n                (salt == rhs.salt) &&\n                (iterations == rhs.iterations) &&\n                (keySize == rhs.keySize) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            digestType.Serialize(ds);\n            password.Serialize(ds);\n            salt.Serialize(ds);\n            ds.Put<>(iterations);\n            ds.Put<>(keySize);\n        }\n};\n\n"}
{"text_input": "Generate KDF_PBKDF1 code for operations.h", "output": "class KDF_PBKDF1 : public Operation {\n    public:\n        const component::DigestType digestType;\n        const component::Cleartext password;\n        const component::Cleartext salt;\n        const uint64_t iterations;\n\n        const uint64_t keySize;\n\n        KDF_PBKDF1(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            digestType(ds),\n            password(ds),\n            salt(ds),\n            iterations(ds.Get<uint64_t>() % 5),\n            keySize(ds.Get<uint64_t>() % 1024)\n        { }\n        KDF_PBKDF1(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            digestType(json[\"digestType\"]),\n            password(json[\"password\"]),\n            salt(json[\"salt\"]),\n            iterations(json[\"iterations\"].get<uint64_t>()),\n            keySize(json[\"keySize\"].get<uint64_t>())\n        { }\n\n        static size_t MaxOperations(void) { return 20; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const KDF_PBKDF1& rhs) const {\n            return\n                (digestType == rhs.digestType) &&\n                (password == rhs.password) &&\n                (salt == rhs.salt) &&\n                (iterations == rhs.iterations) &&\n                (keySize == rhs.keySize) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            digestType.Serialize(ds);\n            password.Serialize(ds);\n            salt.Serialize(ds);\n            ds.Put<>(iterations);\n            ds.Put<>(keySize);\n        }\n};\n\n"}
{"text_input": "Generate KDF_PBKDF2 code for operations.h", "output": "class KDF_PBKDF2 : public Operation {\n    public:\n        const component::DigestType digestType;\n        const component::Cleartext password;\n        const component::Cleartext salt;\n        const uint64_t iterations;\n\n        const uint64_t keySize;\n\n        KDF_PBKDF2(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            digestType(ds),\n            password(ds),\n            salt(ds),\n            iterations(ds.Get<uint64_t>() % 5),\n            keySize(ds.Get<uint64_t>() % 1024)\n        { }\n        KDF_PBKDF2(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            digestType(json[\"digestType\"]),\n            password(json[\"password\"]),\n            salt(json[\"salt\"]),\n            iterations(json[\"iterations\"].get<uint64_t>()),\n            keySize(json[\"keySize\"].get<uint64_t>())\n        { }\n\n        static size_t MaxOperations(void) { return 20; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const KDF_PBKDF2& rhs) const {\n            return\n                (digestType == rhs.digestType) &&\n                (password == rhs.password) &&\n                (salt == rhs.salt) &&\n                (iterations == rhs.iterations) &&\n                (keySize == rhs.keySize) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            digestType.Serialize(ds);\n            password.Serialize(ds);\n            salt.Serialize(ds);\n            ds.Put<>(iterations);\n            ds.Put<>(keySize);\n        }\n};\n\n"}
{"text_input": "Generate KDF_ARGON2 code for operations.h", "output": "class KDF_ARGON2 : public Operation {\n    public:\n        const component::Cleartext password;\n        const component::Cleartext salt;\n        const uint8_t type;\n        const uint8_t threads;\n        const uint32_t memory;\n        const uint32_t iterations;\n        const uint32_t keySize;\n\n        KDF_ARGON2(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            password(ds),\n            salt(ds),\n            type(ds.Get<uint8_t>()),\n            threads(ds.Get<uint8_t>()),\n            memory(ds.Get<uint32_t>() % (64*1024)),\n            iterations(ds.Get<uint32_t>() % 3),\n            keySize(ds.Get<uint32_t>() % 1024)\n        { }\n        KDF_ARGON2(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            password(json[\"password\"]),\n            salt(json[\"salt\"]),\n            type(json[\"type\"].get<uint8_t>()),\n            threads(json[\"threads\"].get<uint8_t>()),\n            memory(json[\"memory\"].get<uint32_t>()),\n            iterations(json[\"iterations\"].get<uint32_t>()),\n            keySize(json[\"keySize\"].get<uint32_t>())\n        { }\n\n        static size_t MaxOperations(void) { return 3; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const KDF_ARGON2& rhs) const {\n            return\n                (password == rhs.password) &&\n                (salt == rhs.salt) &&\n                (type == rhs.type) &&\n                (threads == rhs.threads) &&\n                (memory == rhs.memory) &&\n                (iterations == rhs.iterations) &&\n                (keySize == rhs.keySize) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            password.Serialize(ds);\n            salt.Serialize(ds);\n            ds.Put<>(type);\n            ds.Put<>(threads);\n            ds.Put<>(memory);\n            ds.Put<>(iterations);\n            ds.Put<>(keySize);\n        }\n};\n\n"}
{"text_input": "Generate KDF_SSH code for operations.h", "output": "class KDF_SSH : public Operation {\n    public:\n        const component::DigestType digestType;\n        const component::Cleartext key;\n        const component::Cleartext xcghash;\n        const component::Cleartext session_id;\n        const component::Cleartext type;\n        const uint64_t keySize;\n\n        KDF_SSH(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            digestType(ds),\n            key(ds),\n            xcghash(ds),\n            session_id(ds),\n            type(ds),\n            keySize(ds.Get<uint64_t>() % 1024)\n        { }\n        KDF_SSH(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            digestType(json[\"digestType\"]),\n            key(json[\"key\"]),\n            xcghash(json[\"xcghash\"]),\n            session_id(json[\"session_id\"]),\n            type(json[\"type\"]),\n            keySize(json[\"keySize\"].get<uint64_t>())\n        { }\n\n        static size_t MaxOperations(void) { return 20; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const KDF_SSH& rhs) const {\n            return\n                (digestType == rhs.digestType) &&\n                (key == rhs.key) &&\n                (xcghash == rhs.xcghash) &&\n                (session_id == rhs.session_id) &&\n                (type == rhs.type) &&\n                (keySize == rhs.keySize) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            digestType.Serialize(ds);\n            key.Serialize(ds);\n            xcghash.Serialize(ds);\n            session_id.Serialize(ds);\n            type.Serialize(ds);\n            ds.Put<>(keySize);\n        }\n};\n\n"}
{"text_input": "Generate KDF_X963 code for operations.h", "output": "class KDF_X963 : public Operation {\n    public:\n        const component::DigestType digestType;\n        const component::Cleartext secret;\n        const component::Cleartext info;\n        const uint64_t keySize;\n\n        KDF_X963(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            digestType(ds),\n            secret(ds),\n            info(ds),\n            keySize(ds.Get<uint64_t>() % 1024)\n        { }\n        KDF_X963(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            digestType(json[\"digestType\"]),\n            secret(json[\"secret\"]),\n            info(json[\"info\"]),\n            keySize(json[\"keySize\"].get<uint64_t>())\n        { }\n\n        static size_t MaxOperations(void) { return 20; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const KDF_X963& rhs) const {\n            return\n                (digestType == rhs.digestType) &&\n                (secret == rhs.secret) &&\n                (info == rhs.info) &&\n                (keySize == rhs.keySize) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            digestType.Serialize(ds);\n            secret.Serialize(ds);\n            info.Serialize(ds);\n            ds.Put<>(keySize);\n        }\n};\n\n"}
{"text_input": "Generate KDF_BCRYPT code for operations.h", "output": "class KDF_BCRYPT : public Operation {\n    public:\n        const component::DigestType digestType;\n        const component::Cleartext secret;\n        const component::Cleartext salt;\n        const uint32_t iterations;\n        const uint64_t keySize;\n\n        KDF_BCRYPT(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            digestType(ds),\n            secret(ds),\n            salt(ds),\n            iterations(ds.Get<uint32_t>() % 3),\n            keySize(ds.Get<uint64_t>() % 1024)\n        { }\n        KDF_BCRYPT(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            digestType(json[\"digestType\"]),\n            secret(json[\"secret\"]),\n            salt(json[\"salt\"]),\n            iterations(json[\"iterations\"].get<uint32_t>()),\n            keySize(json[\"keySize\"].get<uint64_t>())\n        { }\n\n        static size_t MaxOperations(void) { return 2; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const KDF_BCRYPT& rhs) const {\n            return\n                (digestType == rhs.digestType) &&\n                (secret == rhs.secret) &&\n                (salt == rhs.salt) &&\n                (iterations == rhs.iterations) &&\n                (keySize == rhs.keySize) &&\n                (modifier == rhs.modifier);\n        }\n};\n\n"}
{"text_input": "Generate KDF_SP_800_108 code for operations.h", "output": "class KDF_SP_800_108 : public Operation {\n    public:\n        const component::MACType mech;\n        const component::Cleartext secret;\n        const component::Cleartext salt;\n        const component::Cleartext label;\n        const uint8_t mode;\n        const uint64_t keySize;\n\n        KDF_SP_800_108(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            mech(ds),\n            secret(ds),\n            salt(ds),\n            label(ds),\n            mode(ds.Get<uint8_t>()),\n            keySize(ds.Get<uint64_t>() % 17000)\n        { }\n        KDF_SP_800_108(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            mech(json[\"mech\"]),\n            secret(json[\"secret\"]),\n            salt(json[\"salt\"]),\n            label(json[\"label\"]),\n            mode(json[\"mode\"].get<uint8_t>()),\n            keySize(json[\"keySize\"].get<uint64_t>())\n        { }\n\n        static size_t MaxOperations(void) { return 20; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const KDF_SP_800_108& rhs) const {\n            return\n                (mech == rhs.mech) &&\n                (secret == rhs.secret) &&\n                (salt == rhs.salt) &&\n                (label == rhs.label) &&\n                (mode == rhs.mode) &&\n                (keySize == rhs.keySize) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            mech.Serialize(ds);\n            secret.Serialize(ds);\n            salt.Serialize(ds);\n            label.Serialize(ds);\n            ds.Put<>(mode);\n            ds.Put<>(keySize);\n        }\n};\n\n"}
{"text_input": "Generate KDF_SRTP code for operations.h", "output": "class KDF_SRTP : public Operation {\n    public:\n        const component::Cleartext key;\n        const component::Cleartext salt;\n        const uint8_t kdr;\n        const uint64_t index;\n        const uint64_t key1Size;\n        const uint64_t key2Size;\n        const uint64_t key3Size;\n\n        KDF_SRTP(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            key(ds),\n            salt(ds),\n            kdr(ds.Get<uint8_t>()),\n            index(ds.Get<uint64_t>()),\n            key1Size(ds.Get<uint64_t>() % (1024*1024)),\n            key2Size(ds.Get<uint64_t>() % (1024*1024)),\n            key3Size(ds.Get<uint64_t>() % (1024*1024))\n        { }\n        KDF_SRTP(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            key(json[\"key\"]),\n            salt(json[\"salt\"]),\n            kdr(json[\"kdr\"].get<uint8_t>()),\n            index(json[\"index\"].get<uint64_t>()),\n            key1Size(json[\"key1Size\"].get<uint64_t>()),\n            key2Size(json[\"key2Size\"].get<uint64_t>()),\n            key3Size(json[\"key3Size\"].get<uint64_t>())\n        { }\n\n        static size_t MaxOperations(void) { return 20; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const KDF_SRTP& rhs) const {\n            return\n                (key == rhs.key) &&\n                (salt == rhs.salt) &&\n                (kdr == rhs.kdr) &&\n                (index == rhs.index) &&\n                (key1Size == rhs.key1Size) &&\n                (key2Size == rhs.key2Size) &&\n                (key3Size == rhs.key3Size) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            key.Serialize(ds);\n            salt.Serialize(ds);\n            ds.Put<>(kdr);\n            ds.Put<>(key1Size);\n            ds.Put<>(key2Size);\n            ds.Put<>(key3Size);\n        }\n};\n\n"}
{"text_input": "Generate KDF_SRTCP code for operations.h", "output": "class KDF_SRTCP : public Operation {\n    public:\n        const component::Cleartext key;\n        const component::Cleartext salt;\n        const uint8_t kdr;\n        const uint32_t index;\n        const uint64_t key1Size;\n        const uint64_t key2Size;\n        const uint64_t key3Size;\n\n        KDF_SRTCP(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            key(ds),\n            salt(ds),\n            kdr(ds.Get<uint8_t>()),\n            index(ds.Get<uint32_t>()),\n            key1Size(ds.Get<uint64_t>() % (1024*1024)),\n            key2Size(ds.Get<uint64_t>() % (1024*1024)),\n            key3Size(ds.Get<uint64_t>() % (1024*1024))\n        { }\n        KDF_SRTCP(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            key(json[\"key\"]),\n            salt(json[\"salt\"]),\n            kdr(json[\"kdr\"].get<uint8_t>()),\n            index(json[\"index\"].get<uint32_t>()),\n            key1Size(json[\"key1Size\"].get<uint64_t>()),\n            key2Size(json[\"key2Size\"].get<uint64_t>()),\n            key3Size(json[\"key3Size\"].get<uint64_t>())\n        { }\n\n        static size_t MaxOperations(void) { return 20; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const KDF_SRTCP& rhs) const {\n            return\n                (key == rhs.key) &&\n                (salt == rhs.salt) &&\n                (kdr == rhs.kdr) &&\n                (index == rhs.index) &&\n                (key1Size == rhs.key1Size) &&\n                (key2Size == rhs.key2Size) &&\n                (key3Size == rhs.key3Size) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            key.Serialize(ds);\n            salt.Serialize(ds);\n            ds.Put<>(kdr);\n            ds.Put<>(key1Size);\n            ds.Put<>(key2Size);\n            ds.Put<>(key3Size);\n        }\n};\n\n"}
{"text_input": "Generate CMAC code for operations.h", "output": "class CMAC : public Operation {\n    public:\n        const component::Cleartext cleartext;\n        const component::SymmetricCipher cipher;\n\n        CMAC(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            cleartext(ds),\n            cipher(ds)\n        { }\n        CMAC(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            cleartext(json[\"cleartext\"]),\n            cipher(json[\"cipher\"])\n        { }\n\n        static size_t MaxOperations(void) { return 20; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const CMAC& rhs) const {\n            return\n                (cleartext == rhs.cleartext) &&\n                (cipher == rhs.cipher) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            cleartext.Serialize(ds);\n            cipher.Serialize(ds);\n        }\n};\n\n"}
{"text_input": "Generate ECC_PrivateToPublic code for operations.h", "output": "class ECC_PrivateToPublic : public Operation {\n    public:\n        const component::CurveType curveType;\n        const component::ECC_PrivateKey priv;\n\n        ECC_PrivateToPublic(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            priv(ds)\n        { }\n        ECC_PrivateToPublic(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            priv(json[\"priv\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const ECC_PrivateToPublic& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (priv == rhs.priv) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            priv.Serialize(ds);\n        }\n};\n\n"}
{"text_input": "Generate ECC_ValidatePubkey code for operations.h", "output": "class ECC_ValidatePubkey : public Operation {\n    public:\n        const component::CurveType curveType;\n        const component::ECC_PublicKey pub;\n\n        ECC_ValidatePubkey(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            pub(ds)\n        { }\n        ECC_ValidatePubkey(\n                const component::CurveType curveType,\n                const component::ECC_PublicKey& pub,\n                component::Modifier& modifier);\n        ECC_ValidatePubkey(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            pub(json[\"pub_x\"], json[\"pub_y\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const ECC_ValidatePubkey& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (pub == rhs.pub) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            pub.Serialize(ds);\n        }\n};\n\n"}
{"text_input": "Generate ECC_GenerateKeyPair code for operations.h", "output": "class ECC_GenerateKeyPair : public Operation {\n    public:\n        const component::CurveType curveType;\n\n        ECC_GenerateKeyPair(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds)\n        { }\n\n        ECC_GenerateKeyPair(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const ECC_GenerateKeyPair& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n        }\n};\n\n"}
{"text_input": "Generate ECCSI_Sign code for operations.h", "output": "class ECCSI_Sign : public Operation {\n    public:\n        const component::CurveType curveType;\n        const component::ECC_PrivateKey priv;\n        const component::Cleartext cleartext;\n        const component::Cleartext id;\n        const component::DigestType digestType;\n\n        ECCSI_Sign(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            priv(ds),\n            cleartext(ds),\n            id(ds),\n            digestType(ds)\n        { }\n        ECCSI_Sign(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            priv(json[\"priv\"]),\n            cleartext(json[\"cleartext\"]),\n            id(json[\"id\"]),\n            digestType(json[\"digestType\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const ECCSI_Sign& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (priv == rhs.priv) &&\n                (cleartext == rhs.cleartext) &&\n                (id == rhs.id) &&\n                (digestType == rhs.digestType ) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            priv.Serialize(ds);\n            cleartext.Serialize(ds);\n            id.Serialize(ds);\n            digestType.Serialize(ds);\n        }\n};\n\n"}
{"text_input": "Generate ECDSA_Sign code for operations.h", "output": "class ECDSA_Sign : public Operation {\n    public:\n        const component::CurveType curveType;\n        const component::ECC_PrivateKey priv;\n        const component::Bignum nonce;\n        const component::Cleartext cleartext;\n        const uint8_t nonceSource;\n        const component::DigestType digestType;\n\n        ECDSA_Sign(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            priv(ds),\n            nonce(ds),\n            cleartext(ds),\n            nonceSource(ds.Get<uint8_t>()),\n            digestType(ds)\n        { }\n        ECDSA_Sign(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            priv(json[\"priv\"]),\n            nonce(json[\"nonce\"]),\n            cleartext(json[\"cleartext\"]),\n            nonceSource(json[\"nonceSource\"].get<uint8_t>()),\n            digestType(json[\"digestType\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const ECDSA_Sign& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (priv == rhs.priv) &&\n                (nonce == rhs.nonce) &&\n                (cleartext == rhs.cleartext) &&\n                (nonceSource == rhs.nonceSource ) &&\n                (digestType == rhs.digestType ) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            priv.Serialize(ds);\n            nonce.Serialize(ds);\n            cleartext.Serialize(ds);\n            ds.Put<>(nonceSource);\n            digestType.Serialize(ds);\n        }\n        bool UseRandomNonce(void) const {\n            return nonceSource == 0;\n        }\n        bool UseRFC6979Nonce(void) const {\n            return nonceSource == 1;\n        }\n        bool UseSpecifiedNonce(void) const {\n            return nonceSource == 2;\n        }\n};\n\n"}
{"text_input": "Generate ECGDSA_Sign code for operations.h", "output": "class ECGDSA_Sign : public Operation {\n    public:\n        const component::CurveType curveType;\n        const component::ECC_PrivateKey priv;\n        const component::Bignum nonce;\n        const component::Cleartext cleartext;\n        const uint8_t nonceSource;\n        const component::DigestType digestType;\n\n        ECGDSA_Sign(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            priv(ds),\n            nonce(ds),\n            cleartext(ds),\n            nonceSource(ds.Get<uint8_t>()),\n            digestType(ds)\n        { }\n        ECGDSA_Sign(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            priv(json[\"priv\"]),\n            nonce(json[\"nonce\"]),\n            cleartext(json[\"cleartext\"]),\n            nonceSource(json[\"nonceSource\"].get<uint8_t>()),\n            digestType(json[\"digestType\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const ECGDSA_Sign& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (priv == rhs.priv) &&\n                (nonce == rhs.nonce) &&\n                (cleartext == rhs.cleartext) &&\n                (nonceSource == rhs.nonceSource ) &&\n                (digestType == rhs.digestType ) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            priv.Serialize(ds);\n            nonce.Serialize(ds);\n            cleartext.Serialize(ds);\n            ds.Put<>(nonceSource);\n            digestType.Serialize(ds);\n        }\n        bool UseRandomNonce(void) const {\n            return nonceSource == 0;\n        }\n        bool UseRFC6979Nonce(void) const {\n            return nonceSource == 1;\n        }\n        bool UseSpecifiedNonce(void) const {\n            return nonceSource == 2;\n        }\n};\n\n"}
{"text_input": "Generate ECRDSA_Sign code for operations.h", "output": "class ECRDSA_Sign : public Operation {\n    public:\n        const component::CurveType curveType;\n        const component::ECC_PrivateKey priv;\n        const component::Bignum nonce;\n        const component::Cleartext cleartext;\n        const uint8_t nonceSource;\n        const component::DigestType digestType;\n\n        ECRDSA_Sign(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            priv(ds),\n            nonce(ds),\n            cleartext(ds),\n            nonceSource(ds.Get<uint8_t>()),\n            digestType(ds)\n        { }\n        ECRDSA_Sign(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            priv(json[\"priv\"]),\n            nonce(json[\"nonce\"]),\n            cleartext(json[\"cleartext\"]),\n            nonceSource(json[\"nonceSource\"].get<uint8_t>()),\n            digestType(json[\"digestType\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const ECRDSA_Sign& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (priv == rhs.priv) &&\n                (nonce == rhs.nonce) &&\n                (cleartext == rhs.cleartext) &&\n                (nonceSource == rhs.nonceSource ) &&\n                (digestType == rhs.digestType ) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            priv.Serialize(ds);\n            nonce.Serialize(ds);\n            cleartext.Serialize(ds);\n            ds.Put<>(nonceSource);\n            digestType.Serialize(ds);\n        }\n        bool UseRandomNonce(void) const {\n            return nonceSource == 0;\n        }\n        bool UseRFC6979Nonce(void) const {\n            return nonceSource == 1;\n        }\n        bool UseSpecifiedNonce(void) const {\n            return nonceSource == 2;\n        }\n};\n\n"}
{"text_input": "Generate Schnorr_Sign code for operations.h", "output": "class Schnorr_Sign : public Operation {\n    public:\n        const component::CurveType curveType;\n        const component::ECC_PrivateKey priv;\n        const component::Bignum nonce;\n        const component::Cleartext cleartext;\n        const uint8_t nonceSource;\n        const component::DigestType digestType;\n\n        Schnorr_Sign(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            priv(ds),\n            nonce(ds),\n            cleartext(ds),\n            nonceSource(ds.Get<uint8_t>()),\n            digestType(ds)\n        { }\n        Schnorr_Sign(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            priv(json[\"priv\"]),\n            nonce(json[\"nonce\"]),\n            cleartext(json[\"cleartext\"]),\n            nonceSource(json[\"nonceSource\"].get<uint8_t>()),\n            digestType(json[\"digestType\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const Schnorr_Sign& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (priv == rhs.priv) &&\n                (nonce == rhs.nonce) &&\n                (cleartext == rhs.cleartext) &&\n                (nonceSource == rhs.nonceSource ) &&\n                (digestType == rhs.digestType ) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            priv.Serialize(ds);\n            nonce.Serialize(ds);\n            cleartext.Serialize(ds);\n            ds.Put<>(nonceSource);\n            digestType.Serialize(ds);\n        }\n        bool UseRandomNonce(void) const {\n            return nonceSource == 0;\n        }\n        bool UseBIP340Nonce(void) const {\n            return nonceSource == 1;\n        }\n        bool UseSpecifiedNonce(void) const {\n            return nonceSource == 2;\n        }\n};\n\n"}
{"text_input": "Generate ECCSI_Verify code for operations.h", "output": "class ECCSI_Verify : public Operation {\n    public:\n        const component::CurveType curveType;\n        const component::Cleartext cleartext;\n        const component::Cleartext id;\n        const component::ECCSI_Signature signature;\n        const component::DigestType digestType;\n\n        ECCSI_Verify(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            cleartext(ds),\n            id(ds),\n            signature(ds),\n            digestType(ds)\n        { }\n        ECCSI_Verify(const ECCSI_Sign& opECCSI_Sign, const component::ECCSI_Signature signature, component::Modifier modifier);\n        ECCSI_Verify(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            cleartext(json[\"cleartext\"]),\n            id(json[\"id\"]),\n            signature(json[\"signature\"]),\n            digestType(json[\"digestType\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const ECCSI_Verify& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (cleartext == rhs.cleartext) &&\n                (id == rhs.id) &&\n                (signature == rhs.signature) &&\n                (digestType == rhs.digestType) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            cleartext.Serialize(ds);\n            id.Serialize(ds);\n            signature.Serialize(ds);\n            digestType.Serialize(ds);\n        }\n};\n\n"}
{"text_input": "Generate ECDSA_Verify code for operations.h", "output": "class ECDSA_Verify : public Operation {\n    public:\n        const component::CurveType curveType;\n        const component::Cleartext cleartext;\n        const component::ECDSA_Signature signature;\n        const component::DigestType digestType;\n\n        ECDSA_Verify(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            cleartext(ds),\n            signature(ds),\n            digestType(ds)\n        { }\n        ECDSA_Verify(const ECDSA_Sign& opECDSA_Sign, const component::ECDSA_Signature signature, component::Modifier modifier);\n        ECDSA_Verify(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            cleartext(json[\"cleartext\"]),\n            signature(json[\"signature\"]),\n            digestType(json[\"digestType\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const ECDSA_Verify& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (cleartext == rhs.cleartext) &&\n                (signature == rhs.signature) &&\n                (digestType == rhs.digestType) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            cleartext.Serialize(ds);\n            signature.Serialize(ds);\n            digestType.Serialize(ds);\n        }\n};\n\n"}
{"text_input": "Generate ECGDSA_Verify code for operations.h", "output": "class ECGDSA_Verify : public Operation {\n    public:\n        const component::CurveType curveType;\n        const component::Cleartext cleartext;\n        const component::ECGDSA_Signature signature;\n        const component::DigestType digestType;\n\n        ECGDSA_Verify(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            cleartext(ds),\n            signature(ds),\n            digestType(ds)\n        { }\n        ECGDSA_Verify(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            cleartext(json[\"cleartext\"]),\n            signature(json[\"signature\"]),\n            digestType(json[\"digestType\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const ECGDSA_Verify& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (cleartext == rhs.cleartext) &&\n                (signature == rhs.signature) &&\n                (digestType == rhs.digestType) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            cleartext.Serialize(ds);\n            signature.Serialize(ds);\n            digestType.Serialize(ds);\n        }\n};\n\n"}
{"text_input": "Generate ECRDSA_Verify code for operations.h", "output": "class ECRDSA_Verify : public Operation {\n    public:\n        const component::CurveType curveType;\n        const component::Cleartext cleartext;\n        const component::ECRDSA_Signature signature;\n        const component::DigestType digestType;\n\n        ECRDSA_Verify(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            cleartext(ds),\n            signature(ds),\n            digestType(ds)\n        { }\n        ECRDSA_Verify(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            cleartext(json[\"cleartext\"]),\n            signature(json[\"signature\"]),\n            digestType(json[\"digestType\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const ECRDSA_Verify& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (cleartext == rhs.cleartext) &&\n                (signature == rhs.signature) &&\n                (digestType == rhs.digestType) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            cleartext.Serialize(ds);\n            signature.Serialize(ds);\n            digestType.Serialize(ds);\n        }\n};\n\n"}
{"text_input": "Generate ECDSA_Recover code for operations.h", "output": "class ECDSA_Recover : public Operation {\n    public:\n        const component::CurveType curveType;\n        const component::Cleartext cleartext;\n        const component::BignumPair signature;\n        const component::DigestType digestType;\n        const uint8_t id;\n\n        ECDSA_Recover(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            cleartext(ds),\n            signature(ds),\n            digestType(ds),\n            id(ds.Get<uint8_t>())\n        { }\n        ECDSA_Recover(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            cleartext(json[\"cleartext\"]),\n            signature(json[\"signature\"]),\n            digestType(json[\"digestType\"]),\n            id(json[\"id\"].get<uint8_t>())\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const ECDSA_Recover& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (cleartext == rhs.cleartext) &&\n                (signature == rhs.signature) &&\n                (digestType == rhs.digestType) &&\n                (id == rhs.id) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            cleartext.Serialize(ds);\n            signature.Serialize(ds);\n            digestType.Serialize(ds);\n            ds.Put<>(id);\n        }\n};\n\n"}
{"text_input": "Generate DSA_GenerateParameters code for operations.h", "output": "class DSA_GenerateParameters : public Operation {\n    public:\n        DSA_GenerateParameters(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier))\n        { (void)ds; }\n        DSA_GenerateParameters(nlohmann::json json) :\n            Operation(json[\"modifier\"])\n        { }\n        DSA_GenerateParameters(component::Modifier modifier) :\n            Operation(std::move(modifier))\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const DSA_GenerateParameters& rhs) const {\n            return\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            (void)ds;\n        }\n};\n\n"}
{"text_input": "Generate DSA_PrivateToPublic code for operations.h", "output": "class DSA_PrivateToPublic : public Operation {\n    public:\n        const component::Bignum g;\n        const component::Bignum p;\n        const component::Bignum priv;\n\n        DSA_PrivateToPublic(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            g(ds),\n            p(ds),\n            priv(ds)\n        { }\n        DSA_PrivateToPublic(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            g(json[\"g\"]),\n            p(json[\"p\"]),\n            priv(json[\"priv\"])\n        { }\n        DSA_PrivateToPublic(\n                component::Modifier modifier,\n                component::Bignum g,\n                component::Bignum p,\n                component::Bignum priv) :\n            Operation(std::move(modifier)),\n            g(g),\n            p(p),\n            priv(priv)\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const DSA_PrivateToPublic& rhs) const {\n            return\n                (g == rhs.g) &&\n                (p == rhs.p) &&\n                (priv == rhs.priv) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            priv.Serialize(ds);\n        }\n};\n\n"}
{"text_input": "Generate DSA_GenerateKeyPair code for operations.h", "output": "class DSA_GenerateKeyPair : public Operation {\n    public:\n        const component::Bignum p;\n        const component::Bignum q;\n        const component::Bignum g;\n\n        DSA_GenerateKeyPair(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            p(ds),\n            q(ds),\n            g(ds)\n        { }\n        DSA_GenerateKeyPair(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            p(json[\"p\"]),\n            q(json[\"q\"]),\n            g(json[\"g\"])\n        { }\n        DSA_GenerateKeyPair(\n                component::Modifier modifier,\n                component::Bignum p,\n                component::Bignum q,\n                component::Bignum g) :\n            Operation(std::move(modifier)),\n            p(p),\n            q(q),\n            g(g)\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const DSA_GenerateKeyPair& rhs) const {\n            return\n                (p == rhs.p) &&\n                (q == rhs.q) &&\n                (g == rhs.g) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            p.Serialize(ds);\n            q.Serialize(ds);\n            g.Serialize(ds);\n        }\n};\n\n"}
{"text_input": "Generate DSA_Sign code for operations.h", "output": "class DSA_Sign : public Operation {\n    public:\n        const component::DSA_Parameters parameters;\n        const component::Bignum priv;\n        const component::Cleartext cleartext;\n\n        DSA_Sign(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            parameters(ds),\n            priv(ds),\n            cleartext(ds)\n        { }\n        DSA_Sign(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            parameters(json[\"parameters\"]),\n            priv(json[\"priv\"]),\n            cleartext(json[\"cleartext\"])\n        { }\n        DSA_Sign(\n                component::Modifier modifier,\n                component::DSA_Parameters parameters,\n                component::Bignum priv,\n                component::Cleartext cleartext) :\n            Operation(std::move(modifier)),\n            parameters(parameters),\n            priv(priv),\n            cleartext(cleartext)\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const DSA_Sign& rhs) const {\n            return\n                (parameters == rhs.parameters) &&\n                (priv == rhs.priv) &&\n                (cleartext == rhs.cleartext) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            parameters.Serialize(ds);\n            priv.Serialize(ds);\n            cleartext.Serialize(ds);\n        }\n};\n\n"}
{"text_input": "Generate DSA_Verify code for operations.h", "output": "class DSA_Verify : public Operation {\n    public:\n        const component::DSA_Parameters parameters;\n        const component::Bignum pub;\n        const component::BignumPair signature;\n        const component::Cleartext cleartext;\n\n        DSA_Verify(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            parameters(ds),\n            pub(ds),\n            signature(ds),\n            cleartext(ds)\n        { }\n        DSA_Verify(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            parameters(json[\"parameters\"]),\n            pub(json[\"pub\"]),\n            signature(json[\"signature\"]),\n            cleartext(json[\"cleartext\"])\n        { }\n        DSA_Verify(\n                component::Modifier modifier,\n                component::DSA_Parameters parameters,\n                component::Bignum pub,\n                component::BignumPair signature,\n                component::Cleartext cleartext) :\n            Operation(std::move(modifier)),\n            parameters(parameters),\n            pub(pub),\n            signature(signature),\n            cleartext(cleartext)\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const DSA_Verify& rhs) const {\n            return\n                (parameters == rhs.parameters) &&\n                (pub == rhs.pub) &&\n                (signature == rhs.signature) &&\n                (cleartext == rhs.cleartext) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            parameters.Serialize(ds);\n            pub.Serialize(ds);\n            signature.Serialize(ds);\n            cleartext.Serialize(ds);\n        }\n};\n\n"}
{"text_input": "Generate Schnorr_Verify code for operations.h", "output": "class Schnorr_Verify : public Operation {\n    public:\n        const component::CurveType curveType;\n        const component::Cleartext cleartext;\n        const component::ECDSA_Signature signature;\n        const component::DigestType digestType;\n\n        Schnorr_Verify(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            cleartext(ds),\n            signature(ds),\n            digestType(ds)\n        { }\n        Schnorr_Verify(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            cleartext(json[\"cleartext\"]),\n            signature(json[\"signature\"]),\n            digestType(json[\"digestType\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const Schnorr_Verify& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (cleartext == rhs.cleartext) &&\n                (signature == rhs.signature) &&\n                (digestType == rhs.digestType) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            cleartext.Serialize(ds);\n            signature.Serialize(ds);\n            digestType.Serialize(ds);\n        }\n};\n\n"}
{"text_input": "Generate ECDH_Derive code for operations.h", "output": "class ECDH_Derive : public Operation {\n    public:\n        const component::CurveType curveType;\n        const component::ECC_PrivateKey priv;\n        const component::ECC_PublicKey pub;\n\n        ECDH_Derive(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            priv(ds),\n            pub(ds)\n        { }\n        ECDH_Derive(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            priv(json[\"priv\"]),\n            pub(json[\"pub_x\"], json[\"pub_y\"])\n        { }\n        ECDH_Derive(\n                component::Modifier modifier,\n                component::CurveType curveType,\n                component::ECC_PrivateKey priv,\n                component::ECC_PublicKey pub) :\n            Operation(std::move(modifier)),\n            curveType(curveType),\n            priv(priv),\n            pub(pub)\n        { }\n\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const ECDH_Derive& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (priv == rhs.priv) &&\n                (pub == rhs.pub) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            priv.Serialize(ds);\n            pub.Serialize(ds);\n        }\n};\n\n"}
{"text_input": "Generate ECIES_Encrypt code for operations.h", "output": "class ECIES_Encrypt : public Operation {\n    public:\n        const component::Cleartext cleartext;\n        const component::CurveType curveType;\n        const component::ECC_PrivateKey priv;\n        const component::ECC_PublicKey pub;\n        const component::SymmetricCipherType cipherType;\n        const std::optional<component::SymmetricIV> iv;\n        /* TODO kdf type */\n        /* TODO mac type */\n\n        ECIES_Encrypt(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            cleartext(ds),\n            curveType(ds),\n            priv(ds),\n            pub(ds),\n            cipherType(ds),\n            iv(ds.Get<bool>() ? std::nullopt : std::make_optional<component::SymmetricIV>(ds))\n        { }\n        ECIES_Encrypt(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            cleartext(json[\"cleartext\"]),\n            curveType(json[\"curveType\"]),\n            priv(json[\"priv\"]),\n            pub(json[\"pub_x\"], json[\"pub_y\"]),\n            cipherType(json[\"cipherType\"]),\n            iv(\n                    json[\"iv_enabled\"].get<bool>() ?\n                        std::optional<component::SymmetricIV>(json[\"iv\"]) :\n                        std::optional<component::SymmetricIV>(std::nullopt)\n            )\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const ECIES_Encrypt& rhs) const {\n            return\n                (cleartext == rhs.cleartext) &&\n                (curveType == rhs.curveType) &&\n                (priv == rhs.priv) &&\n                (pub == rhs.pub) &&\n                (cipherType == rhs.cipherType) &&\n                (iv == rhs.iv) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            cleartext.Serialize(ds);\n            curveType.Serialize(ds);\n            priv.Serialize(ds);\n            pub.Serialize(ds);\n            cipherType.Serialize(ds);\n            if ( iv == std::nullopt ) {\n                ds.Put<bool>(true);\n            } else {\n                ds.Put<bool>(false);\n                iv->Serialize(ds);\n            }\n        }\n};\n\n"}
{"text_input": "Generate ECIES_Decrypt code for operations.h", "output": "class ECIES_Decrypt : public Operation {\n    public:\n        const Buffer ciphertext;\n        const component::CurveType curveType;\n        const component::ECC_PrivateKey priv;\n        const component::ECC_PublicKey pub;\n        const component::SymmetricCipherType cipherType;\n        const std::optional<component::SymmetricIV> iv;\n        /* TODO kdf type */\n        /* TODO mac type */\n\n        ECIES_Decrypt(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            ciphertext(ds),\n            curveType(ds),\n            priv(ds),\n            pub(ds),\n            cipherType(ds),\n            iv(ds.Get<bool>() ? std::nullopt : std::make_optional<component::SymmetricIV>(ds))\n        { }\n        ECIES_Decrypt(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            ciphertext(json[\"ciphertext\"]),\n            curveType(json[\"curveType\"]),\n            priv(json[\"priv\"]),\n            pub(json[\"pub_x\"], json[\"pub_y\"]),\n            cipherType(json[\"cipherType\"]),\n            iv(\n                    json[\"iv_enabled\"].get<bool>() ?\n                        std::optional<component::SymmetricIV>(json[\"iv\"]) :\n                        std::optional<component::SymmetricIV>(std::nullopt)\n            )\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const ECIES_Decrypt& rhs) const {\n            return\n                (ciphertext == rhs.ciphertext) &&\n                (curveType == rhs.curveType) &&\n                (priv == rhs.priv) &&\n                (pub == rhs.pub) &&\n                (cipherType == rhs.cipherType) &&\n                (iv == rhs.iv) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            ciphertext.Serialize(ds);\n            curveType.Serialize(ds);\n            priv.Serialize(ds);\n            pub.Serialize(ds);\n            cipherType.Serialize(ds);\n            if ( iv == std::nullopt ) {\n                ds.Put<bool>(true);\n            } else {\n                ds.Put<bool>(false);\n                iv->Serialize(ds);\n            }\n        }\n};\n\n"}
{"text_input": "Generate ECC_Point_Add code for operations.h", "output": "class ECC_Point_Add : public Operation {\n    public:\n        const component::CurveType curveType;\n        const component::ECC_Point a, b;\n\n        ECC_Point_Add(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            a(ds),\n            b(ds)\n        { }\n        ECC_Point_Add(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            a(json[\"a_x\"], json[\"a_y\"]),\n            b(json[\"b_x\"], json[\"b_y\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const ECC_Point_Add& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (a == rhs.a) &&\n                (b == rhs.b) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            a.Serialize(ds);\n            b.Serialize(ds);\n        }\n};\n\n"}
{"text_input": "Generate ECC_Point_Sub code for operations.h", "output": "class ECC_Point_Sub : public Operation {\n    public:\n        const component::CurveType curveType;\n        const component::ECC_Point a, b;\n\n        ECC_Point_Sub(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            a(ds),\n            b(ds)\n        { }\n        ECC_Point_Sub(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            a(json[\"a_x\"], json[\"a_y\"]),\n            b(json[\"b_x\"], json[\"b_y\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const ECC_Point_Sub& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (a == rhs.a) &&\n                (b == rhs.b) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            a.Serialize(ds);\n            b.Serialize(ds);\n        }\n};\n\n"}
{"text_input": "Generate ECC_Point_Mul code for operations.h", "output": "class ECC_Point_Mul : public Operation {\n    public:\n        const component::CurveType curveType;\n        const component::ECC_Point a;\n        const component::Bignum b;\n\n        ECC_Point_Mul(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            a(ds),\n            b(ds)\n        { }\n        ECC_Point_Mul(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            a(json[\"a_x\"], json[\"a_y\"]),\n            b(json[\"b\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const ECC_Point_Mul& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (a == rhs.a) &&\n                (b == rhs.b) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            a.Serialize(ds);\n            b.Serialize(ds);\n        }\n};\n\n"}
{"text_input": "Generate ECC_Point_Neg code for operations.h", "output": "class ECC_Point_Neg : public Operation {\n    public:\n        const component::CurveType curveType;\n        const component::ECC_Point a;\n\n        ECC_Point_Neg(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            a(ds)\n        { }\n        ECC_Point_Neg(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            a(json[\"a_x\"], json[\"a_y\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const ECC_Point_Neg& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (a == rhs.a) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            a.Serialize(ds);\n        }\n};\n\n"}
{"text_input": "Generate ECC_Point_Dbl code for operations.h", "output": "class ECC_Point_Dbl : public Operation {\n    public:\n        const component::CurveType curveType;\n        const component::ECC_Point a;\n\n        ECC_Point_Dbl(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            a(ds)\n        { }\n        ECC_Point_Dbl(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            a(json[\"a_x\"], json[\"a_y\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const ECC_Point_Dbl& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (a == rhs.a) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            a.Serialize(ds);\n        }\n};\n\n"}
{"text_input": "Generate ECC_Point_Cmp code for operations.h", "output": "class ECC_Point_Cmp : public Operation {\n    public:\n        const component::CurveType curveType;\n        const component::ECC_Point a, b;\n\n        ECC_Point_Cmp(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            a(ds),\n            b(ds)\n        { }\n        ECC_Point_Cmp(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            a(json[\"a_x\"], json[\"a_y\"]),\n            b(json[\"b_x\"], json[\"b_y\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const ECC_Point_Cmp& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (a == rhs.a) &&\n                (b == rhs.b) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            a.Serialize(ds);\n            b.Serialize(ds);\n        }\n};\n\n"}
{"text_input": "Generate DH_GenerateKeyPair code for operations.h", "output": "class DH_GenerateKeyPair : public Operation {\n    public:\n        const component::Bignum prime;\n        const component::Bignum base;\n\n        DH_GenerateKeyPair(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            prime(ds),\n            base(ds)\n        { }\n        DH_GenerateKeyPair(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            prime(json[\"prime\"]),\n            base(json[\"base\"])\n        { }\n        DH_GenerateKeyPair(\n                component::Modifier modifier,\n                component::Bignum prime,\n                component::Bignum base) :\n            Operation(std::move(modifier)),\n            prime(prime),\n            base(base)\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const DH_GenerateKeyPair& rhs) const {\n            return\n                (prime == rhs.prime) &&\n                (base  == rhs.base) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            prime.Serialize(ds);\n            base.Serialize(ds);\n        }\n};\n\n"}
{"text_input": "Generate DH_Derive code for operations.h", "output": "class DH_Derive : public Operation {\n    public:\n        const component::Bignum prime;\n        const component::Bignum base;\n        const component::Bignum pub;\n        const component::Bignum priv;\n\n        DH_Derive(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            prime(ds),\n            base(ds),\n            pub(ds),\n            priv(ds)\n        { }\n        DH_Derive(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            prime(json[\"prime\"]),\n            base(json[\"base\"]),\n            pub(json[\"pub\"]),\n            priv(json[\"priv\"])\n        { }\n        DH_Derive(\n                component::Modifier modifier,\n                component::Bignum prime,\n                component::Bignum base,\n                component::Bignum pub,\n                component::Bignum priv) :\n            Operation(std::move(modifier)),\n            prime(prime),\n            base(base),\n            pub(pub),\n            priv(priv)\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const DH_Derive& rhs) const {\n            return\n                (prime == rhs.prime) &&\n                (base  == rhs.base) &&\n                (pub == rhs.pub) &&\n                (priv == rhs.priv) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            prime.Serialize(ds);\n            base.Serialize(ds);\n            pub.Serialize(ds);\n            priv.Serialize(ds);\n        }\n};\n\n"}
{"text_input": "Generate BignumCalc code for operations.h", "output": "class BignumCalc : public Operation {\n    public:\n        const component::CalcOp calcOp;\n        const component::Bignum bn0;\n        const component::Bignum bn1;\n        const component::Bignum bn2;\n        const component::Bignum bn3;\n        std::optional<component::Bignum> modulo;\n\n        BignumCalc(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            calcOp(ds),\n            bn0(ds),\n            bn1(ds),\n            bn2(ds),\n            bn3(ds)\n        { }\n        BignumCalc(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            calcOp(json[\"calcOp\"]),\n            bn0(json[\"bn1\"]),\n            bn1(json[\"bn2\"]),\n            bn2(json[\"bn3\"]),\n            bn3(json[\"bn4\"])\n        { }\n        BignumCalc(\n                component::Modifier modifier,\n                component::CurveType calcOp,\n                component::Bignum bn0,\n                component::Bignum bn1,\n                component::Bignum bn2,\n                component::Bignum bn3) :\n            Operation(std::move(modifier)),\n            calcOp(calcOp),\n            bn0(bn0),\n            bn1(bn1),\n            bn2(bn2),\n            bn3(bn3)\n        { }\n\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const BignumCalc& rhs) const {\n            return\n                (calcOp == rhs.calcOp) &&\n                (bn0 == rhs.bn0) &&\n                (bn1 == rhs.bn1) &&\n                (bn2 == rhs.bn2) &&\n                (bn3 == rhs.bn3) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            calcOp.Serialize(ds);\n            bn0.Serialize(ds);\n            bn1.Serialize(ds);\n            bn2.Serialize(ds);\n            bn3.Serialize(ds);\n        }\n        void SetModulo(component::Bignum& modulo);\n};\n\n"}
{"text_input": "Generate BignumCalc_Fp2 code for operations.h", "output": "class BignumCalc_Fp2 : public Operation {\n    public:\n        const component::CalcOp calcOp;\n        const component::Fp2 bn0;\n        const component::Fp2 bn1;\n        const component::Fp2 bn2;\n        const component::Fp2 bn3;\n        std::optional<component::Fp2> modulo;\n\n        BignumCalc_Fp2(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            calcOp(ds),\n            bn0(ds),\n            bn1(ds),\n            bn2(ds),\n            bn3(ds)\n        { }\n        BignumCalc_Fp2(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            calcOp(json[\"calcOp\"]),\n            bn0(json[\"bn1\"]),\n            bn1(json[\"bn2\"]),\n            bn2(json[\"bn3\"]),\n            bn3(json[\"bn4\"])\n        { }\n        BignumCalc_Fp2(\n                component::Modifier modifier,\n                component::CurveType calcOp,\n                component::Fp2 bn0,\n                component::Fp2 bn1,\n                component::Fp2 bn2,\n                component::Fp2 bn3) :\n            Operation(std::move(modifier)),\n            calcOp(calcOp),\n            bn0(bn0),\n            bn1(bn1),\n            bn2(bn2),\n            bn3(bn3)\n        { }\n\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const BignumCalc_Fp2& rhs) const {\n            return\n                (calcOp == rhs.calcOp) &&\n                (bn0 == rhs.bn0) &&\n                (bn1 == rhs.bn1) &&\n                (bn2 == rhs.bn2) &&\n                (bn3 == rhs.bn3) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            calcOp.Serialize(ds);\n            bn0.Serialize(ds);\n            bn1.Serialize(ds);\n            bn2.Serialize(ds);\n            bn3.Serialize(ds);\n        }\n        void SetModulo(component::Fp2& modulo);\n};\n\n"}
{"text_input": "Generate BignumCalc_Fp12 code for operations.h", "output": "class BignumCalc_Fp12 : public Operation {\n    public:\n        const component::CalcOp calcOp;\n        const component::Fp12 bn0;\n        const component::Fp12 bn1;\n        const component::Fp12 bn2;\n        const component::Fp12 bn3;\n        std::optional<component::Fp12> modulo;\n\n        BignumCalc_Fp12(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            calcOp(ds),\n            bn0(ds),\n            bn1(ds),\n            bn2(ds),\n            bn3(ds)\n        { }\n        BignumCalc_Fp12(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            calcOp(json[\"calcOp\"]),\n            bn0(json[\"bn1\"]),\n            bn1(json[\"bn2\"]),\n            bn2(json[\"bn3\"]),\n            bn3(json[\"bn4\"])\n        { }\n        BignumCalc_Fp12(\n                component::Modifier modifier,\n                component::CurveType calcOp,\n                component::Fp12 bn0,\n                component::Fp12 bn1,\n                component::Fp12 bn2,\n                component::Fp12 bn3) :\n            Operation(std::move(modifier)),\n            calcOp(calcOp),\n            bn0(bn0),\n            bn1(bn1),\n            bn2(bn2),\n            bn3(bn3)\n        { }\n\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const BignumCalc_Fp12& rhs) const {\n            return\n                (calcOp == rhs.calcOp) &&\n                (bn0 == rhs.bn0) &&\n                (bn1 == rhs.bn1) &&\n                (bn2 == rhs.bn2) &&\n                (bn3 == rhs.bn3) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            calcOp.Serialize(ds);\n            bn0.Serialize(ds);\n            bn1.Serialize(ds);\n            bn2.Serialize(ds);\n            bn3.Serialize(ds);\n        }\n        void SetModulo(component::Fp12& modulo);\n};\n\n"}
{"text_input": "Generate BLS_PrivateToPublic code for operations.h", "output": "class BLS_PrivateToPublic : public Operation {\n    public:\n        const component::CurveType curveType;\n        const component::BLS_PrivateKey priv;\n\n        BLS_PrivateToPublic(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            priv(ds)\n        { }\n        BLS_PrivateToPublic(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            priv(json[\"priv\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const BLS_PrivateToPublic& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (priv == rhs.priv) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            priv.Serialize(ds);\n        }\n};\n\n"}
{"text_input": "Generate BLS_PrivateToPublic_G2 code for operations.h", "output": "class BLS_PrivateToPublic_G2 : public Operation {\n    public:\n        const component::CurveType curveType;\n        const component::BLS_PrivateKey priv;\n\n        BLS_PrivateToPublic_G2(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            priv(ds)\n        { }\n        BLS_PrivateToPublic_G2(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            priv(json[\"priv\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const BLS_PrivateToPublic_G2& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (priv == rhs.priv) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            priv.Serialize(ds);\n        }\n};\n\n"}
{"text_input": "Generate BLS_Sign code for operations.h", "output": "class BLS_Sign : public Operation {\n    public:\n        const component::CurveType curveType;\n        const component::BLS_PrivateKey priv;\n        const bool hashOrPoint;\n        const component::G2 point;\n        const component::Cleartext cleartext;\n        const component::Cleartext dest;\n        const component::Cleartext aug;\n\n        BLS_Sign(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            priv(ds),\n            hashOrPoint(ds.Get<bool>()),\n            point(ds),\n            cleartext(ds),\n            dest(ds),\n            aug(ds)\n        { }\n        BLS_Sign(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            priv(json[\"priv\"]),\n            hashOrPoint(json[\"hashOrPoint\"]),\n            point(json[\"point_v\"], json[\"point_w\"], json[\"point_x\"], json[\"point_y\"]),\n            cleartext(json[\"cleartext\"]),\n            dest(json[\"dest\"]),\n            aug(json[\"aug\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const BLS_Sign& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (priv == rhs.priv) &&\n                (hashOrPoint == rhs.hashOrPoint) &&\n                (point == rhs.point) &&\n                (cleartext == rhs.cleartext) &&\n                (dest == rhs.dest) &&\n                (aug == rhs.aug) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            priv.Serialize(ds);\n            ds.Put<bool>(hashOrPoint);\n            point.Serialize(ds);\n            cleartext.Serialize(ds);\n            dest.Serialize(ds);\n            aug.Serialize(ds);\n        }\n};\n\n"}
{"text_input": "Generate BLS_Verify code for operations.h", "output": "class BLS_Verify : public Operation {\n    public:\n        const component::CurveType curveType;\n        const component::BLS_PublicKey pub;\n        const bool hashOrPoint;\n        const component::G2 point;\n        const component::Cleartext cleartext;\n        const component::Cleartext dest;\n        const component::G2 signature;\n\n        BLS_Verify(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            pub(ds),\n            hashOrPoint(ds.Get<bool>()),\n            point(ds),\n            cleartext(ds),\n            dest(ds),\n            signature(ds)\n        { }\n        BLS_Verify(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            pub(json[\"pub_x\"], json[\"pub_y\"]),\n            hashOrPoint(json[\"hashOrPoint\"]),\n            point(json[\"point_v\"], json[\"point_w\"], json[\"point_x\"], json[\"point_y\"]),\n            cleartext(json[\"cleartext\"]),\n            dest(json[\"dest\"]),\n            signature(json[\"sig_v\"], json[\"sig_w\"], json[\"sig_x\"], json[\"sig_y\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const BLS_Verify& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (pub == rhs.pub) &&\n                (hashOrPoint == rhs.hashOrPoint) &&\n                (point == rhs.point) &&\n                (cleartext == rhs.cleartext) &&\n                (dest == rhs.dest) &&\n                (signature == rhs.signature) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            pub.Serialize(ds);\n            ds.Put<bool>(hashOrPoint);\n            point.Serialize(ds);\n            cleartext.Serialize(ds);\n            dest.Serialize(ds);\n            signature.Serialize(ds);\n        }\n};\n\n"}
{"text_input": "Generate BLS_BatchSign code for operations.h", "output": "class BLS_BatchSign : public Operation {\n    public:\n        component::BLS_BatchSign_Vector bf;\n\n        BLS_BatchSign(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            bf(ds)\n        { }\n        BLS_BatchSign(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            bf(json[\"bf\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const BLS_BatchSign& rhs) const {\n            return\n                (bf == rhs.bf) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            bf.Serialize(ds);\n        }\n};\n\n"}
{"text_input": "Generate BLS_BatchVerify code for operations.h", "output": "class BLS_BatchVerify : public Operation {\n    public:\n        component::BLS_BatchVerify_Vector bf;\n\n        BLS_BatchVerify(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            bf(ds)\n        { }\n        BLS_BatchVerify(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            bf(json[\"bf\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const BLS_BatchVerify& rhs) const {\n            return\n                (bf == rhs.bf) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            bf.Serialize(ds);\n        }\n};\n\n"}
{"text_input": "Generate BLS_Aggregate_G1 code for operations.h", "output": "class BLS_Aggregate_G1 : public Operation {\n    public:\n        const component::CurveType curveType;\n        component::BLS_G1_Vector points;\n\n        BLS_Aggregate_G1(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            points(ds)\n        { }\n        BLS_Aggregate_G1(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            points(json[\"points\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const BLS_Aggregate_G1& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (points == rhs.points) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            points.Serialize(ds);\n        }\n};\n\n"}
{"text_input": "Generate BLS_Aggregate_G2 code for operations.h", "output": "class BLS_Aggregate_G2 : public Operation {\n    public:\n        const component::CurveType curveType;\n        component::BLS_G2_Vector points;\n\n        BLS_Aggregate_G2(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            points(ds)\n        { }\n        BLS_Aggregate_G2(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            points(json[\"points\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const BLS_Aggregate_G2& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (points == rhs.points) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            points.Serialize(ds);\n        }\n};\n\n"}
{"text_input": "Generate BLS_Pairing code for operations.h", "output": "class BLS_Pairing : public Operation {\n    public:\n        const component::CurveType curveType;\n        const component::G1 g1;\n        const component::G2 g2;\n\n        BLS_Pairing(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            g1(ds),\n            g2(ds)\n        { }\n        BLS_Pairing(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            g1(json[\"g1_x\"], json[\"g1_y\"]),\n            g2(json[\"g2_v\"], json[\"g2_w\"], json[\"g2_x\"], json[\"g2_y\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const BLS_Pairing& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (g1 == rhs.g1) &&\n                (g2 == rhs.g2) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            g1.Serialize(ds);\n            g2.Serialize(ds);\n        }\n};\n\n"}
{"text_input": "Generate BLS_MillerLoop code for operations.h", "output": "class BLS_MillerLoop : public Operation {\n    public:\n        const component::CurveType curveType;\n        const component::G1 g1;\n        const component::G2 g2;\n\n        BLS_MillerLoop(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            g1(ds),\n            g2(ds)\n        { }\n        BLS_MillerLoop(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            g1(json[\"g1_x\"], json[\"g1_y\"]),\n            g2(json[\"g2_v\"], json[\"g2_w\"], json[\"g2_x\"], json[\"g2_y\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const BLS_MillerLoop& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (g1 == rhs.g1) &&\n                (g2 == rhs.g2) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            g1.Serialize(ds);\n            g2.Serialize(ds);\n        }\n};\n\n"}
{"text_input": "Generate BLS_FinalExp code for operations.h", "output": "class BLS_FinalExp : public Operation {\n    public:\n        const component::CurveType curveType;\n        const component::Fp12 fp12;\n\n        BLS_FinalExp(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            fp12(ds)\n        { }\n        BLS_FinalExp(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            fp12(json[\"fp12\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const BLS_FinalExp& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (fp12 == rhs.fp12) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            fp12.Serialize(ds);\n        }\n};\n\n"}
{"text_input": "Generate BLS_HashToG1 code for operations.h", "output": "class BLS_HashToG1 : public Operation {\n    public:\n        const component::CurveType curveType;\n        const component::Cleartext cleartext;\n        const component::Cleartext dest;\n        const component::Cleartext aug;\n\n        BLS_HashToG1(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            cleartext(ds),\n            dest(ds),\n            aug(ds)\n        { }\n        BLS_HashToG1(const component::CurveType curveType, const component::Cleartext cleartext, const component::Cleartext dest, const component::Cleartext aug, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(curveType),\n            cleartext(cleartext),\n            dest(dest),\n            aug(aug)\n        { }\n        BLS_HashToG1(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            cleartext(json[\"cleartext\"]),\n            dest(json[\"dest\"]),\n            aug(json[\"aug\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const BLS_HashToG1& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (cleartext == rhs.cleartext) &&\n                (dest == rhs.dest) &&\n                (aug == rhs.aug) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            cleartext.Serialize(ds);\n            dest.Serialize(ds);\n            aug.Serialize(ds);\n        }\n};\n\n"}
{"text_input": "Generate BLS_HashToG2 code for operations.h", "output": "class BLS_HashToG2 : public Operation {\n    public:\n        const component::CurveType curveType;\n        const component::Cleartext cleartext;\n        const component::Cleartext dest;\n        const component::Cleartext aug;\n\n        BLS_HashToG2(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            cleartext(ds),\n            dest(ds),\n            aug(ds)\n        { }\n        BLS_HashToG2(const component::CurveType curveType, const component::Cleartext cleartext, const component::Cleartext dest, const component::Cleartext aug, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(curveType),\n            cleartext(cleartext),\n            dest(dest),\n            aug(aug)\n        { }\n        BLS_HashToG2(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            cleartext(json[\"cleartext\"]),\n            dest(json[\"dest\"]),\n            aug(json[\"aug\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const BLS_HashToG2& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (cleartext == rhs.cleartext) &&\n                (dest == rhs.dest) &&\n                (aug == rhs.aug) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            cleartext.Serialize(ds);\n            dest.Serialize(ds);\n            aug.Serialize(ds);\n        }\n};\n\n"}
{"text_input": "Generate BLS_MapToG1 code for operations.h", "output": "class BLS_MapToG1 : public Operation {\n    public:\n        const component::CurveType curveType;\n        const component::Bignum u;\n        const component::Bignum v;\n\n        BLS_MapToG1(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            u(ds),\n            v(ds)\n        { }\n        BLS_MapToG1(const component::CurveType curveType, const component::Bignum u, const component::Bignum v, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(curveType),\n            u(u),\n            v(v)\n        { }\n        BLS_MapToG1(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            u(json[\"u\"]),\n            v(json[\"v\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const BLS_MapToG1& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (u == rhs.u) &&\n                (v == rhs.v) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            u.Serialize(ds);\n            v.Serialize(ds);\n        }\n};\n\n"}
{"text_input": "Generate BLS_MapToG2 code for operations.h", "output": "class BLS_MapToG2 : public Operation {\n    public:\n        const component::CurveType curveType;\n        const component::Fp2 u;\n        const component::Fp2 v;\n\n        BLS_MapToG2(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            u(ds),\n            v(ds)\n        { }\n        BLS_MapToG2(const component::CurveType curveType, const component::Fp2 u, const component::Fp2 v, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(curveType),\n            u(u),\n            v(v)\n        { }\n        BLS_MapToG2(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            u(json[\"u\"]),\n            v(json[\"v\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const BLS_MapToG2& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (u == rhs.u) &&\n                (v == rhs.v) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            u.Serialize(ds);\n            v.Serialize(ds);\n        }\n};\n\n"}
{"text_input": "Generate BLS_IsG1OnCurve code for operations.h", "output": "class BLS_IsG1OnCurve : public Operation {\n    public:\n        const component::CurveType curveType;\n        const component::G1 g1;\n\n        BLS_IsG1OnCurve(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            g1(ds)\n        { }\n        BLS_IsG1OnCurve(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            g1(json[\"g1_x\"], json[\"g1_y\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const BLS_IsG1OnCurve& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (g1 == rhs.g1) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            g1.Serialize(ds);\n        }\n};\n\n"}
{"text_input": "Generate BLS_IsG2OnCurve code for operations.h", "output": "class BLS_IsG2OnCurve : public Operation {\n    public:\n        const component::CurveType curveType;\n        const component::G2 g2;\n\n        BLS_IsG2OnCurve(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            g2(ds)\n        { }\n        BLS_IsG2OnCurve(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            g2(json[\"g2_v\"], json[\"g2_w\"], json[\"g2_x\"], json[\"g2_y\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const BLS_IsG2OnCurve& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (g2 == rhs.g2) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            g2.Serialize(ds);\n        }\n};\n\n"}
{"text_input": "Generate BLS_GenerateKeyPair code for operations.h", "output": "class BLS_GenerateKeyPair : public Operation {\n    public:\n        const component::CurveType curveType;\n        const component::Cleartext ikm;\n        const component::Cleartext info;\n\n        BLS_GenerateKeyPair(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            ikm(ds),\n            info(ds)\n        { }\n\n        BLS_GenerateKeyPair(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            ikm(json[\"ikm\"]),\n            info(json[\"info\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const BLS_GenerateKeyPair& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (ikm == rhs.ikm) &&\n                (info == rhs.info) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            ikm.Serialize(ds);\n            info.Serialize(ds);\n        }\n};\n\n"}
{"text_input": "Generate BLS_Decompress_G1 code for operations.h", "output": "class BLS_Decompress_G1 : public Operation {\n    public:\n        const component::CurveType curveType;\n        const component::Bignum compressed;\n\n        BLS_Decompress_G1(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            compressed(ds)\n        { }\n        BLS_Decompress_G1(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            compressed(json[\"compressed\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const BLS_Decompress_G1& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (compressed == rhs.compressed) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            compressed.Serialize(ds);\n        }\n};\n\n"}
{"text_input": "Generate BLS_Compress_G1 code for operations.h", "output": "class BLS_Compress_G1 : public Operation {\n    public:\n        const component::CurveType curveType;\n        const component::G1 uncompressed;\n\n        BLS_Compress_G1(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            uncompressed(ds)\n        { }\n        BLS_Compress_G1(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            uncompressed(json[\"g1_x\"], json[\"g1_y\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const BLS_Compress_G1& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (uncompressed == rhs.uncompressed) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            uncompressed.Serialize(ds);\n        }\n};\n\n"}
{"text_input": "Generate BLS_Decompress_G2 code for operations.h", "output": "class BLS_Decompress_G2 : public Operation {\n    public:\n        const component::CurveType curveType;\n        const component::G1 compressed;\n\n        BLS_Decompress_G2(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            compressed(ds)\n        { }\n        BLS_Decompress_G2(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            compressed(json[\"g1_x\"], json[\"g1_y\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const BLS_Decompress_G2& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (compressed == rhs.compressed) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            compressed.Serialize(ds);\n        }\n};\n\n"}
{"text_input": "Generate BLS_Compress_G2 code for operations.h", "output": "class BLS_Compress_G2 : public Operation {\n    public:\n        const component::CurveType curveType;\n        const component::G2 uncompressed;\n\n        BLS_Compress_G2(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            uncompressed(ds)\n        { }\n        BLS_Compress_G2(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            uncompressed(json[\"g2_v\"], json[\"g2_w\"], json[\"g2_x\"], json[\"g2_y\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const BLS_Compress_G2& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (uncompressed == rhs.uncompressed) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            uncompressed.Serialize(ds);\n        }\n};\n\n"}
{"text_input": "Generate BLS_G1_Add code for operations.h", "output": "class BLS_G1_Add : public Operation {\n    public:\n        const component::CurveType curveType;\n        const component::G1 a, b;\n\n        BLS_G1_Add(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            a(ds),\n            b(ds)\n        { }\n        BLS_G1_Add(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            a(json[\"a_x\"], json[\"a_y\"]),\n            b(json[\"b_x\"], json[\"b_y\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const BLS_G1_Add& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (a == rhs.a) &&\n                (b == rhs.b) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            a.Serialize(ds);\n            b.Serialize(ds);\n        }\n};\n\n"}
{"text_input": "Generate BLS_G1_IsEq code for operations.h", "output": "class BLS_G1_IsEq : public Operation {\n    public:\n        const component::CurveType curveType;\n        const component::G1 a, b;\n\n        BLS_G1_IsEq(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            a(ds),\n            b(ds)\n        { }\n        BLS_G1_IsEq(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            a(json[\"a_x\"], json[\"a_y\"]),\n            b(json[\"b_x\"], json[\"b_y\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const BLS_G1_IsEq& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (a == rhs.a) &&\n                (b == rhs.b) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            a.Serialize(ds);\n            b.Serialize(ds);\n        }\n};\n\n"}
{"text_input": "Generate BLS_G1_Mul code for operations.h", "output": "class BLS_G1_Mul : public Operation {\n    public:\n        const component::CurveType curveType;\n        const component::G1 a;\n        const component::Bignum b;\n\n        BLS_G1_Mul(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            a(ds),\n            b(ds)\n        { }\n        BLS_G1_Mul(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            a(json[\"a_x\"], json[\"a_y\"]),\n            b(json[\"b\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const BLS_G1_Mul& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (a == rhs.a) &&\n                (b == rhs.b) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            a.Serialize(ds);\n            b.Serialize(ds);\n        }\n};\n\n"}
{"text_input": "Generate BLS_G1_Neg code for operations.h", "output": "class BLS_G1_Neg : public Operation {\n    public:\n        const component::CurveType curveType;\n        const component::G1 a;\n\n        BLS_G1_Neg(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            a(ds)\n        { }\n        BLS_G1_Neg(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            a(json[\"a_x\"], json[\"a_y\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const BLS_G1_Neg& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (a == rhs.a) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            a.Serialize(ds);\n        }\n};\n\n"}
{"text_input": "Generate BLS_G2_Add code for operations.h", "output": "class BLS_G2_Add : public Operation {\n    public:\n        const component::CurveType curveType;\n        const component::G2 a, b;\n\n        BLS_G2_Add(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            a(ds),\n            b(ds)\n        { }\n        BLS_G2_Add(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            a(json[\"a_v\"], json[\"a_w\"], json[\"a_x\"], json[\"a_y\"]),\n            b(json[\"b_v\"], json[\"b_w\"], json[\"b_x\"], json[\"b_y\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const BLS_G2_Add& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (a == rhs.a) &&\n                (b == rhs.b) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            a.Serialize(ds);\n            b.Serialize(ds);\n        }\n};\n\n"}
{"text_input": "Generate BLS_G2_IsEq code for operations.h", "output": "class BLS_G2_IsEq : public Operation {\n    public:\n        const component::CurveType curveType;\n        const component::G2 a, b;\n\n        BLS_G2_IsEq(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            a(ds),\n            b(ds)\n        { }\n        BLS_G2_IsEq(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            a(json[\"a_v\"], json[\"a_w\"], json[\"a_x\"], json[\"a_y\"]),\n            b(json[\"b_v\"], json[\"b_w\"], json[\"b_x\"], json[\"b_y\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const BLS_G2_IsEq& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (a == rhs.a) &&\n                (b == rhs.b) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            a.Serialize(ds);\n            b.Serialize(ds);\n        }\n};\n\n"}
{"text_input": "Generate BLS_G2_Mul code for operations.h", "output": "class BLS_G2_Mul : public Operation {\n    public:\n        const component::CurveType curveType;\n        const component::G2 a;\n        const component::Bignum b;\n\n        BLS_G2_Mul(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            a(ds),\n            b(ds)\n        { }\n        BLS_G2_Mul(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            a(json[\"a_v\"], json[\"a_w\"], json[\"a_x\"], json[\"a_y\"]),\n            b(json[\"b\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const BLS_G2_Mul& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (a == rhs.a) &&\n                (b == rhs.b) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            a.Serialize(ds);\n            b.Serialize(ds);\n        }\n};\n\n"}
{"text_input": "Generate BLS_G2_Neg code for operations.h", "output": "class BLS_G2_Neg : public Operation {\n    public:\n        const component::CurveType curveType;\n        const component::G2 a;\n\n        BLS_G2_Neg(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            a(ds)\n        { }\n        BLS_G2_Neg(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            a(json[\"a_v\"], json[\"a_w\"], json[\"a_x\"], json[\"a_y\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const BLS_G2_Neg& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (a == rhs.a) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            a.Serialize(ds);\n        }\n};\n\n"}
{"text_input": "Generate BLS_G1_MultiExp code for operations.h", "output": "class BLS_G1_MultiExp : public Operation {\n    public:\n        const component::CurveType curveType;\n        component::BLS_G1_Scalar_Vector points_scalars;\n\n        BLS_G1_MultiExp(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            points_scalars(ds)\n        { }\n        BLS_G1_MultiExp(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            points_scalars(json[\"points_scalars\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const BLS_G1_MultiExp& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (points_scalars == rhs.points_scalars) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            points_scalars.Serialize(ds);\n        }\n};\n\n"}
{"text_input": "Generate Misc code for operations.h", "output": "class Misc : public Operation {\n    public:\n        const Type operation;\n\n        Misc(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            operation(ds)\n        { }\n\n        Misc(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            operation(json[\"operation\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const Misc& rhs) const {\n            return\n                (operation == rhs.operation) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            operation.Serialize(ds);\n        }\n};\n\n"}
{"text_input": "Generate SR25519_Verify code for operations.h", "output": "class SR25519_Verify : public Operation {\n    public:\n        const component::Cleartext cleartext;\n        const component::SR25519_Signature signature;\n\n        SR25519_Verify(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            cleartext(ds),\n            signature(ds)\n        { }\n        SR25519_Verify(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            cleartext(json[\"cleartext\"]),\n            signature(json[\"signature\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const SR25519_Verify& rhs) const {\n            return\n                (cleartext == rhs.cleartext) &&\n                (signature == rhs.signature) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            cleartext.Serialize(ds);\n            signature.Serialize(ds);\n        }\n};\n"}
{"text_input": "Generate Digest code for module.h", "output": "        virtual std::optional<component::Digest> OpDigest(operation::Digest& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate HMAC code for module.h", "output": "        virtual std::optional<component::MAC> OpHMAC(operation::HMAC& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate UMAC code for module.h", "output": "        virtual std::optional<component::MAC> OpUMAC(operation::UMAC& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate SymmetricEncrypt code for module.h", "output": "        virtual std::optional<component::Ciphertext> OpSymmetricEncrypt(operation::SymmetricEncrypt& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate SymmetricDecrypt code for module.h", "output": "        virtual std::optional<component::Cleartext> OpSymmetricDecrypt(operation::SymmetricDecrypt& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate KDF_SCRYPT code for module.h", "output": "        virtual std::optional<component::Key> OpKDF_SCRYPT(operation::KDF_SCRYPT& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate KDF_HKDF code for module.h", "output": "        virtual std::optional<component::Key> OpKDF_HKDF(operation::KDF_HKDF& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate KDF_TLS1_PRF code for module.h", "output": "        virtual std::optional<component::Key> OpKDF_TLS1_PRF(operation::KDF_TLS1_PRF& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate KDF_PBKDF code for module.h", "output": "        virtual std::optional<component::Key> OpKDF_PBKDF(operation::KDF_PBKDF& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate KDF_PBKDF1 code for module.h", "output": "        virtual std::optional<component::Key> OpKDF_PBKDF1(operation::KDF_PBKDF1& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate KDF_PBKDF2 code for module.h", "output": "        virtual std::optional<component::Key> OpKDF_PBKDF2(operation::KDF_PBKDF2& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate KDF_ARGON2 code for module.h", "output": "        virtual std::optional<component::Key> OpKDF_ARGON2(operation::KDF_ARGON2& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate KDF_SSH code for module.h", "output": "        virtual std::optional<component::Key> OpKDF_SSH(operation::KDF_SSH& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate KDF_X963 code for module.h", "output": "        virtual std::optional<component::Key> OpKDF_X963(operation::KDF_X963& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate KDF_BCRYPT code for module.h", "output": "        virtual std::optional<component::Key> OpKDF_BCRYPT(operation::KDF_BCRYPT& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate KDF_SP_800_108 code for module.h", "output": "        virtual std::optional<component::Key> OpKDF_SP_800_108(operation::KDF_SP_800_108& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate KDF_SRTP code for module.h", "output": "        virtual std::optional<component::Key3> OpKDF_SRTP(operation::KDF_SRTP& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate KDF_SRTCP code for module.h", "output": "        virtual std::optional<component::Key3> OpKDF_SRTCP(operation::KDF_SRTCP& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate CMAC code for module.h", "output": "        virtual std::optional<component::MAC> OpCMAC(operation::CMAC& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate ECC_PrivateToPublic code for module.h", "output": "        virtual std::optional<component::ECC_PublicKey> OpECC_PrivateToPublic(operation::ECC_PrivateToPublic& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate ECC_ValidatePubkey code for module.h", "output": "        virtual std::optional<bool> OpECC_ValidatePubkey(operation::ECC_ValidatePubkey& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate ECC_GenerateKeyPair code for module.h", "output": "        virtual std::optional<component::ECC_KeyPair> OpECC_GenerateKeyPair(operation::ECC_GenerateKeyPair& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate ECCSI_Sign code for module.h", "output": "        virtual std::optional<component::ECCSI_Signature> OpECCSI_Sign(operation::ECCSI_Sign& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate ECDSA_Sign code for module.h", "output": "        virtual std::optional<component::ECDSA_Signature> OpECDSA_Sign(operation::ECDSA_Sign& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate ECGDSA_Sign code for module.h", "output": "        virtual std::optional<component::ECGDSA_Signature> OpECGDSA_Sign(operation::ECGDSA_Sign& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate ECRDSA_Sign code for module.h", "output": "        virtual std::optional<component::ECRDSA_Signature> OpECRDSA_Sign(operation::ECRDSA_Sign& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate Schnorr_Sign code for module.h", "output": "        virtual std::optional<component::Schnorr_Signature> OpSchnorr_Sign(operation::Schnorr_Sign& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate ECCSI_Verify code for module.h", "output": "        virtual std::optional<bool> OpECCSI_Verify(operation::ECCSI_Verify& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate ECDSA_Verify code for module.h", "output": "        virtual std::optional<bool> OpECDSA_Verify(operation::ECDSA_Verify& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate ECGDSA_Verify code for module.h", "output": "        virtual std::optional<bool> OpECGDSA_Verify(operation::ECGDSA_Verify& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate ECRDSA_Verify code for module.h", "output": "        virtual std::optional<bool> OpECRDSA_Verify(operation::ECRDSA_Verify& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate Schnorr_Verify code for module.h", "output": "        virtual std::optional<bool> OpSchnorr_Verify(operation::Schnorr_Verify& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate ECDSA_Recover code for module.h", "output": "        virtual std::optional<component::ECC_PublicKey> OpECDSA_Recover(operation::ECDSA_Recover& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate DSA_Verify code for module.h", "output": "        virtual std::optional<bool> OpDSA_Verify(operation::DSA_Verify& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate DSA_Sign code for module.h", "output": "        virtual std::optional<component::DSA_Signature> OpDSA_Sign(operation::DSA_Sign& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate DSA_GenerateParameters code for module.h", "output": "        virtual std::optional<component::DSA_Parameters> OpDSA_GenerateParameters(operation::DSA_GenerateParameters& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate DSA_PrivateToPublic code for module.h", "output": "        virtual std::optional<component::Bignum> OpDSA_PrivateToPublic(operation::DSA_PrivateToPublic& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate DSA_GenerateKeyPair code for module.h", "output": "        virtual std::optional<component::DSA_KeyPair> OpDSA_GenerateKeyPair(operation::DSA_GenerateKeyPair& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate ECDH_Derive code for module.h", "output": "        virtual std::optional<component::Secret> OpECDH_Derive(operation::ECDH_Derive& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate ECIES_Encrypt code for module.h", "output": "        virtual std::optional<component::Ciphertext> OpECIES_Encrypt(operation::ECIES_Encrypt& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate ECIES_Decrypt code for module.h", "output": "        virtual std::optional<component::Cleartext> OpECIES_Decrypt(operation::ECIES_Decrypt& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate ECC_Point_Add code for module.h", "output": "        virtual std::optional<component::ECC_Point> OpECC_Point_Add(operation::ECC_Point_Add& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate ECC_Point_Sub code for module.h", "output": "        virtual std::optional<component::ECC_Point> OpECC_Point_Sub(operation::ECC_Point_Sub& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate ECC_Point_Mul code for module.h", "output": "        virtual std::optional<component::ECC_Point> OpECC_Point_Mul(operation::ECC_Point_Mul& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate ECC_Point_Neg code for module.h", "output": "        virtual std::optional<component::ECC_Point> OpECC_Point_Neg(operation::ECC_Point_Neg& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate ECC_Point_Dbl code for module.h", "output": "        virtual std::optional<component::ECC_Point> OpECC_Point_Dbl(operation::ECC_Point_Dbl& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate ECC_Point_Cmp code for module.h", "output": "        virtual std::optional<bool> OpECC_Point_Cmp(operation::ECC_Point_Cmp& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate DH_GenerateKeyPair code for module.h", "output": "        virtual std::optional<component::DH_KeyPair> OpDH_GenerateKeyPair(operation::DH_GenerateKeyPair& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate DH_Derive code for module.h", "output": "        virtual std::optional<component::Bignum> OpDH_Derive(operation::DH_Derive& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate BignumCalc code for module.h", "output": "        virtual std::optional<component::Bignum> OpBignumCalc(operation::BignumCalc& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate BignumCalc_Fp2 code for module.h", "output": "        virtual std::optional<component::Fp2> OpBignumCalc_Fp2(operation::BignumCalc_Fp2& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate BignumCalc_Fp12 code for module.h", "output": "        virtual std::optional<component::Fp12> OpBignumCalc_Fp12(operation::BignumCalc_Fp12& op) {\n            (void)op;\n            return std::nullopt;\n        }\n        virtual bool SupportsModularBignumCalc(void) const {\n            return false;\n        }\n"}
{"text_input": "Generate BLS_PrivateToPublic code for module.h", "output": "        virtual std::optional<component::BLS_PublicKey> OpBLS_PrivateToPublic(operation::BLS_PrivateToPublic& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate BLS_PrivateToPublic_G2 code for module.h", "output": "        virtual std::optional<component::G2> OpBLS_PrivateToPublic_G2(operation::BLS_PrivateToPublic_G2& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate BLS_Sign code for module.h", "output": "        virtual std::optional<component::BLS_Signature> OpBLS_Sign(operation::BLS_Sign& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate BLS_Verify code for module.h", "output": "        virtual std::optional<bool> OpBLS_Verify(operation::BLS_Verify& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate BLS_BatchSign code for module.h", "output": "        virtual std::optional<component::BLS_BatchSignature> OpBLS_BatchSign(operation::BLS_BatchSign& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate BLS_BatchVerify code for module.h", "output": "        virtual std::optional<bool> OpBLS_BatchVerify(operation::BLS_BatchVerify& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate BLS_Aggregate_G1 code for module.h", "output": "        virtual std::optional<component::G1> OpBLS_Aggregate_G1(operation::BLS_Aggregate_G1& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate BLS_Aggregate_G2 code for module.h", "output": "        virtual std::optional<component::G2> OpBLS_Aggregate_G2(operation::BLS_Aggregate_G2& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate BLS_Pairing code for module.h", "output": "        virtual std::optional<component::Fp12> OpBLS_Pairing(operation::BLS_Pairing& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate BLS_MillerLoop code for module.h", "output": "        virtual std::optional<component::Fp12> OpBLS_MillerLoop(operation::BLS_MillerLoop& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate BLS_FinalExp code for module.h", "output": "        virtual std::optional<component::Fp12> OpBLS_FinalExp(operation::BLS_FinalExp& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate BLS_HashToG1 code for module.h", "output": "        virtual std::optional<component::G1> OpBLS_HashToG1(operation::BLS_HashToG1& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate BLS_HashToG2 code for module.h", "output": "        virtual std::optional<component::G2> OpBLS_HashToG2(operation::BLS_HashToG2& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate BLS_MapToG1 code for module.h", "output": "        virtual std::optional<component::G1> OpBLS_MapToG1(operation::BLS_MapToG1& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate BLS_MapToG2 code for module.h", "output": "        virtual std::optional<component::G2> OpBLS_MapToG2(operation::BLS_MapToG2& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate BLS_IsG1OnCurve code for module.h", "output": "        virtual std::optional<bool> OpBLS_IsG1OnCurve(operation::BLS_IsG1OnCurve& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate BLS_IsG2OnCurve code for module.h", "output": "        virtual std::optional<bool> OpBLS_IsG2OnCurve(operation::BLS_IsG2OnCurve& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate BLS_GenerateKeyPair code for module.h", "output": "        virtual std::optional<component::BLS_KeyPair> OpBLS_GenerateKeyPair(operation::BLS_GenerateKeyPair& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate BLS_Decompress_G1 code for module.h", "output": "        virtual std::optional<component::G1> OpBLS_Decompress_G1(operation::BLS_Decompress_G1& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate BLS_Compress_G1 code for module.h", "output": "        virtual std::optional<component::Bignum> OpBLS_Compress_G1(operation::BLS_Compress_G1& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate BLS_Decompress_G2 code for module.h", "output": "        virtual std::optional<component::G2> OpBLS_Decompress_G2(operation::BLS_Decompress_G2& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate BLS_Compress_G2 code for module.h", "output": "        virtual std::optional<component::G1> OpBLS_Compress_G2(operation::BLS_Compress_G2& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate BLS_G1_Add code for module.h", "output": "        virtual std::optional<component::G1> OpBLS_G1_Add(operation::BLS_G1_Add& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate BLS_G1_Mul code for module.h", "output": "        virtual std::optional<component::G1> OpBLS_G1_Mul(operation::BLS_G1_Mul& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate BLS_G1_IsEq code for module.h", "output": "        virtual std::optional<bool> OpBLS_G1_IsEq(operation::BLS_G1_IsEq& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate BLS_G1_Neg code for module.h", "output": "        virtual std::optional<component::G1> OpBLS_G1_Neg(operation::BLS_G1_Neg& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate BLS_G2_Add code for module.h", "output": "        virtual std::optional<component::G2> OpBLS_G2_Add(operation::BLS_G2_Add& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate BLS_G2_Mul code for module.h", "output": "        virtual std::optional<component::G2> OpBLS_G2_Mul(operation::BLS_G2_Mul& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate BLS_G2_IsEq code for module.h", "output": "        virtual std::optional<bool> OpBLS_G2_IsEq(operation::BLS_G2_IsEq& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate BLS_G2_Neg code for module.h", "output": "        virtual std::optional<component::G2> OpBLS_G2_Neg(operation::BLS_G2_Neg& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate BLS_G1_MultiExp code for module.h", "output": "        virtual std::optional<component::G1> OpBLS_G1_MultiExp(operation::BLS_G1_MultiExp& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate Misc code for module.h", "output": "        virtual std::optional<Buffer> OpMisc(operation::Misc& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate SR25519_Verify code for module.h", "output": "        virtual std::optional<bool> OpSR25519_Verify(operation::SR25519_Verify& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}
{"text_input": "Generate Digest code for operation.cpp", "output": "std::string Digest::Name(void) const { return \"Digest\"; }std::string Digest::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: Digest\" << std::endl;\n    ss << \"digest: \" << repository::DigestToString(digestType.Get()) << std::endl;\n    ss << \"cleartext: \" << util::HexDump(cleartext.Get()) << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json Digest::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"Digest\";\n    j[\"cleartext\"] = cleartext.ToJSON();\n    j[\"digestType\"] = digestType.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}
{"text_input": "Generate HMAC code for operation.cpp", "output": "std::string HMAC::Name(void) const { return \"HMAC\"; }std::string HMAC::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: HMAC\" << std::endl;\n    ss << \"digest: \" << repository::DigestToString(digestType.Get()) << std::endl;\n    ss << \"key: \" << util::HexDump(cipher.key.Get()) << std::endl;\n    ss << \"cleartext: \" << util::HexDump(cleartext.Get()) << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json HMAC::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"HMAC\";\n    j[\"cleartext\"] = cleartext.ToJSON();\n    j[\"digestType\"] = digestType.ToJSON();\n    j[\"cipher\"] = cipher.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}
{"text_input": "Generate UMAC code for operation.cpp", "output": "std::string UMAC::Name(void) const { return \"UMAC\"; }std::string UMAC::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: UMAC\" << std::endl;\n    ss << \"cleartext: \" << util::HexDump(cleartext.Get()) << std::endl;\n    ss << \"key: \" << util::HexDump(key.Get()) << std::endl;\n    ss << \"iv: \" << util::HexDump(iv.Get()) << std::endl;\n    ss << \"type: \" << std::to_string(type) << std::endl;\n    ss << \"outSize: \" << std::to_string(outSize) << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json UMAC::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"UMAC\";\n    j[\"cleartext\"] = cleartext.ToJSON();\n    j[\"key\"] = key.ToJSON();\n    j[\"iv\"] = iv.ToJSON();\n    j[\"type\"] = type;\n    j[\"outSize\"] = outSize;\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}
{"text_input": "Generate SymmetricEncrypt code for operation.cpp", "output": "std::string SymmetricEncrypt::Name(void) const { return \"SymmetricEncrypt\"; }std::string SymmetricEncrypt::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: SymmetricEncrypt\" << std::endl;\n    ss << \"cleartext: \" << util::HexDump(cleartext.Get()) << std::endl;\n    ss << \"aad: \" << (aad ? util::HexDump(aad->Get()) : \"nullopt\") << std::endl;\n    ss << \"cipher iv: \" << util::HexDump(cipher.iv.Get()) << std::endl;\n    ss << \"cipher key: \" << util::HexDump(cipher.key.Get()) << std::endl;\n    ss << \"cipher: \" << repository::CipherToString(cipher.cipherType.Get()) << std::endl;\n    ss << \"ciphertextSize: \" << std::to_string(ciphertextSize) << std::endl;\n    ss << \"tagSize: \" << (tagSize ? std::to_string(*tagSize) : \"nullopt\") << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json SymmetricEncrypt::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"SymmetricEncrypt\";\n    j[\"cleartext\"] = cleartext.ToJSON();\n    j[\"cipher\"] = cipher.ToJSON();\n    j[\"aad_enabled\"] = (bool)(aad != std::nullopt);\n    j[\"aad\"] = aad != std::nullopt ? aad->ToJSON() : \"\";\n    j[\"ciphertextSize\"] = ciphertextSize;\n    j[\"tagSize_enabled\"] = (bool)(tagSize != std::nullopt);\n    j[\"tagSize\"] = tagSize != std::nullopt ? *tagSize : 0;\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}
{"text_input": "Generate SymmetricDecrypt code for operation.cpp", "output": "std::string SymmetricDecrypt::Name(void) const { return \"SymmetricDecrypt\"; }std::string SymmetricDecrypt::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: SymmetricDecrypt\" << std::endl;\n    ss << \"ciphertext: \" << util::HexDump(ciphertext.Get()) << std::endl;\n    ss << \"tag: \" << (tag ? util::HexDump(tag->Get()) : \"nullopt\") << std::endl;\n    ss << \"aad: \" << (aad ? util::HexDump(aad->Get()) : \"nullopt\") << std::endl;\n    ss << \"cipher iv: \" << util::HexDump(cipher.iv.Get()) << std::endl;\n    ss << \"cipher key: \" << util::HexDump(cipher.key.Get()) << std::endl;\n    ss << \"cipher: \" << repository::CipherToString(cipher.cipherType.Get()) << std::endl;\n    ss << \"cleartextSize: \" << std::to_string(cleartextSize) << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json SymmetricDecrypt::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"SymmetricDecrypt\";\n    j[\"ciphertext\"] = ciphertext.ToJSON();\n    j[\"cipher\"] = cipher.ToJSON();\n    j[\"aad_enabled\"] = (bool)(aad != std::nullopt);\n    j[\"aad\"] = aad != std::nullopt ? aad->ToJSON() : \"\";\n    j[\"tag_enabled\"] = (bool)(tag != std::nullopt);\n    j[\"tag\"] = tag != std::nullopt ? tag->ToJSON() : \"\";\n    j[\"cleartextSize\"] = cleartextSize;\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n/* Construct SymmetricDecrypt from SymmetricEncrypt */\nSymmetricDecrypt::SymmetricDecrypt(const SymmetricEncrypt& opSymmetricEncrypt, const component::Ciphertext ciphertext, const uint64_t cleartextSize, std::optional<component::AAD> aad, component::Modifier modifier) :\n    Operation(std::move(modifier)),\n    ciphertext(ciphertext.ciphertext),\n    cipher(opSymmetricEncrypt.cipher),\n    tag(ciphertext.tag),\n    aad(aad),\n    cleartextSize(cleartextSize)\n{ }\n\n"}
{"text_input": "Generate KDF_SCRYPT code for operation.cpp", "output": "std::string KDF_SCRYPT::Name(void) const { return \"KDF_SCRYPT\"; }std::string KDF_SCRYPT::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: KDF_SCRYPT\" << std::endl;\n    ss << \"password: \" << util::HexDump(password.Get()) << std::endl;\n    ss << \"salt: \" << util::HexDump(salt.Get()) << std::endl;\n    ss << \"N: \" << std::to_string(N) << std::endl;\n    ss << \"r: \" << std::to_string(r) << std::endl;\n    ss << \"p: \" << std::to_string(p) << std::endl;\n    ss << \"keySize: \" << std::to_string(keySize) << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json KDF_SCRYPT::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"KDF_SCRYPT\";\n    j[\"password\"] = password.ToJSON();\n    j[\"salt\"] = salt.ToJSON();\n    j[\"N\"] = N;\n    j[\"r\"] = r;\n    j[\"p\"] = p;\n    j[\"keySize\"] = keySize;\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}
{"text_input": "Generate KDF_HKDF code for operation.cpp", "output": "std::string KDF_HKDF::Name(void) const { return \"KDF_HKDF\"; }std::string KDF_HKDF::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: KDF_HKDF\" << std::endl;\n    ss << \"digest: \" << repository::DigestToString(digestType.Get()) << std::endl;\n    ss << \"password: \" << util::HexDump(password.Get()) << std::endl;\n    ss << \"salt: \" << util::HexDump(salt.Get()) << std::endl;\n    ss << \"info: \" << util::HexDump(info.Get()) << std::endl;\n    ss << \"keySize: \" << std::to_string(keySize) << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json KDF_HKDF::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"KDF_HKDF\";\n    j[\"digestType\"] = digestType.ToJSON();\n    j[\"password\"] = password.ToJSON();\n    j[\"salt\"] = salt.ToJSON();\n    j[\"info\"] = info.ToJSON();\n    j[\"keySize\"] = keySize;\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}
{"text_input": "Generate KDF_TLS1_PRF code for operation.cpp", "output": "std::string KDF_TLS1_PRF::Name(void) const { return \"KDF_TLS1_PRF\"; }std::string KDF_TLS1_PRF::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: KDF_TLS1_PRF\" << std::endl;\n    ss << \"digest: \" << repository::DigestToString(digestType.Get()) << std::endl;\n    ss << \"secret: \" << util::HexDump(secret.Get()) << std::endl;\n    ss << \"seed: \" << util::HexDump(seed.Get()) << std::endl;\n    ss << \"keySize: \" << std::to_string(keySize) << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json KDF_TLS1_PRF::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"KDF_TLS1_PRF\";\n    j[\"digestType\"] = digestType.ToJSON();\n    j[\"secret\"] = secret.ToJSON();\n    j[\"seed\"] = seed.ToJSON();\n    j[\"keySize\"] = keySize;\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}
{"text_input": "Generate KDF_PBKDF code for operation.cpp", "output": "std::string KDF_PBKDF::Name(void) const { return \"KDF_PBKDF\"; }std::string KDF_PBKDF::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: KDF_PBKDF\" << std::endl;\n    ss << \"digest: \" << repository::DigestToString(digestType.Get()) << std::endl;\n    ss << \"password: \" << util::HexDump(password.Get()) << std::endl;\n    ss << \"salt: \" << util::HexDump(salt.Get()) << std::endl;\n    ss << \"iterations: \" << std::to_string(iterations) << std::endl;\n    ss << \"keySize: \" << std::to_string(keySize) << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json KDF_PBKDF::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"KDF_PBKDF\";\n    j[\"digestType\"] = digestType.ToJSON();\n    j[\"password\"] = password.ToJSON();\n    j[\"salt\"] = salt.ToJSON();\n    j[\"iterations\"] = iterations;\n    j[\"keySize\"] = keySize;\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}
{"text_input": "Generate KDF_PBKDF1 code for operation.cpp", "output": "std::string KDF_PBKDF1::Name(void) const { return \"KDF_PBKDF1\"; }std::string KDF_PBKDF1::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: KDF_PBKDF1\" << std::endl;\n    ss << \"digest: \" << repository::DigestToString(digestType.Get()) << std::endl;\n    ss << \"password: \" << util::HexDump(password.Get()) << std::endl;\n    ss << \"salt: \" << util::HexDump(salt.Get()) << std::endl;\n    ss << \"iterations: \" << std::to_string(iterations) << std::endl;\n    ss << \"keySize: \" << std::to_string(keySize) << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json KDF_PBKDF1::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"KDF_PBKDF1\";\n    j[\"digestType\"] = digestType.ToJSON();\n    j[\"password\"] = password.ToJSON();\n    j[\"salt\"] = salt.ToJSON();\n    j[\"iterations\"] = iterations;\n    j[\"keySize\"] = keySize;\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}
{"text_input": "Generate KDF_PBKDF2 code for operation.cpp", "output": "std::string KDF_PBKDF2::Name(void) const { return \"KDF_PBKDF2\"; }std::string KDF_PBKDF2::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: KDF_PBKDF2\" << std::endl;\n    ss << \"digest: \" << repository::DigestToString(digestType.Get()) << std::endl;\n    ss << \"password: \" << util::HexDump(password.Get()) << std::endl;\n    ss << \"salt: \" << util::HexDump(salt.Get()) << std::endl;\n    ss << \"iterations: \" << std::to_string(iterations) << std::endl;\n    ss << \"keySize: \" << std::to_string(keySize) << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json KDF_PBKDF2::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"KDF_PBKDF2\";\n    j[\"digestType\"] = digestType.ToJSON();\n    j[\"password\"] = password.ToJSON();\n    j[\"salt\"] = salt.ToJSON();\n    j[\"iterations\"] = iterations;\n    j[\"keySize\"] = keySize;\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}
{"text_input": "Generate KDF_ARGON2 code for operation.cpp", "output": "std::string KDF_ARGON2::Name(void) const { return \"KDF_ARGON2\"; }std::string KDF_ARGON2::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: KDF_ARGON2\" << std::endl;\n    ss << \"password: \" << util::HexDump(password.Get()) << std::endl;\n    ss << \"salt: \" << util::HexDump(salt.Get()) << std::endl;\n    ss << \"type: \" << std::to_string(type) << std::endl;\n    ss << \"threads: \" << std::to_string(threads) << std::endl;\n    ss << \"memory: \" << std::to_string(memory) << std::endl;\n    ss << \"iterations: \" << std::to_string(iterations) << std::endl;\n    ss << \"keySize: \" << std::to_string(keySize) << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json KDF_ARGON2::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"KDF_ARGON2\";\n    j[\"password\"] = password.ToJSON();\n    j[\"salt\"] = salt.ToJSON();\n    j[\"type\"] = type;\n    j[\"threads\"] = threads;\n    j[\"memory\"] = memory;\n    j[\"iterations\"] = iterations;\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}
{"text_input": "Generate KDF_SSH code for operation.cpp", "output": "std::string KDF_SSH::Name(void) const { return \"KDF_SSH\"; }std::string KDF_SSH::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: KDF_SSH\" << std::endl;\n    ss << \"digest: \" << repository::DigestToString(digestType.Get()) << std::endl;\n    ss << \"key: \" << util::HexDump(key.Get()) << std::endl;\n    ss << \"xcghash: \" << util::HexDump(xcghash.Get()) << std::endl;\n    ss << \"session_id: \" << util::HexDump(session_id.Get()) << std::endl;\n    ss << \"type: \" << util::HexDump(type.Get()) << std::endl;\n    ss << \"keySize: \" << std::to_string(keySize) << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json KDF_SSH::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"KDF_SSH\";\n    j[\"digestType\"] = digestType.ToJSON();\n    j[\"key\"] = key.ToJSON();\n    j[\"xcghash\"] = xcghash.ToJSON();\n    j[\"session_id\"] = session_id.ToJSON();\n    j[\"type\"] = type.ToJSON();\n    j[\"keySize\"] = keySize;\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}
{"text_input": "Generate KDF_X963 code for operation.cpp", "output": "std::string KDF_X963::Name(void) const { return \"KDF_X963\"; }std::string KDF_X963::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: KDF_X963\" << std::endl;\n    ss << \"digest: \" << repository::DigestToString(digestType.Get()) << std::endl;\n    ss << \"secret: \" << util::HexDump(secret.Get()) << std::endl;\n    ss << \"info: \" << util::HexDump(info.Get()) << std::endl;\n    ss << \"keySize: \" << std::to_string(keySize) << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json KDF_X963::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"KDF_X963\";\n    j[\"digestType\"] = digestType.ToJSON();\n    j[\"secret\"] = secret.ToJSON();\n    j[\"info\"] = info.ToJSON();\n    j[\"keySize\"] = keySize;\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}
{"text_input": "Generate KDF_BCRYPT code for operation.cpp", "output": "std::string KDF_BCRYPT::Name(void) const { return \"KDF_BCRYPT\"; }std::string KDF_BCRYPT::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: KDF_BCRYPT\" << std::endl;\n    ss << \"digest: \" << repository::DigestToString(digestType.Get()) << std::endl;\n    ss << \"secret: \" << util::HexDump(secret.Get()) << std::endl;\n    ss << \"salt: \" << util::HexDump(salt.Get()) << std::endl;\n    ss << \"iterations: \" << std::to_string(iterations) << std::endl;\n    ss << \"keySize: \" << std::to_string(keySize) << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json KDF_BCRYPT::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"KDF_BCRYPT\";\n    j[\"digestType\"] = digestType.ToJSON();\n    j[\"secret\"] = secret.ToJSON();\n    j[\"salt\"] = salt.ToJSON();\n    j[\"iterations\"] = iterations;\n    j[\"keySize\"] = keySize;\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}
{"text_input": "Generate KDF_SP_800_108 code for operation.cpp", "output": "std::string KDF_SP_800_108::Name(void) const { return \"KDF_SP_800_108\"; }std::string KDF_SP_800_108::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: KDF_SP_800_108\" << std::endl;\n    ss << \"hmac/cmac: \" << (mech.mode ? \"HMAC\" : \"CMAC\") << std::endl;\n    if ( mech.mode == true ) {\n        ss << \"digest: \" << repository::DigestToString(mech.type.Get()) << std::endl;\n    } else {\n        ss << \"cipher: \" << repository::CipherToString(mech.type.Get()) << std::endl;\n    }\n    ss << \"secret: \" << util::HexDump(secret.Get()) << std::endl;\n    ss << \"salt: \" << util::HexDump(salt.Get()) << std::endl;\n    ss << \"label: \" << util::HexDump(label.Get()) << std::endl;\n    ss << \"mode: \" << std::to_string(mode) << std::endl;\n    ss << \"keySize: \" << std::to_string(keySize) << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json KDF_SP_800_108::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"KDF_SP_800_108\";\n    j[\"mech\"] = mech.ToJSON();\n    j[\"secret\"] = secret.ToJSON();\n    j[\"salt\"] = salt.ToJSON();\n    j[\"label\"] = label.ToJSON();\n    j[\"mode\"] = mode;\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}
{"text_input": "Generate KDF_SRTP code for operation.cpp", "output": "std::string KDF_SRTP::Name(void) const { return \"KDF_SRTP\"; }std::string KDF_SRTP::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: KDF_SRTP\" << std::endl;\n    ss << \"key: \" << util::HexDump(key.Get()) << std::endl;\n    ss << \"salt: \" << util::HexDump(salt.Get()) << std::endl;\n    ss << \"kdr: \" << std::to_string(kdr) << std::endl;\n    ss << \"index: \" << std::to_string(index) << std::endl;\n    ss << \"key1Size: \" << std::to_string(key1Size) << std::endl;\n    ss << \"key2Size: \" << std::to_string(key2Size) << std::endl;\n    ss << \"key3Size: \" << std::to_string(key3Size) << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json KDF_SRTP::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"KDF_SRTP\";\n    j[\"key\"] = key.ToJSON();\n    j[\"salt\"] = salt.ToJSON();\n    j[\"kdr\"] = kdr;\n    j[\"index\"] = index;\n    j[\"key1Size\"] = key1Size;\n    j[\"key2Size\"] = key2Size;\n    j[\"key3Size\"] = key3Size;\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}
{"text_input": "Generate KDF_SRTCP code for operation.cpp", "output": "std::string KDF_SRTCP::Name(void) const { return \"KDF_SRTCP\"; }std::string KDF_SRTCP::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: KDF_SRTCP\" << std::endl;\n    ss << \"key: \" << util::HexDump(key.Get()) << std::endl;\n    ss << \"salt: \" << util::HexDump(salt.Get()) << std::endl;\n    ss << \"kdr: \" << std::to_string(kdr) << std::endl;\n    ss << \"index: \" << std::to_string(index) << std::endl;\n    ss << \"key1Size: \" << std::to_string(key1Size) << std::endl;\n    ss << \"key2Size: \" << std::to_string(key2Size) << std::endl;\n    ss << \"key3Size: \" << std::to_string(key3Size) << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json KDF_SRTCP::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"KDF_SRTCP\";\n    j[\"key\"] = key.ToJSON();\n    j[\"salt\"] = salt.ToJSON();\n    j[\"kdr\"] = kdr;\n    j[\"index\"] = index;\n    j[\"key1Size\"] = key1Size;\n    j[\"key2Size\"] = key2Size;\n    j[\"key3Size\"] = key3Size;\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}
{"text_input": "Generate CMAC code for operation.cpp", "output": "std::string CMAC::Name(void) const { return \"CMAC\"; }std::string CMAC::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: CMAC\" << std::endl;\n    ss << \"cipher iv: \" << util::HexDump(cipher.iv.Get()) << std::endl;\n    ss << \"cipher key: \" << util::HexDump(cipher.key.Get()) << std::endl;\n    ss << \"cipher: \" << repository::CipherToString(cipher.cipherType.Get()) << std::endl;\n    ss << \"cleartext: \" << util::HexDump(cleartext.Get()) << std::endl;\n    ss << \"key: \" << util::HexDump(cipher.key.Get()) << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json CMAC::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"CMAC\";\n    j[\"cleartext\"] = cleartext.ToJSON();\n    j[\"cipher\"] = cipher.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}
{"text_input": "Generate ECC_PrivateToPublic code for operation.cpp", "output": "std::string ECC_PrivateToPublic::Name(void) const { return \"ECC_PrivateToPublic\"; }std::string ECC_PrivateToPublic::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: ECC_PrivateToPublic\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"private key: \" << priv.ToString() << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json ECC_PrivateToPublic::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"ECC_PrivateToPublic\";\n    j[\"priv\"] = priv.ToJSON();\n    j[\"curveType\"] = curveType.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}
{"text_input": "Generate ECC_ValidatePubkey code for operation.cpp", "output": "std::string ECC_ValidatePubkey::Name(void) const { return \"ECC_ValidatePubkey\"; }std::string ECC_ValidatePubkey::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: ECC_ValidatePubkey\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"public key X: \" << pub.first.ToString() << std::endl;\n    ss << \"public key Y: \" << pub.second.ToString() << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json ECC_ValidatePubkey::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"ECC_ValidatePubkey\";\n    j[\"pub_x\"] = pub.first.ToJSON();\n    j[\"pub_y\"] = pub.second.ToJSON();\n    j[\"curveType\"] = curveType.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\nECC_ValidatePubkey::ECC_ValidatePubkey(\n        const component::CurveType curveType,\n        const component::ECC_PublicKey& pub,\n        component::Modifier& modifier) :\n    Operation(std::move(modifier)),\n    curveType(curveType),\n    pub(pub)\n{ }\n\n"}
{"text_input": "Generate ECC_GenerateKeyPair code for operation.cpp", "output": "std::string ECC_GenerateKeyPair::Name(void) const { return \"ECC_GenerateKeyPair\"; }std::string ECC_GenerateKeyPair::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: ECC_GenerateKeyPair\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json ECC_GenerateKeyPair::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"ECC_GenerateKeyPair\";\n    j[\"curveType\"] = curveType.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}
{"text_input": "Generate ECCSI_Sign code for operation.cpp", "output": "std::string ECCSI_Sign::Name(void) const { return \"ECCSI_Sign\"; }std::string ECCSI_Sign::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: ECCSI_Sign\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"private key: \" << priv.ToString() << std::endl;\n    ss << \"cleartext: \" << util::HexDump(cleartext.Get()) << std::endl;\n    ss << \"id: \" << util::HexDump(id.Get()) << std::endl;\n\n    ss << \"digest: \" << repository::DigestToString(digestType.Get()) << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json ECCSI_Sign::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"ECCSI_Sign\";\n    j[\"priv\"] = priv.ToJSON();\n    j[\"curveType\"] = curveType.ToJSON();\n    j[\"cleartext\"] = cleartext.ToJSON();\n    j[\"id\"] = id.ToJSON();\n    j[\"digestType\"] = digestType.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}
{"text_input": "Generate ECDSA_Sign code for operation.cpp", "output": "std::string ECDSA_Sign::Name(void) const { return \"ECDSA_Sign\"; }std::string ECDSA_Sign::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: ECDSA_Sign\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"nonce: \" << nonce.ToString() << std::endl;\n    ss << \"private key: \" << priv.ToString() << std::endl;\n    ss << \"cleartext: \" << util::HexDump(cleartext.Get()) << std::endl;\n    ss << \"nonce source: \";\n    if ( UseRandomNonce() ) {\n        ss << \"random\";\n    } else if ( UseRFC6979Nonce() ) {\n        ss << \"RFC 6979\";\n    } else if ( UseSpecifiedNonce() ) {\n        ss << \"specified\";\n    } else {\n        ss << \"(unknown)\";\n    }\n    ss << std::endl;\n\n    ss << \"digest: \" << repository::DigestToString(digestType.Get()) << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json ECDSA_Sign::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"ECDSA_Sign\";\n    j[\"priv\"] = priv.ToJSON();\n    j[\"nonce\"] = priv.ToJSON();\n    j[\"curveType\"] = curveType.ToJSON();\n    j[\"cleartext\"] = cleartext.ToJSON();\n    j[\"nonceSource\"] = nonceSource;\n    j[\"digestType\"] = digestType.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}
{"text_input": "Generate ECGDSA_Sign code for operation.cpp", "output": "std::string ECGDSA_Sign::Name(void) const { return \"ECGDSA_Sign\"; }std::string ECGDSA_Sign::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: ECGDSA_Sign\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"nonce: \" << nonce.ToString() << std::endl;\n    ss << \"private key: \" << priv.ToString() << std::endl;\n    ss << \"cleartext: \" << util::HexDump(cleartext.Get()) << std::endl;\n    ss << \"nonce source: \";\n    if ( UseRandomNonce() ) {\n        ss << \"random\";\n    } else if ( UseRFC6979Nonce() ) {\n        ss << \"RFC 6979\";\n    } else if ( UseSpecifiedNonce() ) {\n        ss << \"specified\";\n    } else {\n        ss << \"(unknown)\";\n    }\n    ss << std::endl;\n\n    ss << \"digest: \" << repository::DigestToString(digestType.Get()) << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json ECGDSA_Sign::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"ECGDSA_Sign\";\n    j[\"priv\"] = priv.ToJSON();\n    j[\"nonce\"] = priv.ToJSON();\n    j[\"curveType\"] = curveType.ToJSON();\n    j[\"cleartext\"] = cleartext.ToJSON();\n    j[\"nonceSource\"] = nonceSource;\n    j[\"digestType\"] = digestType.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}
{"text_input": "Generate ECRDSA_Sign code for operation.cpp", "output": "std::string ECRDSA_Sign::Name(void) const { return \"ECRDSA_Sign\"; }std::string ECRDSA_Sign::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: ECRDSA_Sign\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"nonce: \" << nonce.ToString() << std::endl;\n    ss << \"private key: \" << priv.ToString() << std::endl;\n    ss << \"cleartext: \" << util::HexDump(cleartext.Get()) << std::endl;\n    ss << \"nonce source: \";\n    if ( UseRandomNonce() ) {\n        ss << \"random\";\n    } else if ( UseRFC6979Nonce() ) {\n        ss << \"RFC 6979\";\n    } else if ( UseSpecifiedNonce() ) {\n        ss << \"specified\";\n    } else {\n        ss << \"(unknown)\";\n    }\n    ss << std::endl;\n\n    ss << \"digest: \" << repository::DigestToString(digestType.Get()) << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json ECRDSA_Sign::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"ECRDSA_Sign\";\n    j[\"priv\"] = priv.ToJSON();\n    j[\"nonce\"] = priv.ToJSON();\n    j[\"curveType\"] = curveType.ToJSON();\n    j[\"cleartext\"] = cleartext.ToJSON();\n    j[\"nonceSource\"] = nonceSource;\n    j[\"digestType\"] = digestType.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}
{"text_input": "Generate Schnorr_Sign code for operation.cpp", "output": "std::string Schnorr_Sign::Name(void) const { return \"Schnorr_Sign\"; }std::string Schnorr_Sign::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: Schnorr_Sign\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"nonce: \" << nonce.ToString() << std::endl;\n    ss << \"private key: \" << priv.ToString() << std::endl;\n    ss << \"cleartext: \" << util::HexDump(cleartext.Get()) << std::endl;\n    ss << \"nonce source: \";\n    if ( UseRandomNonce() ) {\n        ss << \"random\";\n    } else if ( UseBIP340Nonce() ) {\n        ss << \"BIP 340\";\n    } else if ( UseSpecifiedNonce() ) {\n        ss << \"specified\";\n    } else {\n        ss << \"(unknown)\";\n    }\n    ss << std::endl;\n\n    ss << \"digest: \" << repository::DigestToString(digestType.Get()) << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json Schnorr_Sign::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"Schnorr_Sign\";\n    j[\"priv\"] = priv.ToJSON();\n    j[\"nonce\"] = priv.ToJSON();\n    j[\"curveType\"] = curveType.ToJSON();\n    j[\"cleartext\"] = cleartext.ToJSON();\n    j[\"nonceSource\"] = nonceSource;\n    j[\"digestType\"] = digestType.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}
{"text_input": "Generate ECCSI_Verify code for operation.cpp", "output": "std::string ECCSI_Verify::Name(void) const { return \"ECCSI_Verify\"; }std::string ECCSI_Verify::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: ECCSI_Verify\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"public key X: \" << signature.pub.first.ToString() << std::endl;\n    ss << \"public key Y: \" << signature.pub.second.ToString() << std::endl;\n    ss << \"cleartext: \" << util::HexDump(cleartext.Get()) << std::endl;\n    ss << \"id: \" << util::HexDump(id.Get()) << std::endl;\n    ss << \"signature R: \" << signature.signature.first.ToString() << std::endl;\n    ss << \"signature S: \" << signature.signature.second.ToString() << std::endl;\n    ss << \"digest: \" << repository::DigestToString(digestType.Get()) << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json ECCSI_Verify::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"ECCSI_Verify\";\n    j[\"curveType\"] = curveType.ToJSON();\n    j[\"pub_x\"] = signature.pub.first.ToJSON();\n    j[\"pub_y\"] = signature.pub.second.ToJSON();\n    j[\"cleartext\"] = cleartext.ToJSON();\n    j[\"id\"] = id.ToJSON();\n    j[\"sig_r\"] = signature.signature.first.ToJSON();\n    j[\"sig_s\"] = signature.signature.second.ToJSON();\n    j[\"digestType\"] = digestType.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n/* Construct ECCSI_Verify from ECCSI_Sign */\nECCSI_Verify::ECCSI_Verify(const ECCSI_Sign& opECCSI_Sign, const component::ECCSI_Signature signature, component::Modifier modifier) :\n    Operation(std::move(modifier)),\n    curveType(opECCSI_Sign.curveType),\n    cleartext(opECCSI_Sign.cleartext),\n    id(opECCSI_Sign.id),\n    signature(signature),\n    digestType(opECCSI_Sign.digestType)\n{ }\n\n"}
{"text_input": "Generate ECDSA_Verify code for operation.cpp", "output": "std::string ECDSA_Verify::Name(void) const { return \"ECDSA_Verify\"; }std::string ECDSA_Verify::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: ECDSA_Verify\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"public key X: \" << signature.pub.first.ToString() << std::endl;\n    ss << \"public key Y: \" << signature.pub.second.ToString() << std::endl;\n    ss << \"cleartext: \" << util::HexDump(cleartext.Get()) << std::endl;\n    ss << \"signature R: \" << signature.signature.first.ToString() << std::endl;\n    ss << \"signature S: \" << signature.signature.second.ToString() << std::endl;\n    ss << \"digest: \" << repository::DigestToString(digestType.Get()) << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json ECDSA_Verify::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"ECDSA_Verify\";\n    j[\"curveType\"] = curveType.ToJSON();\n    j[\"pub_x\"] = signature.pub.first.ToJSON();\n    j[\"pub_y\"] = signature.pub.second.ToJSON();\n    j[\"cleartext\"] = cleartext.ToJSON();\n    j[\"sig_r\"] = signature.signature.first.ToJSON();\n    j[\"sig_s\"] = signature.signature.second.ToJSON();\n    j[\"digestType\"] = digestType.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n/* Construct ECDSA_Verify from ECDSA_Sign */\nECDSA_Verify::ECDSA_Verify(const ECDSA_Sign& opECDSA_Sign, const component::ECDSA_Signature signature, component::Modifier modifier) :\n    Operation(std::move(modifier)),\n    curveType(opECDSA_Sign.curveType),\n    cleartext(opECDSA_Sign.cleartext),\n    signature(signature),\n    digestType(opECDSA_Sign.digestType)\n{ }\n\n"}
{"text_input": "Generate ECGDSA_Verify code for operation.cpp", "output": "std::string ECGDSA_Verify::Name(void) const { return \"ECGDSA_Verify\"; }std::string ECGDSA_Verify::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: ECGDSA_Verify\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"public key X: \" << signature.pub.first.ToString() << std::endl;\n    ss << \"public key Y: \" << signature.pub.second.ToString() << std::endl;\n    ss << \"cleartext: \" << util::HexDump(cleartext.Get()) << std::endl;\n    ss << \"signature R: \" << signature.signature.first.ToString() << std::endl;\n    ss << \"signature S: \" << signature.signature.second.ToString() << std::endl;\n    ss << \"digest: \" << repository::DigestToString(digestType.Get()) << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json ECGDSA_Verify::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"ECGDSA_Verify\";\n    j[\"curveType\"] = curveType.ToJSON();\n    j[\"pub_x\"] = signature.pub.first.ToJSON();\n    j[\"pub_y\"] = signature.pub.second.ToJSON();\n    j[\"cleartext\"] = cleartext.ToJSON();\n    j[\"sig_r\"] = signature.signature.first.ToJSON();\n    j[\"sig_s\"] = signature.signature.second.ToJSON();\n    j[\"digestType\"] = digestType.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}
{"text_input": "Generate ECRDSA_Verify code for operation.cpp", "output": "std::string ECRDSA_Verify::Name(void) const { return \"ECRDSA_Verify\"; }std::string ECRDSA_Verify::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: ECRDSA_Verify\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"public key X: \" << signature.pub.first.ToString() << std::endl;\n    ss << \"public key Y: \" << signature.pub.second.ToString() << std::endl;\n    ss << \"cleartext: \" << util::HexDump(cleartext.Get()) << std::endl;\n    ss << \"signature R: \" << signature.signature.first.ToString() << std::endl;\n    ss << \"signature S: \" << signature.signature.second.ToString() << std::endl;\n    ss << \"digest: \" << repository::DigestToString(digestType.Get()) << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json ECRDSA_Verify::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"ECRDSA_Verify\";\n    j[\"curveType\"] = curveType.ToJSON();\n    j[\"pub_x\"] = signature.pub.first.ToJSON();\n    j[\"pub_y\"] = signature.pub.second.ToJSON();\n    j[\"cleartext\"] = cleartext.ToJSON();\n    j[\"sig_r\"] = signature.signature.first.ToJSON();\n    j[\"sig_s\"] = signature.signature.second.ToJSON();\n    j[\"digestType\"] = digestType.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}
{"text_input": "Generate Schnorr_Verify code for operation.cpp", "output": "std::string Schnorr_Verify::Name(void) const { return \"Schnorr_Verify\"; }std::string Schnorr_Verify::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: Schnorr_Verify\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"public key X: \" << signature.pub.first.ToString() << std::endl;\n    ss << \"public key Y: \" << signature.pub.second.ToString() << std::endl;\n    ss << \"cleartext: \" << util::HexDump(cleartext.Get()) << std::endl;\n    ss << \"signature R: \" << signature.signature.first.ToString() << std::endl;\n    ss << \"signature S: \" << signature.signature.second.ToString() << std::endl;\n    ss << \"digest: \" << repository::DigestToString(digestType.Get()) << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json Schnorr_Verify::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"Schnorr_Verify\";\n    j[\"curveType\"] = curveType.ToJSON();\n    j[\"pub_x\"] = signature.pub.first.ToJSON();\n    j[\"pub_y\"] = signature.pub.second.ToJSON();\n    j[\"cleartext\"] = cleartext.ToJSON();\n    j[\"sig_r\"] = signature.signature.first.ToJSON();\n    j[\"sig_s\"] = signature.signature.second.ToJSON();\n    j[\"digestType\"] = digestType.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}
{"text_input": "Generate ECDSA_Recover code for operation.cpp", "output": "std::string ECDSA_Recover::Name(void) const { return \"ECDSA_Recover\"; }std::string ECDSA_Recover::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: ECDSA_Recover\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"cleartext: \" << util::HexDump(cleartext.Get()) << std::endl;\n    ss << \"signature R: \" << signature.first.ToString() << std::endl;\n    ss << \"signature S: \" << signature.second.ToString() << std::endl;\n    ss << \"digest: \" << repository::DigestToString(digestType.Get()) << std::endl;\n    ss << \"recovery ID: \" << std::to_string(id) << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json ECDSA_Recover::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"ECDSA_Recover\";\n    j[\"curveType\"] = curveType.ToJSON();\n    j[\"cleartext\"] = cleartext.ToJSON();\n    j[\"sig_r\"] = signature.first.ToJSON();\n    j[\"sig_s\"] = signature.second.ToJSON();\n    j[\"id\"] = id;\n    j[\"digestType\"] = digestType.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}
{"text_input": "Generate DSA_Verify code for operation.cpp", "output": "std::string DSA_Verify::Name(void) const { return \"DSA_Verify\"; }std::string DSA_Verify::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: DSA_Verify\" << std::endl;\n    ss << \"p: \" << parameters.p.ToString() << std::endl;\n    ss << \"q: \" << parameters.q.ToString() << std::endl;\n    ss << \"g: \" << parameters.g.ToString() << std::endl;\n    ss << \"public key: \" << pub.ToString() << std::endl;\n    ss << \"r: \" << signature.first.ToString() << std::endl;\n    ss << \"s: \" << signature.second.ToString() << std::endl;\n    ss << \"cleartext: \" << util::HexDump(cleartext.Get()) << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json DSA_Verify::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"p\"] = parameters.p.ToJSON();\n    j[\"q\"] = parameters.q.ToJSON();\n    j[\"g\"] = parameters.g.ToJSON();\n    j[\"pub\"] = pub.ToJSON();\n    j[\"r\"] = signature.first.ToJSON();\n    j[\"s\"] = signature.second.ToJSON();\n    j[\"cleartext\"] = cleartext.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}
{"text_input": "Generate DSA_Sign code for operation.cpp", "output": "std::string DSA_Sign::Name(void) const { return \"DSA_Sign\"; }std::string DSA_Sign::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: DSA_Sign\" << std::endl;\n    ss << \"p: \" << parameters.p.ToString() << std::endl;\n    ss << \"q: \" << parameters.q.ToString() << std::endl;\n    ss << \"g: \" << parameters.g.ToString() << std::endl;\n    ss << \"private key: \" << priv.ToString() << std::endl;\n    ss << \"cleartext: \" << util::HexDump(cleartext.Get()) << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json DSA_Sign::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"p\"] = parameters.p.ToJSON();\n    j[\"q\"] = parameters.q.ToJSON();\n    j[\"g\"] = parameters.g.ToJSON();\n    j[\"priv\"] = priv.ToJSON();\n    j[\"cleartext\"] = cleartext.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}
{"text_input": "Generate DSA_PrivateToPublic code for operation.cpp", "output": "std::string DSA_PrivateToPublic::Name(void) const { return \"DSA_PrivateToPublic\"; }std::string DSA_PrivateToPublic::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: DSA_PrivateToPublic\" << std::endl;\n    ss << \"priv: \" << priv.ToString() << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json DSA_PrivateToPublic::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"priv\"] = priv.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}
{"text_input": "Generate DSA_GenerateKeyPair code for operation.cpp", "output": "std::string DSA_GenerateKeyPair::Name(void) const { return \"DSA_GenerateKeyPair\"; }std::string DSA_GenerateKeyPair::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: DSA_GenerateKeyPair\" << std::endl;\n    ss << \"p: \" << p.ToString() << std::endl;\n    ss << \"q: \" << q.ToString() << std::endl;\n    ss << \"g: \" << g.ToString() << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json DSA_GenerateKeyPair::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"p\"] = p.ToJSON();\n    j[\"q\"] = q.ToJSON();\n    j[\"g\"] = g.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}
{"text_input": "Generate DSA_GenerateParameters code for operation.cpp", "output": "std::string DSA_GenerateParameters::Name(void) const { return \"DSA_GenerateParameters\"; }std::string DSA_GenerateParameters::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: DSA_GenerateParameters\" << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json DSA_GenerateParameters::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}
{"text_input": "Generate ECDH_Derive code for operation.cpp", "output": "std::string ECDH_Derive::Name(void) const { return \"ECDH_Derive\"; }std::string ECDH_Derive::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: ECDH_Derive\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"private key: \" << priv.ToString() << std::endl;\n    ss << \"public key X: \" << pub.first.ToString() << std::endl;\n    ss << \"public key Y: \" << pub.second.ToString() << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json ECDH_Derive::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"ECDH_Derive\";\n    j[\"curveType\"] = curveType.ToJSON();\n    j[\"priv\"] = priv.ToJSON();\n    j[\"pub_x\"] = pub.first.ToJSON();\n    j[\"pub_y\"] = pub.second.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}
{"text_input": "Generate ECIES_Encrypt code for operation.cpp", "output": "std::string ECIES_Encrypt::Name(void) const { return \"ECIES_Encrypt\"; }std::string ECIES_Encrypt::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: ECIES_Encrypt\" << std::endl;\n    ss << \"cleartext: \" << util::HexDump(cleartext.Get()) << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"private key: \" << priv.ToString() << std::endl;\n    ss << \"public key X: \" << pub.first.ToString() << std::endl;\n    ss << \"public key Y: \" << pub.second.ToString() << std::endl;\n    ss << \"cipher: \" << repository::CipherToString(cipherType.Get()) << std::endl;\n    ss << \"iv: \" << (iv ? util::HexDump(iv->Get()) : \"nullopt\") << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json ECIES_Encrypt::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"ECIES_Encrypt\";\n    j[\"cleartext\"] = cleartext.ToJSON();\n    j[\"curveType\"] = curveType.ToJSON();\n    j[\"priv\"] = priv.ToJSON();\n    j[\"pub_x\"] = pub.first.ToJSON();\n    j[\"pub_y\"] = pub.second.ToJSON();\n    j[\"cipherType\"] = cipherType.ToJSON();\n    j[\"iv_enabled\"] = (bool)(iv != std::nullopt);\n    j[\"iv\"] = iv != std::nullopt ? iv->ToJSON() : \"\";\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}
{"text_input": "Generate ECIES_Decrypt code for operation.cpp", "output": "std::string ECIES_Decrypt::Name(void) const { return \"ECIES_Decrypt\"; }std::string ECIES_Decrypt::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: ECIES_Decrypt\" << std::endl;\n    ss << \"ciphertext: \" << util::HexDump(ciphertext.Get()) << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"private key: \" << priv.ToString() << std::endl;\n    ss << \"public key X: \" << pub.first.ToString() << std::endl;\n    ss << \"public key Y: \" << pub.second.ToString() << std::endl;\n    ss << \"cipher: \" << repository::CipherToString(cipherType.Get()) << std::endl;\n    ss << \"iv: \" << (iv ? util::HexDump(iv->Get()) : \"nullopt\") << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json ECIES_Decrypt::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"ECIES_Decrypt\";\n    j[\"ciphertext\"] = ciphertext.ToJSON();\n    j[\"curveType\"] = curveType.ToJSON();\n    j[\"priv\"] = priv.ToJSON();\n    j[\"pub_x\"] = pub.first.ToJSON();\n    j[\"pub_y\"] = pub.second.ToJSON();\n    j[\"cipherType\"] = cipherType.ToJSON();\n    j[\"iv_enabled\"] = (bool)(iv != std::nullopt);\n    j[\"iv\"] = iv != std::nullopt ? iv->ToJSON() : \"\";\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}
{"text_input": "Generate ECC_Point_Add code for operation.cpp", "output": "std::string ECC_Point_Add::Name(void) const { return \"ECC_Point_Add\"; }std::string ECC_Point_Add::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: ECC_Point_Add\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"A X: \" << a.first.ToString() << std::endl;\n    ss << \"A Y: \" << a.second.ToString() << std::endl;\n    ss << \"B X: \" << b.first.ToString() << std::endl;\n    ss << \"B Y: \" << b.second.ToString() << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json ECC_Point_Add::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"ECC_Point_Add\";\n    j[\"curveType\"] = curveType.ToJSON();\n\n    j[\"a_x\"] = a.first.ToJSON();\n    j[\"a_y\"] = a.second.ToJSON();\n\n    j[\"b_x\"] = b.first.ToJSON();\n    j[\"b_y\"] = b.second.ToJSON();\n\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}
{"text_input": "Generate ECC_Point_Sub code for operation.cpp", "output": "std::string ECC_Point_Sub::Name(void) const { return \"ECC_Point_Sub\"; }std::string ECC_Point_Sub::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: ECC_Point_Sub\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"A X: \" << a.first.ToString() << std::endl;\n    ss << \"A Y: \" << a.second.ToString() << std::endl;\n    ss << \"B X: \" << b.first.ToString() << std::endl;\n    ss << \"B Y: \" << b.second.ToString() << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json ECC_Point_Sub::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"ECC_Point_Sub\";\n    j[\"curveType\"] = curveType.ToJSON();\n\n    j[\"a_x\"] = a.first.ToJSON();\n    j[\"a_y\"] = a.second.ToJSON();\n\n    j[\"b_x\"] = b.first.ToJSON();\n    j[\"b_y\"] = b.second.ToJSON();\n\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}
{"text_input": "Generate ECC_Point_Mul code for operation.cpp", "output": "std::string ECC_Point_Mul::Name(void) const { return \"ECC_Point_Mul\"; }std::string ECC_Point_Mul::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: ECC_Point_Mul\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"A X: \" << a.first.ToString() << std::endl;\n    ss << \"A Y: \" << a.second.ToString() << std::endl;\n    ss << \"B: \" << b.ToString() << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json ECC_Point_Mul::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"ECC_Point_Mul\";\n    j[\"curveType\"] = curveType.ToJSON();\n\n    j[\"a_x\"] = a.first.ToJSON();\n    j[\"a_y\"] = a.second.ToJSON();\n\n    j[\"b\"] = b.ToJSON();\n\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}
{"text_input": "Generate ECC_Point_Neg code for operation.cpp", "output": "std::string ECC_Point_Neg::Name(void) const { return \"ECC_Point_Neg\"; }std::string ECC_Point_Neg::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: ECC_Point_Neg\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"A X: \" << a.first.ToString() << std::endl;\n    ss << \"A Y: \" << a.second.ToString() << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json ECC_Point_Neg::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"curveType\"] = curveType.ToJSON();\n\n    j[\"a_x\"] = a.first.ToJSON();\n    j[\"a_y\"] = a.second.ToJSON();\n\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}
{"text_input": "Generate ECC_Point_Dbl code for operation.cpp", "output": "std::string ECC_Point_Dbl::Name(void) const { return \"ECC_Point_Dbl\"; }std::string ECC_Point_Dbl::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: ECC_Point_Dbl\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"A X: \" << a.first.ToString() << std::endl;\n    ss << \"A Y: \" << a.second.ToString() << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json ECC_Point_Dbl::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"curveType\"] = curveType.ToJSON();\n\n    j[\"a_x\"] = a.first.ToJSON();\n    j[\"a_y\"] = a.second.ToJSON();\n\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}
{"text_input": "Generate ECC_Point_Cmp code for operation.cpp", "output": "std::string ECC_Point_Cmp::Name(void) const { return \"ECC_Point_Cmp\"; }std::string ECC_Point_Cmp::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: ECC_Point_Cmp\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"A X: \" << a.first.ToString() << std::endl;\n    ss << \"A Y: \" << a.second.ToString() << std::endl;\n    ss << \"B X: \" << b.first.ToString() << std::endl;\n    ss << \"B Y: \" << b.second.ToString() << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json ECC_Point_Cmp::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"ECC_Point_Cmp\";\n    j[\"curveType\"] = curveType.ToJSON();\n\n    j[\"a_x\"] = a.first.ToJSON();\n    j[\"a_y\"] = a.second.ToJSON();\n\n    j[\"b_x\"] = b.first.ToJSON();\n    j[\"b_y\"] = b.second.ToJSON();\n\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}
{"text_input": "Generate DH_GenerateKeyPair code for operation.cpp", "output": "std::string DH_GenerateKeyPair::Name(void) const { return \"DH_GenerateKeyPair\"; }std::string DH_GenerateKeyPair::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: DH_GenerateKeyPair\" << std::endl;\n    ss << \"prime: \" << prime.ToString() << std::endl;\n    ss << \"base: \" << base.ToString() << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json DH_GenerateKeyPair::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"DH_GenerateKeyPair\";\n    j[\"prime\"] = prime.ToJSON();\n    j[\"base\"] = base.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}
{"text_input": "Generate DH_Derive code for operation.cpp", "output": "std::string DH_Derive::Name(void) const { return \"DH_Derive\"; }std::string DH_Derive::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: DH_Derive\" << std::endl;\n    ss << \"prime: \" << prime.ToString() << std::endl;\n    ss << \"base: \" << base.ToString() << std::endl;\n    ss << \"public key: \" << pub.ToString() << std::endl;\n    ss << \"private key: \" << priv.ToString() << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json DH_Derive::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"DH_Derive\";\n    j[\"prime\"] = prime.ToJSON();\n    j[\"base\"] = base.ToJSON();\n    j[\"pub\"] = pub.ToJSON();\n    j[\"priv\"] = priv.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}
{"text_input": "Generate BignumCalc code for operation.cpp", "output": "std::string BignumCalc::Name(void) const { return \"BignumCalc\"; }std::string BignumCalc::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: BignumCalc\" << std::endl;\n    ss << \"calc operation: \" << repository::CalcOpToString(calcOp.Get()) << std::endl;\n    ss << \"bignum 1: \" << bn0.ToString() << std::endl;\n    ss << \"bignum 2: \" << bn1.ToString() << std::endl;\n    ss << \"bignum 3: \" << bn2.ToString() << std::endl;\n    ss << \"bignum 4: \" << bn3.ToString() << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json BignumCalc::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"BignumCalc\";\n    j[\"calcOp\"] = calcOp.ToJSON();\n    j[\"bn0\"] = bn0.ToJSON();\n    j[\"bn1\"] = bn1.ToJSON();\n    j[\"bn2\"] = bn2.ToJSON();\n    j[\"bn3\"] = bn3.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}
{"text_input": "Generate BignumCalc_Fp2 code for operation.cpp", "output": "std::string BignumCalc_Fp2::Name(void) const { return \"BignumCalc_Fp2\"; }std::string BignumCalc_Fp2::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: BignumCalc_Fp2\" << std::endl;\n    ss << \"calc operation: \" << repository::CalcOpToString(calcOp.Get()) << std::endl;\n    ss << \"Fp2 1 x: \" << bn0.first.ToString() << std::endl;\n    ss << \"Fp2 1 x: \" << bn0.second.ToString() << std::endl;\n    ss << \"Fp2 2 x: \" << bn1.first.ToString() << std::endl;\n    ss << \"Fp2 2 x: \" << bn1.second.ToString() << std::endl;\n    ss << \"Fp2 3 x: \" << bn2.first.ToString() << std::endl;\n    ss << \"Fp2 3 x: \" << bn2.second.ToString() << std::endl;\n    ss << \"Fp2 4 x: \" << bn3.first.ToString() << std::endl;\n    ss << \"Fp2 4 x: \" << bn3.second.ToString() << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json BignumCalc_Fp2::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"BignumCalc\";\n    j[\"calcOp\"] = calcOp.ToJSON();\n    j[\"bn0\"] = bn0.ToJSON();\n    j[\"bn1\"] = bn1.ToJSON();\n    j[\"bn2\"] = bn2.ToJSON();\n    j[\"bn3\"] = bn3.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}
{"text_input": "Generate BignumCalc_Fp12 code for operation.cpp", "output": "std::string BignumCalc_Fp12::Name(void) const { return \"BignumCalc_Fp12\"; }std::string BignumCalc_Fp12::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: BignumCalc_Fp12\" << std::endl;\n    ss << \"calc operation: \" << repository::CalcOpToString(calcOp.Get()) << std::endl;\n    ss << \"bn0 1: \" << bn0.bn1.ToString() << std::endl;\n    ss << \"bn0 2: \" << bn0.bn2.ToString() << std::endl;\n    ss << \"bn0 3: \" << bn0.bn3.ToString() << std::endl;\n    ss << \"bn0 4: \" << bn0.bn4.ToString() << std::endl;\n    ss << \"bn0 5: \" << bn0.bn5.ToString() << std::endl;\n    ss << \"bn0 6: \" << bn0.bn6.ToString() << std::endl;\n    ss << \"bn0 7: \" << bn0.bn7.ToString() << std::endl;\n    ss << \"bn0 8: \" << bn0.bn8.ToString() << std::endl;\n    ss << \"bn0 9: \" << bn0.bn9.ToString() << std::endl;\n    ss << \"bn0 10: \" << bn0.bn10.ToString() << std::endl;\n    ss << \"bn0 11: \" << bn0.bn11.ToString() << std::endl;\n    ss << \"bn0 12: \" << bn0.bn12.ToString() << std::endl;\n\n    ss << std::endl;\n\n    ss << \"bn1 1: \" << bn1.bn1.ToString() << std::endl;\n    ss << \"bn1 2: \" << bn1.bn2.ToString() << std::endl;\n    ss << \"bn1 3: \" << bn1.bn3.ToString() << std::endl;\n    ss << \"bn1 4: \" << bn1.bn4.ToString() << std::endl;\n    ss << \"bn1 5: \" << bn1.bn5.ToString() << std::endl;\n    ss << \"bn1 6: \" << bn1.bn6.ToString() << std::endl;\n    ss << \"bn1 7: \" << bn1.bn7.ToString() << std::endl;\n    ss << \"bn1 8: \" << bn1.bn8.ToString() << std::endl;\n    ss << \"bn1 9: \" << bn1.bn9.ToString() << std::endl;\n    ss << \"bn1 10: \" << bn1.bn10.ToString() << std::endl;\n    ss << \"bn1 11: \" << bn1.bn11.ToString() << std::endl;\n    ss << \"bn1 12: \" << bn1.bn12.ToString() << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json BignumCalc_Fp12::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"BignumCalc\";\n    j[\"calcOp\"] = calcOp.ToJSON();\n    j[\"bn0\"] = bn0.ToJSON();\n    j[\"bn1\"] = bn1.ToJSON();\n    j[\"bn2\"] = bn2.ToJSON();\n    j[\"bn3\"] = bn3.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}
{"text_input": "Generate BLS_PrivateToPublic code for operation.cpp", "output": "std::string BLS_PrivateToPublic::Name(void) const { return \"BLS_PrivateToPublic\"; }std::string BLS_PrivateToPublic::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: BLS_PrivateToPublic\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"private key: \" << priv.ToString() << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json BLS_PrivateToPublic::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"BLS_PrivateToPublic\";\n    j[\"priv\"] = priv.ToJSON();\n    j[\"curveType\"] = curveType.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}
{"text_input": "Generate BLS_PrivateToPublic_G2 code for operation.cpp", "output": "std::string BLS_PrivateToPublic_G2::Name(void) const { return \"BLS_PrivateToPublic_G2\"; }std::string BLS_PrivateToPublic_G2::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: BLS_PrivateToPublic_G2\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"private key: \" << priv.ToString() << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json BLS_PrivateToPublic_G2::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"BLS_PrivateToPublic_G2\";\n    j[\"priv\"] = priv.ToJSON();\n    j[\"curveType\"] = curveType.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}
{"text_input": "Generate BLS_Sign code for operation.cpp", "output": "std::string BLS_Sign::Name(void) const { return \"BLS_Sign\"; }std::string BLS_Sign::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: BLS_Sign\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"private key: \" << priv.ToString() << std::endl;\n    if ( hashOrPoint == true ) {\n        ss << \"cleartext: \" << util::HexDump(cleartext.Get()) << std::endl;\n    } else {\n        ss << \"point V: \" << point.first.first.ToString() << std::endl;\n        ss << \"point W: \" << point.first.second.ToString() << std::endl;\n        ss << \"point X: \" << point.second.first.ToString() << std::endl;\n        ss << \"point Y: \" << point.second.second.ToString() << std::endl;\n    }\n    ss << \"dest: \" << util::HexDump(dest.Get()) << std::endl;\n    ss << \"aug: \" << util::HexDump(aug.Get()) << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json BLS_Sign::ToJSON(void) const {\n    nlohmann::json j;\n\n    j[\"operation\"] = \"BLS_Sign\";\n    j[\"curveType\"] = curveType.ToJSON();\n\n    j[\"hashOrPoint\"] = hashOrPoint;\n\n    j[\"priv\"] = priv.ToJSON();\n\n    if ( hashOrPoint == true ) {\n        j[\"cleartext\"] = cleartext.ToJSON();\n    } else {\n        j[\"g2_v\"] = point.first.first.ToJSON();\n        j[\"g2_w\"] = point.first.second.ToJSON();\n        j[\"g2_x\"] = point.second.first.ToJSON();\n        j[\"g2_y\"] = point.second.second.ToJSON();\n    }\n    j[\"dest\"] = dest.ToJSON();\n    j[\"aug\"] = aug.ToJSON();\n\n    j[\"modifier\"] = modifier.ToJSON();\n\n    return j;\n}\n\n"}
{"text_input": "Generate BLS_Verify code for operation.cpp", "output": "std::string BLS_Verify::Name(void) const { return \"BLS_Verify\"; }std::string BLS_Verify::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: BLS_Verify\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"public key X: \" << pub.first.ToString() << std::endl;\n    ss << \"public key Y: \" << pub.second.ToString() << std::endl;\n    ss << \"cleartext: \" << util::HexDump(cleartext.Get()) << std::endl;\n    ss << \"signature V: \" << signature.first.first.ToString() << std::endl;\n    ss << \"signature W: \" << signature.first.second.ToString() << std::endl;\n    ss << \"signature X: \" << signature.second.first.ToString() << std::endl;\n    ss << \"signature Y: \" << signature.second.second.ToString() << std::endl;\n    ss << \"dest: \" << util::HexDump(dest.Get()) << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json BLS_Verify::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"BLS_Verify\";\n    j[\"curveType\"] = curveType.ToJSON();\n\n    j[\"cleartext\"] = cleartext.ToJSON();\n\n    j[\"g1_x\"] = pub.first.ToJSON();\n    j[\"g1_y\"] = pub.second.ToJSON();\n\n    j[\"g2_v\"] = signature.first.first.ToJSON();\n    j[\"g2_w\"] = signature.first.second.ToJSON();\n    j[\"g2_x\"] = signature.second.first.ToJSON();\n    j[\"g2_y\"] = signature.second.second.ToJSON();\n\n    j[\"dest\"] = dest.ToJSON();\n\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}
{"text_input": "Generate BLS_BatchSign code for operation.cpp", "output": "std::string BLS_BatchSign::Name(void) const { return \"BLS_BatchSign\"; }std::string BLS_BatchSign::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: BLS_BatchSign\" << std::endl;\n\n    for (const auto& cur : bf.c) {\n        ss << \"priv: \" << cur.priv.ToString() << std::endl;\n        ss << \"G1 X: \" << cur.g1.first.ToString() << std::endl;\n        ss << \"G1 Y: \" << cur.g1.second.ToString() << std::endl;\n    }\n    return ss.str();\n}\n\nnlohmann::json BLS_BatchSign::ToJSON(void) const {\n    nlohmann::json j;\n    /* TODO */\n    return j;\n}\n\n"}
{"text_input": "Generate BLS_BatchVerify code for operation.cpp", "output": "std::string BLS_BatchVerify::Name(void) const { return \"BLS_BatchVerify\"; }std::string BLS_BatchVerify::ToString(void) const {\n    std::stringstream ss;\n\n    for (const auto& cur : bf.c) {\n        ss << \"G1 X: \" << cur.g1.first.ToString() << std::endl;\n        ss << \"G1 Y: \" << cur.g1.second.ToString() << std::endl;\n        ss << std::endl;\n        ss << \"G2 V: \" << cur.g2.first.first.ToString() << std::endl;\n        ss << \"G2 W: \" << cur.g2.first.second.ToString() << std::endl;\n        ss << \"G2 X: \" << cur.g2.second.first.ToString() << std::endl;\n        ss << \"G2 Y: \" << cur.g2.second.second.ToString() << std::endl;\n        ss << \"----------\" << std::endl;\n    }\n\n    /* TODO */\n    return ss.str();\n}\n\nnlohmann::json BLS_BatchVerify::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"BLS_BatchVerify\";\n    j[\"modifier\"] = modifier.ToJSON();\n    j[\"bf\"] = bf.ToJSON();\n    return j;\n}\n\n"}
{"text_input": "Generate BLS_Pairing code for operation.cpp", "output": "std::string BLS_Pairing::Name(void) const { return \"BLS_Pairing\"; }std::string BLS_Pairing::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: BLS_Pairing\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"G1 X: \" << g1.first.ToString() << std::endl;\n    ss << \"G1 Y: \" << g1.second.ToString() << std::endl;\n    ss << \"G2 V: \" << g2.first.first.ToString() << std::endl;\n    ss << \"G2 W: \" << g2.first.second.ToString() << std::endl;\n    ss << \"G2 X: \" << g2.second.first.ToString() << std::endl;\n    ss << \"G2 Y: \" << g2.second.second.ToString() << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json BLS_Pairing::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"BLS_Pairing\";\n    j[\"curveType\"] = curveType.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n    j[\"g1_x\"] = g1.first.ToJSON();\n    j[\"g1_y\"] = g1.second.ToJSON();\n    j[\"g2_v\"] = g2.first.first.ToJSON();\n    j[\"g2_w\"] = g2.first.second.ToJSON();\n    j[\"g2_x\"] = g2.second.first.ToJSON();\n    j[\"g2_y\"] = g2.second.second.ToJSON();\n    return j;\n}\n\n"}
{"text_input": "Generate BLS_MillerLoop code for operation.cpp", "output": "std::string BLS_MillerLoop::Name(void) const { return \"BLS_MillerLoop\"; }std::string BLS_MillerLoop::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: BLS_MillerLoop\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"G1 X: \" << g1.first.ToString() << std::endl;\n    ss << \"G1 Y: \" << g1.second.ToString() << std::endl;\n    ss << \"G2 V: \" << g2.first.first.ToString() << std::endl;\n    ss << \"G2 W: \" << g2.first.second.ToString() << std::endl;\n    ss << \"G2 X: \" << g2.second.first.ToString() << std::endl;\n    ss << \"G2 Y: \" << g2.second.second.ToString() << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json BLS_MillerLoop::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"curveType\"] = curveType.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}
{"text_input": "Generate BLS_FinalExp code for operation.cpp", "output": "std::string BLS_FinalExp::Name(void) const { return \"BLS_FinalExp\"; }std::string BLS_FinalExp::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: BLS_FinalExp\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"Fp12 c0.b0.a0: \" << fp12.bn1.ToString() << std::endl;\n    ss << \"Fp12 c0.b0.a1: \" << fp12.bn2.ToString() << std::endl;\n    ss << \"Fp12 c0.b1.a0: \" << fp12.bn3.ToString() << std::endl;\n    ss << \"Fp12 c0.b1.a1: \" << fp12.bn4.ToString() << std::endl;\n    ss << \"Fp12 c0.b2.a0: \" << fp12.bn5.ToString() << std::endl;\n    ss << \"Fp12 c0.b2.a1: \" << fp12.bn6.ToString() << std::endl;\n    ss << \"Fp12 c1.b0.a0: \" << fp12.bn7.ToString() << std::endl;\n    ss << \"Fp12 c1.b0.a1: \" << fp12.bn8.ToString() << std::endl;\n    ss << \"Fp12 c1.b1.a0: \" << fp12.bn9.ToString() << std::endl;\n    ss << \"Fp12 c1.b1.a1: \" << fp12.bn10.ToString() << std::endl;\n    ss << \"Fp12 c1.b2.a0: \" << fp12.bn11.ToString() << std::endl;\n    ss << \"Fp12 c1.b2.a1: \" << fp12.bn12.ToString() << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json BLS_FinalExp::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"BLS_FinalExp\";\n    j[\"curveType\"] = curveType.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n    j[\"fp12\"] = fp12.ToJSON();\n    return j;\n}\n"}
{"text_input": "Generate BLS_Aggregate_G1 code for operation.cpp", "output": "std::string BLS_Aggregate_G1::Name(void) const { return \"BLS_Aggregate_G1\"; }std::string BLS_Aggregate_G1::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: BLS_Aggregate_G1\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n\n    for (const auto& g1 : points.points) {\n        ss << \"    X: \" << g1.first.ToString() << std::endl;\n        ss << \"    Y: \" << g1.second.ToString() << std::endl;\n        ss << std::endl;\n    }\n\n    return ss.str();\n}\n\nnlohmann::json BLS_Aggregate_G1::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"BLS_Aggregate_G1\";\n    j[\"curveType\"] = curveType.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n\n    nlohmann::json points_json = nlohmann::json::array();\n\n    for (const auto& g1 : points.points) {\n        nlohmann::json point;\n\n        point[\"x\"] = g1.first.ToJSON();\n        point[\"y\"] = g1.second.ToJSON();\n\n        points_json.push_back(point);\n    }\n\n    j[\"points\"] = points_json;\n\n    return j;\n}\n\n"}
{"text_input": "Generate BLS_Aggregate_G2 code for operation.cpp", "output": "std::string BLS_Aggregate_G2::Name(void) const { return \"BLS_Aggregate_G2\"; }std::string BLS_Aggregate_G2::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: BLS_Aggregate_G2\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n\n    for (const auto& g2 : points.points) {\n        ss << \"    V:\" << g2.first.first.ToString() << std::endl;\n        ss << \"    W:\" << g2.first.second.ToString() << std::endl;\n        ss << \"    X:\" << g2.second.first.ToString() << std::endl;\n        ss << \"    Y:\" << g2.second.second.ToString() << std::endl;\n        ss << std::endl;\n    }\n\n    return ss.str();\n}\n\nnlohmann::json BLS_Aggregate_G2::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"BLS_Aggregate_G2\";\n    j[\"curveType\"] = curveType.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n\n    nlohmann::json points_json = nlohmann::json::array();\n\n    for (const auto& g2 : points.points) {\n        nlohmann::json point;\n\n        point[\"v\"] = g2.first.first.ToJSON();\n        point[\"w\"] = g2.first.second.ToJSON();\n        point[\"x\"] = g2.second.first.ToJSON();\n        point[\"y\"] = g2.second.second.ToJSON();\n\n        points_json.push_back(point);\n    }\n\n    j[\"points\"] = points_json;\n    return j;\n}\n\n"}
{"text_input": "Generate BLS_HashToG1 code for operation.cpp", "output": "std::string BLS_HashToG1::Name(void) const { return \"BLS_HashToG1\"; }std::string BLS_HashToG1::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: BLS_HashToG1\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"cleartext: \" << util::HexDump(cleartext.Get()) << std::endl;\n    ss << \"dest: \" << util::HexDump(dest.Get()) << std::endl;\n    ss << \"aug: \" << util::HexDump(aug.Get()) << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json BLS_HashToG1::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"BLS_HashToG1\";\n    j[\"curveType\"] = curveType.ToJSON();\n    j[\"cleartext\"] = cleartext.ToJSON();\n    j[\"dest\"] = dest.ToJSON();\n    j[\"aug\"] = aug.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}
{"text_input": "Generate BLS_HashToG2 code for operation.cpp", "output": "std::string BLS_HashToG2::Name(void) const { return \"BLS_HashToG2\"; }std::string BLS_HashToG2::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: BLS_HashToG2\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"cleartext: \" << util::HexDump(cleartext.Get()) << std::endl;\n    ss << \"dest: \" << util::HexDump(dest.Get()) << std::endl;\n    ss << \"aug: \" << util::HexDump(aug.Get()) << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json BLS_HashToG2::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"BLS_HashToG2\";\n    j[\"curveType\"] = curveType.ToJSON();\n    j[\"cleartext\"] = cleartext.ToJSON();\n    j[\"dest\"] = dest.ToJSON();\n    j[\"aug\"] = aug.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}
{"text_input": "Generate BLS_MapToG1 code for operation.cpp", "output": "std::string BLS_MapToG1::Name(void) const { return \"BLS_MapToG1\"; }std::string BLS_MapToG1::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: BLS_MapToG1\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"u: \" << u.ToString() << std::endl;\n    ss << \"v: \" << v.ToString() << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json BLS_MapToG1::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"BLS_MapToG1\";\n    j[\"curveType\"] = curveType.ToJSON();\n    j[\"u\"] = u.ToJSON();\n    j[\"v\"] = v.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}
{"text_input": "Generate BLS_MapToG2 code for operation.cpp", "output": "std::string BLS_MapToG2::Name(void) const { return \"BLS_MapToG2\"; }std::string BLS_MapToG2::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: BLS_MapToG2\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"u_x: \" << u.first.ToString() << std::endl;\n    ss << \"u_y: \" << u.second.ToString() << std::endl;\n    ss << \"v_x: \" << v.first.ToString() << std::endl;\n    ss << \"v_y: \" << v.second.ToString() << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json BLS_MapToG2::ToJSON(void) const {\n    nlohmann::json j;\n\n    j[\"operation\"] = \"BLS_MapToG2\";\n    j[\"u_x\"] = u.first.ToJSON();\n    j[\"u_y\"] = u.second.ToJSON();\n    j[\"v_x\"] = v.first.ToJSON();\n    j[\"v_y\"] = v.second.ToJSON();\n\n    return j;\n}\n\n"}
{"text_input": "Generate BLS_IsG1OnCurve code for operation.cpp", "output": "std::string BLS_IsG1OnCurve::Name(void) const { return \"BLS_IsG1OnCurve\"; }std::string BLS_IsG1OnCurve::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: BLS_IsG1OnCurve\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"G1 X: \" << g1.first.ToString() << std::endl;\n    ss << \"G1 Y: \" << g1.second.ToString() << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json BLS_IsG1OnCurve::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"BLS_IsG1OnCurve\";\n    j[\"curveType\"] = curveType.ToJSON();\n\n    j[\"g1_x\"] = g1.first.ToJSON();\n    j[\"g1_y\"] = g1.second.ToJSON();\n\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}
{"text_input": "Generate BLS_IsG2OnCurve code for operation.cpp", "output": "std::string BLS_IsG2OnCurve::Name(void) const { return \"BLS_IsG2OnCurve\"; }std::string BLS_IsG2OnCurve::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: BLS_IsG2OnCurve\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"G2 V: \" << g2.first.first.ToString() << std::endl;\n    ss << \"G2 W: \" << g2.first.second.ToString() << std::endl;\n    ss << \"G2 X: \" << g2.second.first.ToString() << std::endl;\n    ss << \"G2 Y: \" << g2.second.second.ToString() << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json BLS_IsG2OnCurve::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"BLS_IsG2OnCurve\";\n    j[\"curveType\"] = curveType.ToJSON();\n\n    j[\"g2_v\"] = g2.first.first.ToJSON();\n    j[\"g2_w\"] = g2.first.second.ToJSON();\n    j[\"g2_x\"] = g2.second.first.ToJSON();\n    j[\"g2_y\"] = g2.second.second.ToJSON();\n\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}
{"text_input": "Generate BLS_GenerateKeyPair code for operation.cpp", "output": "std::string BLS_GenerateKeyPair::Name(void) const { return \"BLS_GenerateKeyPair\"; }std::string BLS_GenerateKeyPair::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: BLS_GenerateKeyPair\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"ikm: \" << util::HexDump(ikm.Get()) << std::endl;\n    ss << \"info: \" << util::HexDump(info.Get()) << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json BLS_GenerateKeyPair::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"BLS_GenerateKeyPair\";\n    j[\"curveType\"] = curveType.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n    j[\"ikm\"] = ikm.ToJSON();\n    j[\"info\"] = info.ToJSON();\n    return j;\n}\n\n"}
{"text_input": "Generate BLS_Decompress_G1 code for operation.cpp", "output": "std::string BLS_Decompress_G1::Name(void) const { return \"BLS_Decompress_G1\"; }std::string BLS_Decompress_G1::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: BLS_Decompress_G1\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"compressed: \" << compressed.ToString() << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json BLS_Decompress_G1::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"BLS_Decompress_G1\";\n    j[\"curveType\"] = curveType.ToJSON();\n    j[\"compressed\"] = compressed.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}
{"text_input": "Generate BLS_Compress_G1 code for operation.cpp", "output": "std::string BLS_Compress_G1::Name(void) const { return \"BLS_Compress_G1\"; }std::string BLS_Compress_G1::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: BLS_Compress_G1\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"uncompressed X:\" << uncompressed.first.ToString() << std::endl;\n    ss << \"uncompressed Y:\" << uncompressed.second.ToString() << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json BLS_Compress_G1::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"BLS_Compress_G1\";\n    j[\"curveType\"] = curveType.ToJSON();\n    j[\"g1_x\"] = uncompressed.first.ToJSON();\n    j[\"g1_y\"] = uncompressed.second.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}
{"text_input": "Generate BLS_Decompress_G2 code for operation.cpp", "output": "std::string BLS_Decompress_G2::Name(void) const { return \"BLS_Decompress_G2\"; }std::string BLS_Decompress_G2::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: BLS_Decompress_G2\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"compressed X: \" << compressed.first.ToString() << std::endl;\n    ss << \"compressed Y: \" << compressed.second.ToString() << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json BLS_Decompress_G2::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"BLS_Decompress_G2\";\n    j[\"curveType\"] = curveType.ToJSON();\n    j[\"g1_x\"] = compressed.first.ToJSON();\n    j[\"g1_y\"] = compressed.second.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}
{"text_input": "Generate BLS_Compress_G2 code for operation.cpp", "output": "std::string BLS_Compress_G2::Name(void) const { return \"BLS_Compress_G2\"; }std::string BLS_Compress_G2::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: BLS_Compress_G2\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"uncompressed V:\" << uncompressed.first.first.ToString() << std::endl;\n    ss << \"uncompressed W:\" << uncompressed.first.second.ToString() << std::endl;\n    ss << \"uncompressed X:\" << uncompressed.second.first.ToString() << std::endl;\n    ss << \"uncompressed Y:\" << uncompressed.second.second.ToString() << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json BLS_Compress_G2::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"BLS_Compress_G2\";\n    j[\"curveType\"] = curveType.ToJSON();\n    j[\"g2_v\"] = uncompressed.first.first.ToJSON();\n    j[\"g2_w\"] = uncompressed.first.second.ToJSON();\n    j[\"g2_x\"] = uncompressed.second.first.ToJSON();\n    j[\"g2_y\"] = uncompressed.second.second.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}
{"text_input": "Generate BLS_G1_Add code for operation.cpp", "output": "std::string BLS_G1_Add::Name(void) const { return \"BLS_G1_Add\"; }std::string BLS_G1_Add::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: BLS_G1_Add\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"A X: \" << a.first.ToString() << std::endl;\n    ss << \"A Y: \" << a.second.ToString() << std::endl;\n    ss << \"B X: \" << b.first.ToString() << std::endl;\n    ss << \"B Y: \" << b.second.ToString() << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json BLS_G1_Add::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"BLS_G1_Add\";\n    j[\"curveType\"] = curveType.ToJSON();\n\n    j[\"a_x\"] = a.first.ToJSON();\n    j[\"a_y\"] = a.second.ToJSON();\n\n    j[\"b_x\"] = b.first.ToJSON();\n    j[\"b_y\"] = b.second.ToJSON();\n\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}
{"text_input": "Generate BLS_G1_Mul code for operation.cpp", "output": "std::string BLS_G1_Mul::Name(void) const { return \"BLS_G1_Mul\"; }std::string BLS_G1_Mul::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: BLS_G1_Mul\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"A X: \" << a.first.ToString() << std::endl;\n    ss << \"A Y: \" << a.second.ToString() << std::endl;\n    ss << \"B: \" << b.ToString() << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json BLS_G1_Mul::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"BLS_G1_Mul\";\n    j[\"curveType\"] = curveType.ToJSON();\n\n    j[\"a_x\"] = a.first.ToJSON();\n    j[\"a_y\"] = a.second.ToJSON();\n\n    j[\"b\"] = b.ToJSON();\n\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}
{"text_input": "Generate BLS_G1_IsEq code for operation.cpp", "output": "std::string BLS_G1_IsEq::Name(void) const { return \"BLS_G1_IsEq\"; }std::string BLS_G1_IsEq::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: BLS_G1_IsEq\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"A X: \" << a.first.ToString() << std::endl;\n    ss << \"A Y: \" << a.second.ToString() << std::endl;\n    ss << \"B X: \" << b.first.ToString() << std::endl;\n    ss << \"B Y: \" << b.second.ToString() << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json BLS_G1_IsEq::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"curveType\"] = curveType.ToJSON();\n\n    j[\"operation\"] = \"BLS_G1_IsEq\";\n    j[\"a_x\"] = a.first.ToJSON();\n    j[\"a_y\"] = a.second.ToJSON();\n\n    j[\"b_x\"] = b.first.ToJSON();\n    j[\"b_y\"] = b.second.ToJSON();\n\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}
{"text_input": "Generate BLS_G1_Neg code for operation.cpp", "output": "std::string BLS_G1_Neg::Name(void) const { return \"BLS_G1_Neg\"; }std::string BLS_G1_Neg::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: BLS_G1_Neg\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"A X: \" << a.first.ToString() << std::endl;\n    ss << \"A Y: \" << a.second.ToString() << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json BLS_G1_Neg::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"BLS_G1_Neg\";\n    j[\"curveType\"] = curveType.ToJSON();\n\n    j[\"a_x\"] = a.first.ToJSON();\n    j[\"a_y\"] = a.second.ToJSON();\n\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}
{"text_input": "Generate BLS_G2_Add code for operation.cpp", "output": "std::string BLS_G2_Add::Name(void) const { return \"BLS_G2_Add\"; }std::string BLS_G2_Add::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: BLS_G2_Add\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"A V:\" << a.first.first.ToString() << std::endl;\n    ss << \"A W:\" << a.first.second.ToString() << std::endl;\n    ss << \"A X:\" << a.second.first.ToString() << std::endl;\n    ss << \"A Y:\" << a.second.second.ToString() << std::endl;\n    ss << \"B V:\" << b.first.first.ToString() << std::endl;\n    ss << \"B W:\" << b.first.second.ToString() << std::endl;\n    ss << \"B X:\" << b.second.first.ToString() << std::endl;\n    ss << \"B Y:\" << b.second.second.ToString() << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json BLS_G2_Add::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"BLS_G2_Add\";\n    j[\"curveType\"] = curveType.ToJSON();\n\n    j[\"a_v\"] = a.first.first.ToJSON();\n    j[\"a_w\"] = a.first.second.ToJSON();\n    j[\"a_x\"] = a.second.first.ToJSON();\n    j[\"a_y\"] = a.second.second.ToJSON();\n\n    j[\"b_v\"] = b.first.first.ToJSON();\n    j[\"b_w\"] = b.first.second.ToJSON();\n    j[\"b_x\"] = b.second.first.ToJSON();\n    j[\"b_y\"] = b.second.second.ToJSON();\n\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}
{"text_input": "Generate BLS_G2_Mul code for operation.cpp", "output": "std::string BLS_G2_Mul::Name(void) const { return \"BLS_G2_Mul\"; }std::string BLS_G2_Mul::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: BLS_G2_Mul\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"A V:\" << a.first.first.ToString() << std::endl;\n    ss << \"A W:\" << a.first.second.ToString() << std::endl;\n    ss << \"A X:\" << a.second.first.ToString() << std::endl;\n    ss << \"A Y:\" << a.second.second.ToString() << std::endl;\n    ss << \"B: \" << b.ToString() << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json BLS_G2_Mul::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"BLS_G2_Mul\";\n    j[\"curveType\"] = curveType.ToJSON();\n\n    j[\"a_v\"] = a.first.first.ToJSON();\n    j[\"a_w\"] = a.first.second.ToJSON();\n    j[\"a_x\"] = a.second.first.ToJSON();\n    j[\"a_y\"] = a.second.second.ToJSON();\n\n    j[\"b\"] = b.ToJSON();\n\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}
{"text_input": "Generate BLS_G2_IsEq code for operation.cpp", "output": "std::string BLS_G2_IsEq::Name(void) const { return \"BLS_G2_IsEq\"; }std::string BLS_G2_IsEq::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: BLS_G2_IsEq\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"A V:\" << a.first.first.ToString() << std::endl;\n    ss << \"A W:\" << a.first.second.ToString() << std::endl;\n    ss << \"A X:\" << a.second.first.ToString() << std::endl;\n    ss << \"A Y:\" << a.second.second.ToString() << std::endl;\n    ss << \"B V:\" << b.first.first.ToString() << std::endl;\n    ss << \"B W:\" << b.first.second.ToString() << std::endl;\n    ss << \"B X:\" << b.second.first.ToString() << std::endl;\n    ss << \"B Y:\" << b.second.second.ToString() << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json BLS_G2_IsEq::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"BLS_G2_IsEq\";\n    j[\"curveType\"] = curveType.ToJSON();\n\n    j[\"a_v\"] = a.first.first.ToJSON();\n    j[\"a_w\"] = a.first.second.ToJSON();\n    j[\"a_x\"] = a.second.first.ToJSON();\n    j[\"a_y\"] = a.second.second.ToJSON();\n\n    j[\"b_v\"] = b.first.first.ToJSON();\n    j[\"b_w\"] = b.first.second.ToJSON();\n    j[\"b_x\"] = b.second.first.ToJSON();\n    j[\"b_y\"] = b.second.second.ToJSON();\n\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}
{"text_input": "Generate BLS_G2_Neg code for operation.cpp", "output": "std::string BLS_G2_Neg::Name(void) const { return \"BLS_G2_Neg\"; }std::string BLS_G2_Neg::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: BLS_G2_Neg\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"A V:\" << a.first.first.ToString() << std::endl;\n    ss << \"A W:\" << a.first.second.ToString() << std::endl;\n    ss << \"A X:\" << a.second.first.ToString() << std::endl;\n    ss << \"A Y:\" << a.second.second.ToString() << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json BLS_G2_Neg::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"BLS_G2_Neg\";\n    j[\"curveType\"] = curveType.ToJSON();\n\n    j[\"a_v\"] = a.first.first.ToJSON();\n    j[\"a_w\"] = a.first.second.ToJSON();\n    j[\"a_x\"] = a.second.first.ToJSON();\n    j[\"a_y\"] = a.second.second.ToJSON();\n\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}
{"text_input": "Generate BLS_G1_MultiExp code for operation.cpp", "output": "std::string BLS_G1_MultiExp::Name(void) const { return \"BLS_G1_MultiExp\"; }std::string BLS_G1_MultiExp::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: BLS_G1_MultiExp\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n\n    for (const auto& point_scalar : points_scalars.points_scalars) {\n        ss << \"    X: \" << point_scalar.first.first.ToString() << std::endl;\n        ss << \"    Y: \" << point_scalar.first.second.ToString() << std::endl;\n        ss << \"    scalar: \" << point_scalar.second.ToString() << std::endl;\n        ss << std::endl;\n    }\n\n    return ss.str();\n}\n\nnlohmann::json BLS_G1_MultiExp::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"curveType\"] = curveType.ToJSON();\n\n    nlohmann::json points_scalars_json = nlohmann::json::array();\n\n    for (const auto& point_scalar : points_scalars.points_scalars) {\n        nlohmann::json ps;\n        ps[\"x\"] = point_scalar.first.first.ToJSON();\n        ps[\"y\"] = point_scalar.first.second.ToJSON();\n        ps[\"scalar\"] = point_scalar.second.ToJSON();\n\n        points_scalars_json.push_back(ps);\n    }\n\n    j[\"points_scalars\"] = points_scalars_json;\n\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}
{"text_input": "Generate Misc code for operation.cpp", "output": "std::string Misc::Name(void) const { return \"Misc\"; }std::string Misc::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: Misc\" << std::endl;\n    ss << \"operation: \" << std::to_string(operation.Get()) << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json Misc::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = operation.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}
{"text_input": "Generate SR25519_Verify code for operation.cpp", "output": "std::string SR25519_Verify::Name(void) const { return \"ECDSA_Verify\"; }std::string SR25519_Verify::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: SR25519_Verify\" << std::endl;\n    ss << \"public key: \" << signature.pub.ToString() << std::endl;\n    ss << \"cleartext: \" << util::HexDump(cleartext.Get()) << std::endl;\n    ss << \"signature R: \" << signature.signature.first.ToString() << std::endl;\n    ss << \"signature S: \" << signature.signature.second.ToString() << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json SR25519_Verify::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"SR25519_Verify\";\n    j[\"pub\"] = signature.pub.ToJSON();\n    j[\"cleartext\"] = cleartext.ToJSON();\n    j[\"sig_r\"] = signature.signature.first.ToJSON();\n    j[\"sig_s\"] = signature.signature.second.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n"}
{"text_input": "Generate BignumCalc code for executor.h", "output": "class ExecutorBignumCalc : public ExecutorBase<component::Bignum, operation::BignumCalc> {    private:\n        std::optional<component::Bignum> callModule(std::shared_ptr<Module> module, operation::BignumCalc& op) const override;\n    protected:\n        std::optional<component::Bignum> modulo = std::nullopt;\n    public:\n        ExecutorBignumCalc(const uint64_t operationID, const std::map<uint64_t, std::shared_ptr<Module> >& modules, const Options& options);\n        void SetModulo(const std::string& modulo);\n};\n\n"}
{"text_input": "Generate BignumCalc_Mod_BLS12_381_R code for executor.h", "output": "class ExecutorBignumCalc_Mod_BLS12_381_R : public ExecutorBignumCalc {    public:\n        ExecutorBignumCalc_Mod_BLS12_381_R(const uint64_t operationID, const std::map<uint64_t, std::shared_ptr<Module> >& modules, const Options& options);\n        operation::BignumCalc getOpPostprocess(Datasource* parentDs, operation::BignumCalc op) const override;\n};\n\n"}
{"text_input": "Generate BignumCalc_Mod_BLS12_381_P code for executor.h", "output": "class ExecutorBignumCalc_Mod_BLS12_381_P : public ExecutorBignumCalc {    public:\n        ExecutorBignumCalc_Mod_BLS12_381_P(const uint64_t operationID, const std::map<uint64_t, std::shared_ptr<Module> >& modules, const Options& options);\n        operation::BignumCalc getOpPostprocess(Datasource* parentDs, operation::BignumCalc op) const override;\n};\n\n"}
{"text_input": "Generate BignumCalc_Mod_BLS12_377_R code for executor.h", "output": "class ExecutorBignumCalc_Mod_BLS12_377_R : public ExecutorBignumCalc {    public:\n        ExecutorBignumCalc_Mod_BLS12_377_R(const uint64_t operationID, const std::map<uint64_t, std::shared_ptr<Module> >& modules, const Options& options);\n        operation::BignumCalc getOpPostprocess(Datasource* parentDs, operation::BignumCalc op) const override;\n};\n\n"}
{"text_input": "Generate BignumCalc_Mod_BLS12_377_P code for executor.h", "output": "class ExecutorBignumCalc_Mod_BLS12_377_P : public ExecutorBignumCalc {    public:\n        ExecutorBignumCalc_Mod_BLS12_377_P(const uint64_t operationID, const std::map<uint64_t, std::shared_ptr<Module> >& modules, const Options& options);\n        operation::BignumCalc getOpPostprocess(Datasource* parentDs, operation::BignumCalc op) const override;\n};\n\n"}
{"text_input": "Generate BignumCalc_Mod_BN128_R code for executor.h", "output": "class ExecutorBignumCalc_Mod_BN128_R : public ExecutorBignumCalc {    public:\n        ExecutorBignumCalc_Mod_BN128_R(const uint64_t operationID, const std::map<uint64_t, std::shared_ptr<Module> >& modules, const Options& options);\n        operation::BignumCalc getOpPostprocess(Datasource* parentDs, operation::BignumCalc op) const override;\n};\n\n"}
{"text_input": "Generate BignumCalc_Mod_BN128_P code for executor.h", "output": "class ExecutorBignumCalc_Mod_BN128_P : public ExecutorBignumCalc {    public:\n        ExecutorBignumCalc_Mod_BN128_P(const uint64_t operationID, const std::map<uint64_t, std::shared_ptr<Module> >& modules, const Options& options);\n        operation::BignumCalc getOpPostprocess(Datasource* parentDs, operation::BignumCalc op) const override;\n};\n\n"}
{"text_input": "Generate BignumCalc_Mod_Vesta_R code for executor.h", "output": "class ExecutorBignumCalc_Mod_Vesta_R : public ExecutorBignumCalc {    public:\n        ExecutorBignumCalc_Mod_Vesta_R(const uint64_t operationID, const std::map<uint64_t, std::shared_ptr<Module> >& modules, const Options& options);\n        operation::BignumCalc getOpPostprocess(Datasource* parentDs, operation::BignumCalc op) const override;\n};\n\n"}
{"text_input": "Generate BignumCalc_Mod_Vesta_P code for executor.h", "output": "class ExecutorBignumCalc_Mod_Vesta_P : public ExecutorBignumCalc {    public:\n        ExecutorBignumCalc_Mod_Vesta_P(const uint64_t operationID, const std::map<uint64_t, std::shared_ptr<Module> >& modules, const Options& options);\n        operation::BignumCalc getOpPostprocess(Datasource* parentDs, operation::BignumCalc op) const override;\n};\n\n"}
{"text_input": "Generate BignumCalc_Mod_ED25519 code for executor.h", "output": "class ExecutorBignumCalc_Mod_ED25519 : public ExecutorBignumCalc {    public:\n        ExecutorBignumCalc_Mod_ED25519(const uint64_t operationID, const std::map<uint64_t, std::shared_ptr<Module> >& modules, const Options& options);\n        operation::BignumCalc getOpPostprocess(Datasource* parentDs, operation::BignumCalc op) const override;\n};\n\n"}
{"text_input": "Generate BignumCalc_Mod_Edwards_R code for executor.h", "output": "class ExecutorBignumCalc_Mod_Edwards_R : public ExecutorBignumCalc {    public:\n        ExecutorBignumCalc_Mod_Edwards_R(const uint64_t operationID, const std::map<uint64_t, std::shared_ptr<Module> >& modules, const Options& options);\n        operation::BignumCalc getOpPostprocess(Datasource* parentDs, operation::BignumCalc op) const override;\n};\n\n"}
{"text_input": "Generate BignumCalc_Mod_Edwards_P code for executor.h", "output": "class ExecutorBignumCalc_Mod_Edwards_P : public ExecutorBignumCalc {    public:\n        ExecutorBignumCalc_Mod_Edwards_P(const uint64_t operationID, const std::map<uint64_t, std::shared_ptr<Module> >& modules, const Options& options);\n        operation::BignumCalc getOpPostprocess(Datasource* parentDs, operation::BignumCalc op) const override;\n};\n\n"}
{"text_input": "Generate BignumCalc_Mod_Goldilocks code for executor.h", "output": "class ExecutorBignumCalc_Mod_Goldilocks : public ExecutorBignumCalc {    public:\n        ExecutorBignumCalc_Mod_Goldilocks(const uint64_t operationID, const std::map<uint64_t, std::shared_ptr<Module> >& modules, const Options& options);\n        operation::BignumCalc getOpPostprocess(Datasource* parentDs, operation::BignumCalc op) const override;\n};\n\n"}
{"text_input": "Generate BignumCalc_Mod_MNT4_R code for executor.h", "output": "class ExecutorBignumCalc_Mod_MNT4_R : public ExecutorBignumCalc {    public:\n        ExecutorBignumCalc_Mod_MNT4_R(const uint64_t operationID, const std::map<uint64_t, std::shared_ptr<Module> >& modules, const Options& options);\n        operation::BignumCalc getOpPostprocess(Datasource* parentDs, operation::BignumCalc op) const override;\n};\n\n"}
{"text_input": "Generate BignumCalc_Mod_MNT4_P code for executor.h", "output": "class ExecutorBignumCalc_Mod_MNT4_P : public ExecutorBignumCalc {    public:\n        ExecutorBignumCalc_Mod_MNT4_P(const uint64_t operationID, const std::map<uint64_t, std::shared_ptr<Module> >& modules, const Options& options);\n        operation::BignumCalc getOpPostprocess(Datasource* parentDs, operation::BignumCalc op) const override;\n};\n\n"}
{"text_input": "Generate BignumCalc_Mod_MNT6_R code for executor.h", "output": "class ExecutorBignumCalc_Mod_MNT6_R : public ExecutorBignumCalc {    public:\n        ExecutorBignumCalc_Mod_MNT6_R(const uint64_t operationID, const std::map<uint64_t, std::shared_ptr<Module> >& modules, const Options& options);\n        operation::BignumCalc getOpPostprocess(Datasource* parentDs, operation::BignumCalc op) const override;\n};\n\n"}
{"text_input": "Generate BignumCalc_Mod_MNT6_P code for executor.h", "output": "class ExecutorBignumCalc_Mod_MNT6_P : public ExecutorBignumCalc {    public:\n        ExecutorBignumCalc_Mod_MNT6_P(const uint64_t operationID, const std::map<uint64_t, std::shared_ptr<Module> >& modules, const Options& options);\n        operation::BignumCalc getOpPostprocess(Datasource* parentDs, operation::BignumCalc op) const override;\n};\n\n"}
{"text_input": "Generate BignumCalc_Mod_2Exp64 code for executor.h", "output": "class ExecutorBignumCalc_Mod_2Exp64 : public ExecutorBignumCalc {    public:\n        ExecutorBignumCalc_Mod_2Exp64(const uint64_t operationID, const std::map<uint64_t, std::shared_ptr<Module> >& modules, const Options& options);\n        operation::BignumCalc getOpPostprocess(Datasource* parentDs, operation::BignumCalc op) const override;\n};\n\n"}
{"text_input": "Generate BignumCalc_Mod_2Exp128 code for executor.h", "output": "class ExecutorBignumCalc_Mod_2Exp128 : public ExecutorBignumCalc {    public:\n        ExecutorBignumCalc_Mod_2Exp128(const uint64_t operationID, const std::map<uint64_t, std::shared_ptr<Module> >& modules, const Options& options);\n        operation::BignumCalc getOpPostprocess(Datasource* parentDs, operation::BignumCalc op) const override;\n};\n\n"}
{"text_input": "Generate BignumCalc_Mod_2Exp256 code for executor.h", "output": "class ExecutorBignumCalc_Mod_2Exp256 : public ExecutorBignumCalc {    public:\n        ExecutorBignumCalc_Mod_2Exp256(const uint64_t operationID, const std::map<uint64_t, std::shared_ptr<Module> >& modules, const Options& options);\n        operation::BignumCalc getOpPostprocess(Datasource* parentDs, operation::BignumCalc op) const override;\n};\n\n"}
{"text_input": "Generate BignumCalc_Mod_2Exp512 code for executor.h", "output": "class ExecutorBignumCalc_Mod_2Exp512 : public ExecutorBignumCalc {    public:\n        ExecutorBignumCalc_Mod_2Exp512(const uint64_t operationID, const std::map<uint64_t, std::shared_ptr<Module> >& modules, const Options& options);\n        operation::BignumCalc getOpPostprocess(Datasource* parentDs, operation::BignumCalc op) const override;\n};\n\n"}
{"text_input": "Generate BignumCalc_Mod_SECP256K1 code for executor.h", "output": "class ExecutorBignumCalc_Mod_SECP256K1 : public ExecutorBignumCalc {    public:\n        ExecutorBignumCalc_Mod_SECP256K1(const uint64_t operationID, const std::map<uint64_t, std::shared_ptr<Module> >& modules, const Options& options);\n        operation::BignumCalc getOpPostprocess(Datasource* parentDs, operation::BignumCalc op) const override;\n};\n\n"}
{"text_input": "Generate BignumCalc_Mod_SECP256K1_P code for executor.h", "output": "class ExecutorBignumCalc_Mod_SECP256K1_P : public ExecutorBignumCalc {    public:\n        ExecutorBignumCalc_Mod_SECP256K1_P(const uint64_t operationID, const std::map<uint64_t, std::shared_ptr<Module> >& modules, const Options& options);\n        operation::BignumCalc getOpPostprocess(Datasource* parentDs, operation::BignumCalc op) const override;\n};\n\n"}
{"text_input": "Generate BignumCalc_Fp2 code for executor.h", "output": "class ExecutorBignumCalc_Fp2 : public ExecutorBase<component::Fp2, operation::BignumCalc_Fp2> {    private:\n        std::optional<component::Fp2> callModule(std::shared_ptr<Module> module, operation::BignumCalc_Fp2& op) const override;\n    protected:\n        std::optional<component::Bignum> modulo = std::nullopt;\n    public:\n        ExecutorBignumCalc_Fp2(const uint64_t operationID, const std::map<uint64_t, std::shared_ptr<Module> >& modules, const Options& options);\n        void SetModulo(const std::string& modulo);\n};\n\n"}
{"text_input": "Generate BignumCalc_Fp12 code for executor.h", "output": "class ExecutorBignumCalc_Fp12 : public ExecutorBase<component::Fp12, operation::BignumCalc_Fp12> {    private:\n        std::optional<component::Fp12> callModule(std::shared_ptr<Module> module, operation::BignumCalc_Fp12& op) const override;\n    protected:\n        std::optional<component::Bignum> modulo = std::nullopt;\n    public:\n        ExecutorBignumCalc_Fp12(const uint64_t operationID, const std::map<uint64_t, std::shared_ptr<Module> >& modules, const Options& options);\n        void SetModulo(const std::string& modulo);\n};\n\n"}
{"text_input": "Generate Digest code for executor.h", "output": "using ExecutorDigest = ExecutorBase<component::Digest, operation::Digest>;\n"}
{"text_input": "Generate HMAC code for executor.h", "output": "using ExecutorHMAC = ExecutorBase<component::MAC, operation::HMAC>;\n"}
{"text_input": "Generate UMAC code for executor.h", "output": "using ExecutorUMAC = ExecutorBase<component::MAC, operation::UMAC>;\n"}
{"text_input": "Generate CMAC code for executor.h", "output": "using ExecutorCMAC = ExecutorBase<component::MAC, operation::CMAC>;\n"}
{"text_input": "Generate SymmetricEncrypt code for executor.h", "output": "using ExecutorSymmetricEncrypt = ExecutorBase<component::Ciphertext, operation::SymmetricEncrypt>;\n"}
{"text_input": "Generate SymmetricDecrypt code for executor.h", "output": "using ExecutorSymmetricDecrypt = ExecutorBase<component::Cleartext, operation::SymmetricDecrypt>;\n"}
{"text_input": "Generate KDF_SCRYPT code for executor.h", "output": "using ExecutorKDF_SCRYPT = ExecutorBase<component::Key, operation::KDF_SCRYPT>;\n"}
{"text_input": "Generate KDF_HKDF code for executor.h", "output": "using ExecutorKDF_HKDF = ExecutorBase<component::Key, operation::KDF_HKDF>;\n"}
{"text_input": "Generate KDF_TLS1_PRF code for executor.h", "output": "using ExecutorKDF_TLS1_PRF = ExecutorBase<component::Key, operation::KDF_TLS1_PRF>;\n"}
{"text_input": "Generate KDF_PBKDF code for executor.h", "output": "using ExecutorKDF_PBKDF = ExecutorBase<component::Key, operation::KDF_PBKDF>;\n"}
{"text_input": "Generate KDF_PBKDF1 code for executor.h", "output": "using ExecutorKDF_PBKDF1 = ExecutorBase<component::Key, operation::KDF_PBKDF1>;\n"}
{"text_input": "Generate KDF_PBKDF2 code for executor.h", "output": "using ExecutorKDF_PBKDF2 = ExecutorBase<component::Key, operation::KDF_PBKDF2>;\n"}
{"text_input": "Generate KDF_ARGON2 code for executor.h", "output": "using ExecutorKDF_ARGON2 = ExecutorBase<component::Key, operation::KDF_ARGON2>;\n"}
{"text_input": "Generate KDF_SSH code for executor.h", "output": "using ExecutorKDF_SSH = ExecutorBase<component::Key, operation::KDF_SSH>;\n"}
{"text_input": "Generate KDF_X963 code for executor.h", "output": "using ExecutorKDF_X963 = ExecutorBase<component::Key, operation::KDF_X963>;\n"}
{"text_input": "Generate KDF_BCRYPT code for executor.h", "output": "using ExecutorKDF_BCRYPT = ExecutorBase<component::Key, operation::KDF_BCRYPT>;\n"}
{"text_input": "Generate KDF_SP_800_108 code for executor.h", "output": "using ExecutorKDF_SP_800_108 = ExecutorBase<component::Key, operation::KDF_SP_800_108>;\n"}
{"text_input": "Generate KDF_SRTP code for executor.h", "output": "using ExecutorKDF_SRTP = ExecutorBase<component::Key3, operation::KDF_SRTP>;\n"}
{"text_input": "Generate KDF_SRTCP code for executor.h", "output": "using ExecutorKDF_SRTCP = ExecutorBase<component::Key3, operation::KDF_SRTCP>;\n"}
{"text_input": "Generate ECC_PrivateToPublic code for executor.h", "output": "using ExecutorECC_PrivateToPublic = ExecutorBase<component::ECC_PublicKey, operation::ECC_PrivateToPublic>;\n"}
{"text_input": "Generate ECC_ValidatePubkey code for executor.h", "output": "using ExecutorECC_ValidatePubkey = ExecutorBase<bool, operation::ECC_ValidatePubkey>;\n"}
{"text_input": "Generate ECC_GenerateKeyPair code for executor.h", "output": "using ExecutorECC_GenerateKeyPair = ExecutorBase<component::ECC_KeyPair, operation::ECC_GenerateKeyPair>;\n"}
{"text_input": "Generate ECCSI_Sign code for executor.h", "output": "using ExecutorECCSI_Sign = ExecutorBase<component::ECCSI_Signature, operation::ECCSI_Sign>;\n"}
{"text_input": "Generate ECDSA_Sign code for executor.h", "output": "using ExecutorECDSA_Sign = ExecutorBase<component::ECDSA_Signature, operation::ECDSA_Sign>;\n"}
{"text_input": "Generate ECGDSA_Sign code for executor.h", "output": "using ExecutorECGDSA_Sign = ExecutorBase<component::ECGDSA_Signature, operation::ECGDSA_Sign>;\n"}
{"text_input": "Generate ECRDSA_Sign code for executor.h", "output": "using ExecutorECRDSA_Sign = ExecutorBase<component::ECRDSA_Signature, operation::ECRDSA_Sign>;\n"}
{"text_input": "Generate Schnorr_Sign code for executor.h", "output": "using ExecutorSchnorr_Sign = ExecutorBase<component::Schnorr_Signature, operation::Schnorr_Sign>;\n"}
{"text_input": "Generate ECCSI_Verify code for executor.h", "output": "using ExecutorECCSI_Verify = ExecutorBase<bool, operation::ECCSI_Verify>;\n"}
{"text_input": "Generate ECDSA_Verify code for executor.h", "output": "using ExecutorECDSA_Verify = ExecutorBase<bool, operation::ECDSA_Verify>;\n"}
{"text_input": "Generate ECGDSA_Verify code for executor.h", "output": "using ExecutorECGDSA_Verify = ExecutorBase<bool, operation::ECGDSA_Verify>;\n"}
{"text_input": "Generate ECRDSA_Verify code for executor.h", "output": "using ExecutorECRDSA_Verify = ExecutorBase<bool, operation::ECRDSA_Verify>;\n"}
{"text_input": "Generate Schnorr_Verify code for executor.h", "output": "using ExecutorSchnorr_Verify = ExecutorBase<bool, operation::Schnorr_Verify>;\n"}
{"text_input": "Generate ECDSA_Recover code for executor.h", "output": "using ExecutorECDSA_Recover = ExecutorBase<component::ECC_PublicKey, operation::ECDSA_Recover>;\n"}
{"text_input": "Generate DSA_Verify code for executor.h", "output": "using ExecutorDSA_Verify = ExecutorBase<bool, operation::DSA_Verify>;\n"}
{"text_input": "Generate DSA_Sign code for executor.h", "output": "using ExecutorDSA_Sign = ExecutorBase<component::DSA_Signature, operation::DSA_Sign>;\n"}
{"text_input": "Generate DSA_GenerateParameters code for executor.h", "output": "using ExecutorDSA_GenerateParameters = ExecutorBase<component::DSA_Parameters, operation::DSA_GenerateParameters>;\n"}
{"text_input": "Generate DSA_PrivateToPublic code for executor.h", "output": "using ExecutorDSA_PrivateToPublic = ExecutorBase<component::Bignum, operation::DSA_PrivateToPublic>;\n"}
{"text_input": "Generate DSA_GenerateKeyPair code for executor.h", "output": "using ExecutorDSA_GenerateKeyPair = ExecutorBase<component::DSA_KeyPair, operation::DSA_GenerateKeyPair>;\n"}
{"text_input": "Generate ECDH_Derive code for executor.h", "output": "using ExecutorECDH_Derive = ExecutorBase<component::Secret, operation::ECDH_Derive>;\n"}
{"text_input": "Generate ECIES_Encrypt code for executor.h", "output": "using ExecutorECIES_Encrypt = ExecutorBase<component::Ciphertext, operation::ECIES_Encrypt>;\n"}
{"text_input": "Generate ECIES_Decrypt code for executor.h", "output": "using ExecutorECIES_Decrypt = ExecutorBase<component::Cleartext, operation::ECIES_Decrypt>;\n"}
{"text_input": "Generate ECC_Point_Add code for executor.h", "output": "using ExecutorECC_Point_Add = ExecutorBase<component::ECC_Point, operation::ECC_Point_Add>;\n"}
{"text_input": "Generate ECC_Point_Sub code for executor.h", "output": "using ExecutorECC_Point_Sub = ExecutorBase<component::ECC_Point, operation::ECC_Point_Sub>;\n"}
{"text_input": "Generate ECC_Point_Mul code for executor.h", "output": "using ExecutorECC_Point_Mul = ExecutorBase<component::ECC_Point, operation::ECC_Point_Mul>;\n"}
{"text_input": "Generate ECC_Point_Neg code for executor.h", "output": "using ExecutorECC_Point_Neg = ExecutorBase<component::ECC_Point, operation::ECC_Point_Neg>;\n"}
{"text_input": "Generate ECC_Point_Dbl code for executor.h", "output": "using ExecutorECC_Point_Dbl = ExecutorBase<component::ECC_Point, operation::ECC_Point_Dbl>;\n"}
{"text_input": "Generate ECC_Point_Cmp code for executor.h", "output": "using ExecutorECC_Point_Cmp = ExecutorBase<bool, operation::ECC_Point_Cmp>;\n"}
{"text_input": "Generate DH_GenerateKeyPair code for executor.h", "output": "using ExecutorDH_GenerateKeyPair = ExecutorBase<component::DH_KeyPair, operation::DH_GenerateKeyPair>;\n"}
{"text_input": "Generate DH_Derive code for executor.h", "output": "using ExecutorDH_Derive = ExecutorBase<component::Bignum, operation::DH_Derive>;\n"}
{"text_input": "Generate BLS_PrivateToPublic code for executor.h", "output": "using ExecutorBLS_PrivateToPublic = ExecutorBase<component::BLS_PublicKey, operation::BLS_PrivateToPublic>;\n"}
{"text_input": "Generate BLS_PrivateToPublic_G2 code for executor.h", "output": "using ExecutorBLS_PrivateToPublic_G2 = ExecutorBase<component::G2, operation::BLS_PrivateToPublic_G2>;\n"}
{"text_input": "Generate BLS_Sign code for executor.h", "output": "using ExecutorBLS_Sign = ExecutorBase<component::BLS_Signature, operation::BLS_Sign>;\n"}
{"text_input": "Generate BLS_Verify code for executor.h", "output": "using ExecutorBLS_Verify = ExecutorBase<bool, operation::BLS_Verify>;\n"}
{"text_input": "Generate BLS_BatchSign code for executor.h", "output": "using ExecutorBLS_BatchSign = ExecutorBase<component::BLS_BatchSignature, operation::BLS_BatchSign>;\n"}
{"text_input": "Generate BLS_BatchVerify code for executor.h", "output": "using ExecutorBLS_BatchVerify = ExecutorBase<bool, operation::BLS_BatchVerify>;\n"}
{"text_input": "Generate BLS_Aggregate_G1 code for executor.h", "output": "using ExecutorBLS_Aggregate_G1 = ExecutorBase<component::G1, operation::BLS_Aggregate_G1>;\n"}
{"text_input": "Generate BLS_Aggregate_G2 code for executor.h", "output": "using ExecutorBLS_Aggregate_G2 = ExecutorBase<component::G2, operation::BLS_Aggregate_G2>;\n"}
{"text_input": "Generate BLS_Pairing code for executor.h", "output": "using ExecutorBLS_Pairing = ExecutorBase<component::Fp12, operation::BLS_Pairing>;\n"}
{"text_input": "Generate BLS_MillerLoop code for executor.h", "output": "using ExecutorBLS_MillerLoop = ExecutorBase<component::Fp12, operation::BLS_MillerLoop>;\n"}
{"text_input": "Generate BLS_FinalExp code for executor.h", "output": "using ExecutorBLS_FinalExp = ExecutorBase<component::Fp12, operation::BLS_FinalExp>;\n"}
{"text_input": "Generate BLS_HashToG1 code for executor.h", "output": "using ExecutorBLS_HashToG1 = ExecutorBase<component::G1, operation::BLS_HashToG1>;\n"}
{"text_input": "Generate BLS_HashToG2 code for executor.h", "output": "using ExecutorBLS_HashToG2 = ExecutorBase<component::G2, operation::BLS_HashToG2>;\n"}
{"text_input": "Generate BLS_MapToG1 code for executor.h", "output": "using ExecutorBLS_MapToG1 = ExecutorBase<component::G1, operation::BLS_MapToG1>;\n"}
{"text_input": "Generate BLS_MapToG2 code for executor.h", "output": "using ExecutorBLS_MapToG2 = ExecutorBase<component::G2, operation::BLS_MapToG2>;\n"}
{"text_input": "Generate BLS_IsG1OnCurve code for executor.h", "output": "using ExecutorBLS_IsG1OnCurve = ExecutorBase<bool, operation::BLS_IsG1OnCurve>;\n"}
{"text_input": "Generate BLS_IsG2OnCurve code for executor.h", "output": "using ExecutorBLS_IsG2OnCurve = ExecutorBase<bool, operation::BLS_IsG2OnCurve>;\n"}
{"text_input": "Generate BLS_GenerateKeyPair code for executor.h", "output": "using ExecutorBLS_GenerateKeyPair = ExecutorBase<component::BLS_KeyPair, operation::BLS_GenerateKeyPair>;\n"}
{"text_input": "Generate BLS_Decompress_G1 code for executor.h", "output": "using ExecutorBLS_Decompress_G1 = ExecutorBase<component::G1, operation::BLS_Decompress_G1>;\n"}
{"text_input": "Generate BLS_Compress_G1 code for executor.h", "output": "using ExecutorBLS_Compress_G1 = ExecutorBase<component::Bignum, operation::BLS_Compress_G1>;\n"}
{"text_input": "Generate BLS_Decompress_G2 code for executor.h", "output": "using ExecutorBLS_Decompress_G2 = ExecutorBase<component::G2, operation::BLS_Decompress_G2>;\n"}
{"text_input": "Generate BLS_Compress_G2 code for executor.h", "output": "using ExecutorBLS_Compress_G2 = ExecutorBase<component::G1, operation::BLS_Compress_G2>;\n"}
{"text_input": "Generate BLS_G1_Add code for executor.h", "output": "using ExecutorBLS_G1_Add = ExecutorBase<component::G1, operation::BLS_G1_Add>;\n"}
{"text_input": "Generate BLS_G1_Mul code for executor.h", "output": "using ExecutorBLS_G1_Mul = ExecutorBase<component::G1, operation::BLS_G1_Mul>;\n"}
{"text_input": "Generate BLS_G1_IsEq code for executor.h", "output": "using ExecutorBLS_G1_IsEq = ExecutorBase<bool, operation::BLS_G1_IsEq>;\n"}
{"text_input": "Generate BLS_G1_Neg code for executor.h", "output": "using ExecutorBLS_G1_Neg = ExecutorBase<component::G1, operation::BLS_G1_Neg>;\n"}
{"text_input": "Generate BLS_G2_Add code for executor.h", "output": "using ExecutorBLS_G2_Add = ExecutorBase<component::G2, operation::BLS_G2_Add>;\n"}
{"text_input": "Generate BLS_G2_Mul code for executor.h", "output": "using ExecutorBLS_G2_Mul = ExecutorBase<component::G2, operation::BLS_G2_Mul>;\n"}
{"text_input": "Generate BLS_G2_IsEq code for executor.h", "output": "using ExecutorBLS_G2_IsEq = ExecutorBase<bool, operation::BLS_G2_IsEq>;\n"}
{"text_input": "Generate BLS_G2_Neg code for executor.h", "output": "using ExecutorBLS_G2_Neg = ExecutorBase<component::G2, operation::BLS_G2_Neg>;\n"}
{"text_input": "Generate BLS_G1_MultiExp code for executor.h", "output": "using ExecutorBLS_G1_MultiExp = ExecutorBase<component::G1, operation::BLS_G1_MultiExp>;\n"}
{"text_input": "Generate Misc code for executor.h", "output": "using ExecutorMisc = ExecutorBase<Buffer, operation::Misc>;\n"}
{"text_input": "Generate SR25519_Verify code for executor.h", "output": "using ExecutorSR25519_Verify = ExecutorBase<bool, operation::SR25519_Verify>;\n"}
{"text_input": "Generate Digest code for executor.cpp", "output": "/* Specialization for operation::Digest */template<> void ExecutorBase<component::Digest, operation::Digest>::postprocess(std::shared_ptr<Module> module, operation::Digest& op, const ExecutorBase<component::Digest, operation::Digest>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n\n    if ( result.second != std::nullopt ) {\n        fuzzing::memory::memory_test_msan(result.second->GetPtr(), result.second->GetSize());\n    }\n}\n\ntemplate<> std::optional<component::Digest> ExecutorBase<component::Digest, operation::Digest>::callModule(std::shared_ptr<Module> module, operation::Digest& op) const {\n    RETURN_IF_DISABLED(options.digests, op.digestType.Get());\n\n    return module->OpDigest(op);\n}\n\n\ntemplate class ExecutorBase<component::Digest, operation::Digest>;"}
{"text_input": "Generate HMAC code for executor.cpp", "output": "/* Specialization for operation::HMAC */template<> void ExecutorBase<component::MAC, operation::HMAC>::postprocess(std::shared_ptr<Module> module, operation::HMAC& op, const ExecutorBase<component::MAC, operation::HMAC>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n\n    if ( result.second != std::nullopt ) {\n        fuzzing::memory::memory_test_msan(result.second->GetPtr(), result.second->GetSize());\n    }\n}\n\ntemplate<> std::optional<component::MAC> ExecutorBase<component::MAC, operation::HMAC>::callModule(std::shared_ptr<Module> module, operation::HMAC& op) const {\n    RETURN_IF_DISABLED(options.digests, op.digestType.Get());\n\n    return module->OpHMAC(op);\n}\n\ntemplate <>\nbool ExecutorBase<component::MAC, operation::HMAC>::dontCompare(const operation::HMAC& operation) const {\n    if ( operation.cipher.cipherType.Get() == CF_CIPHER(\"DES_EDE3_WRAP\") ) return true;\n\n    return false;\n}\n\n\ntemplate class ExecutorBase<component::MAC, operation::HMAC>;"}
{"text_input": "Generate UMAC code for executor.cpp", "output": "/* Specialization for operation::UMAC */template<> void ExecutorBase<component::MAC, operation::UMAC>::postprocess(std::shared_ptr<Module> module, operation::UMAC& op, const ExecutorBase<component::MAC, operation::UMAC>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n\n    if ( result.second != std::nullopt ) {\n        fuzzing::memory::memory_test_msan(result.second->GetPtr(), result.second->GetSize());\n    }\n}\n\ntemplate<> std::optional<component::MAC> ExecutorBase<component::MAC, operation::UMAC>::callModule(std::shared_ptr<Module> module, operation::UMAC& op) const {\n    return module->OpUMAC(op);\n}\n\n\ntemplate class ExecutorBase<component::MAC, operation::UMAC>;"}
{"text_input": "Generate CMAC code for executor.cpp", "output": "/* Specialization for operation::CMAC */template<> void ExecutorBase<component::MAC, operation::CMAC>::postprocess(std::shared_ptr<Module> module, operation::CMAC& op, const ExecutorBase<component::MAC, operation::CMAC>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n\n    if ( result.second != std::nullopt ) {\n        fuzzing::memory::memory_test_msan(result.second->GetPtr(), result.second->GetSize());\n    }\n}\n\ntemplate<> std::optional<component::MAC> ExecutorBase<component::MAC, operation::CMAC>::callModule(std::shared_ptr<Module> module, operation::CMAC& op) const {\n    RETURN_IF_DISABLED(options.ciphers, op.cipher.cipherType.Get());\n\n    return module->OpCMAC(op);\n}\n\ntemplate <>\nbool ExecutorBase<component::MAC, operation::CMAC>::dontCompare(const operation::CMAC& operation) const {\n    if ( operation.cipher.cipherType.Get() == CF_CIPHER(\"DES_EDE3_WRAP\") ) return true;\n\n    return false;\n}\n\n\ntemplate class ExecutorBase<component::MAC, operation::CMAC>;"}
{"text_input": "Generate SymmetricEncrypt code for executor.cpp", "output": "/* Specialization for operation::SymmetricEncrypt */template<> void ExecutorBase<component::Ciphertext, operation::SymmetricEncrypt>::postprocess(std::shared_ptr<Module> module, operation::SymmetricEncrypt& op, const ExecutorBase<component::Ciphertext, operation::SymmetricEncrypt>::ResultPair& result) const {\n    if ( options.noDecrypt == true ) {\n        return;\n    }\n\n    if ( result.second != std::nullopt ) {\n        fuzzing::memory::memory_test_msan(result.second->ciphertext.GetPtr(), result.second->ciphertext.GetSize());\n        if ( result.second->tag != std::nullopt ) {\n            fuzzing::memory::memory_test_msan(result.second->tag->GetPtr(), result.second->tag->GetSize());\n        }\n    }\n\n    if ( op.cleartext.GetSize() > 0 && result.second != std::nullopt && result.second->ciphertext.GetSize() > 0 ) {\n        using fuzzing::datasource::ID;\n\n        bool tryDecrypt = true;\n\n        if ( module->ID == CF_MODULE(\"OpenSSL\") ) {\n            switch ( op.cipher.cipherType.Get() ) {\n                case    ID(\"Cryptofuzz/Cipher/AES_128_OCB\"):\n                case    ID(\"Cryptofuzz/Cipher/AES_256_OCB\"):\n                    tryDecrypt = false;\n                    break;\n                case    ID(\"Cryptofuzz/Cipher/AES_128_GCM\"):\n                case    ID(\"Cryptofuzz/Cipher/AES_192_GCM\"):\n                case    ID(\"Cryptofuzz/Cipher/AES_256_GCM\"):\n                case    ID(\"Cryptofuzz/Cipher/AES_128_CCM\"):\n                case    ID(\"Cryptofuzz/Cipher/AES_192_CCM\"):\n                case    ID(\"Cryptofuzz/Cipher/AES_256_CCM\"):\n                case    ID(\"Cryptofuzz/Cipher/ARIA_128_CCM\"):\n                case    ID(\"Cryptofuzz/Cipher/ARIA_192_CCM\"):\n                case    ID(\"Cryptofuzz/Cipher/ARIA_256_CCM\"):\n                case    ID(\"Cryptofuzz/Cipher/ARIA_128_GCM\"):\n                case    ID(\"Cryptofuzz/Cipher/ARIA_192_GCM\"):\n                case    ID(\"Cryptofuzz/Cipher/ARIA_256_GCM\"):\n                    if ( op.tagSize == std::nullopt ) {\n                        /* OpenSSL fails to decrypt its own CCM and GCM ciphertexts if\n                         * a tag is not included\n                         */\n                        tryDecrypt = false;\n                    }\n                    break;\n            }\n        }\n\n        if ( tryDecrypt == true ) {\n            /* Try to decrypt the encrypted data */\n\n            /* Construct a SymmetricDecrypt instance with the SymmetricEncrypt instance */\n            auto opDecrypt = operation::SymmetricDecrypt(\n                    /* The SymmetricEncrypt instance */\n                    op,\n\n                    /* The ciphertext generated by OpSymmetricEncrypt */\n                    *(result.second),\n\n                    /* The size of the output buffer that OpSymmetricDecrypt() must use. */\n                    op.cleartext.GetSize() + 32,\n\n                    op.aad,\n\n                    /* Empty modifier */\n                    {});\n\n            const auto cleartext = module->OpSymmetricDecrypt(opDecrypt);\n\n            if ( cleartext == std::nullopt ) {\n                /* Decryption failed, OpSymmetricDecrypt() returned std::nullopt */\n                printf(\"Cannot decrypt ciphertext\\n\\n\");\n                printf(\"Operation:\\n%s\\n\", op.ToString().c_str());\n                printf(\"Ciphertext: %s\\n\", util::HexDump(result.second->ciphertext.Get()).c_str());\n                printf(\"Tag: %s\\n\", result.second->tag ? util::HexDump(result.second->tag->Get()).c_str() : \"nullopt\");\n                abort(\n                        {module->name},\n                        op.Name(),\n                        op.GetAlgorithmString(),\n                        \"cannot decrypt ciphertext\"\n                );\n            } else if ( cleartext->Get() != op.cleartext.Get() ) {\n                /* Decryption ostensibly succeeded, but the cleartext returned by OpSymmetricDecrypt()\n                 * does not match to original cleartext */\n\n                printf(\"Cannot decrypt ciphertext (but decryption ostensibly succeeded)\\n\\n\");\n                printf(\"Operation:\\n%s\\n\", op.ToString().c_str());\n                printf(\"Ciphertext: %s\\n\", util::HexDump(result.second->ciphertext.Get()).c_str());\n                printf(\"Tag: %s\\n\", result.second->tag ? util::HexDump(result.second->tag->Get()).c_str() : \"nullopt\");\n                printf(\"Purported cleartext: %s\\n\", util::HexDump(cleartext->Get()).c_str());\n                abort(\n                        {module->name},\n                        op.Name(),\n                        op.GetAlgorithmString(),\n                        \"cannot decrypt ciphertext\"\n                );\n            }\n        }\n    }\n}\n\ntemplate<> std::optional<component::Ciphertext> ExecutorBase<component::Ciphertext, operation::SymmetricEncrypt>::callModule(std::shared_ptr<Module> module, operation::SymmetricEncrypt& op) const {\n    RETURN_IF_DISABLED(options.ciphers , op.cipher.cipherType.Get());\n\n    return module->OpSymmetricEncrypt(op);\n}\n\ntemplate <>\nbool ExecutorBase<component::Ciphertext, operation::SymmetricEncrypt>::dontCompare(const operation::SymmetricEncrypt& operation) const {\n    if ( operation.cipher.cipherType.Get() == CF_CIPHER(\"DES_EDE3_WRAP\") ) { return true; }\n\n    return false;\n}\n\n\ntemplate class ExecutorBase<component::Ciphertext, operation::SymmetricEncrypt>;"}
{"text_input": "Generate SymmetricDecrypt code for executor.cpp", "output": "/* Specialization for operation::SymmetricDecrypt */template<> void ExecutorBase<component::MAC, operation::SymmetricDecrypt>::postprocess(std::shared_ptr<Module> module, operation::SymmetricDecrypt& op, const ExecutorBase<component::MAC, operation::SymmetricDecrypt>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n\n    if ( result.second != std::nullopt ) {\n        fuzzing::memory::memory_test_msan(result.second->GetPtr(), result.second->GetSize());\n    }\n}\n\ntemplate<> std::optional<component::MAC> ExecutorBase<component::MAC, operation::SymmetricDecrypt>::callModule(std::shared_ptr<Module> module, operation::SymmetricDecrypt& op) const {\n    RETURN_IF_DISABLED(options.ciphers , op.cipher.cipherType.Get());\n\n    return module->OpSymmetricDecrypt(op);\n}\n\ntemplate <>\nbool ExecutorBase<component::Cleartext, operation::SymmetricDecrypt>::dontCompare(const operation::SymmetricDecrypt& operation) const {\n    if ( operation.cipher.cipherType.Get() == CF_CIPHER(\"DES_EDE3_WRAP\") ) return true;\n\n    return false;\n}\n\n\ntemplate class ExecutorBase<component::Cleartext, operation::SymmetricDecrypt>;"}
{"text_input": "Generate KDF_SCRYPT code for executor.cpp", "output": "/* Specialization for operation::KDF_SCRYPT */template<> void ExecutorBase<component::Key, operation::KDF_SCRYPT>::postprocess(std::shared_ptr<Module> module, operation::KDF_SCRYPT& op, const ExecutorBase<component::Key, operation::KDF_SCRYPT>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n\n    if ( result.second != std::nullopt ) {\n        fuzzing::memory::memory_test_msan(result.second->GetPtr(), result.second->GetSize());\n    }\n}\n\ntemplate<> std::optional<component::Key> ExecutorBase<component::Key, operation::KDF_SCRYPT>::callModule(std::shared_ptr<Module> module, operation::KDF_SCRYPT& op) const {\n    return module->OpKDF_SCRYPT(op);\n}\n\n\ntemplate class ExecutorBase<component::Key, operation::KDF_SCRYPT>;"}
{"text_input": "Generate KDF_HKDF code for executor.cpp", "output": "/* Specialization for operation::KDF_HKDF */template<> void ExecutorBase<component::Key, operation::KDF_HKDF>::postprocess(std::shared_ptr<Module> module, operation::KDF_HKDF& op, const ExecutorBase<component::Key, operation::KDF_HKDF>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n\n    if ( result.second != std::nullopt ) {\n        fuzzing::memory::memory_test_msan(result.second->GetPtr(), result.second->GetSize());\n    }\n}\n\ntemplate<> std::optional<component::Key> ExecutorBase<component::Key, operation::KDF_HKDF>::callModule(std::shared_ptr<Module> module, operation::KDF_HKDF& op) const {\n    RETURN_IF_DISABLED(options.digests, op.digestType.Get());\n\n    return module->OpKDF_HKDF(op);\n}\n\n\ntemplate class ExecutorBase<component::Key, operation::KDF_HKDF>;"}
{"text_input": "Generate KDF_PBKDF code for executor.cpp", "output": "/* Specialization for operation::KDF_PBKDF */template<> void ExecutorBase<component::Key, operation::KDF_PBKDF>::postprocess(std::shared_ptr<Module> module, operation::KDF_PBKDF& op, const ExecutorBase<component::Key, operation::KDF_PBKDF>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n\n    if ( result.second != std::nullopt ) {\n        fuzzing::memory::memory_test_msan(result.second->GetPtr(), result.second->GetSize());\n    }\n}\n\ntemplate<> std::optional<component::Key> ExecutorBase<component::Key, operation::KDF_PBKDF>::callModule(std::shared_ptr<Module> module, operation::KDF_PBKDF& op) const {\n    RETURN_IF_DISABLED(options.digests, op.digestType.Get());\n\n    return module->OpKDF_PBKDF(op);\n}\n\n\ntemplate class ExecutorBase<component::Key, operation::KDF_PBKDF>;"}
{"text_input": "Generate KDF_PBKDF1 code for executor.cpp", "output": "/* Specialization for operation::KDF_PBKDF1 */template<> void ExecutorBase<component::Key, operation::KDF_PBKDF1>::postprocess(std::shared_ptr<Module> module, operation::KDF_PBKDF1& op, const ExecutorBase<component::Key, operation::KDF_PBKDF1>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n\n    if ( result.second != std::nullopt ) {\n        fuzzing::memory::memory_test_msan(result.second->GetPtr(), result.second->GetSize());\n    }\n}\n\ntemplate<> std::optional<component::Key> ExecutorBase<component::Key, operation::KDF_PBKDF1>::callModule(std::shared_ptr<Module> module, operation::KDF_PBKDF1& op) const {\n    RETURN_IF_DISABLED(options.digests, op.digestType.Get());\n\n    return module->OpKDF_PBKDF1(op);\n}\n\n\ntemplate class ExecutorBase<component::Key, operation::KDF_PBKDF1>;"}
{"text_input": "Generate KDF_PBKDF2 code for executor.cpp", "output": "/* Specialization for operation::KDF_PBKDF2 */template<> void ExecutorBase<component::Key, operation::KDF_PBKDF2>::postprocess(std::shared_ptr<Module> module, operation::KDF_PBKDF2& op, const ExecutorBase<component::Key, operation::KDF_PBKDF2>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n\n    if ( result.second != std::nullopt ) {\n        fuzzing::memory::memory_test_msan(result.second->GetPtr(), result.second->GetSize());\n    }\n}\n\ntemplate<> std::optional<component::Key> ExecutorBase<component::Key, operation::KDF_PBKDF2>::callModule(std::shared_ptr<Module> module, operation::KDF_PBKDF2& op) const {\n    RETURN_IF_DISABLED(options.digests, op.digestType.Get());\n\n    return module->OpKDF_PBKDF2(op);\n}\n\n\ntemplate class ExecutorBase<component::Key, operation::KDF_PBKDF2>;"}
{"text_input": "Generate KDF_ARGON2 code for executor.cpp", "output": "/* Specialization for operation::KDF_ARGON2 */template<> void ExecutorBase<component::Key, operation::KDF_ARGON2>::postprocess(std::shared_ptr<Module> module, operation::KDF_ARGON2& op, const ExecutorBase<component::Key, operation::KDF_ARGON2>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n\n    if ( result.second != std::nullopt ) {\n        fuzzing::memory::memory_test_msan(result.second->GetPtr(), result.second->GetSize());\n    }\n}\n\ntemplate<> std::optional<component::Key> ExecutorBase<component::Key, operation::KDF_ARGON2>::callModule(std::shared_ptr<Module> module, operation::KDF_ARGON2& op) const {\n    return module->OpKDF_ARGON2(op);\n}\n\n\ntemplate class ExecutorBase<component::Key, operation::KDF_ARGON2>;"}
{"text_input": "Generate KDF_SSH code for executor.cpp", "output": "/* Specialization for operation::KDF_SSH */template<> void ExecutorBase<component::Key, operation::KDF_SSH>::postprocess(std::shared_ptr<Module> module, operation::KDF_SSH& op, const ExecutorBase<component::Key, operation::KDF_SSH>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n\n    if ( result.second != std::nullopt ) {\n        fuzzing::memory::memory_test_msan(result.second->GetPtr(), result.second->GetSize());\n    }\n}\n\ntemplate<> std::optional<component::Key> ExecutorBase<component::Key, operation::KDF_SSH>::callModule(std::shared_ptr<Module> module, operation::KDF_SSH& op) const {\n    RETURN_IF_DISABLED(options.digests, op.digestType.Get());\n\n    return module->OpKDF_SSH(op);\n}\n\n\ntemplate class ExecutorBase<component::Key, operation::KDF_SSH>;"}
{"text_input": "Generate KDF_TLS1_PRF code for executor.cpp", "output": "/* Specialization for operation::KDF_TLS1_PRF */template<> void ExecutorBase<component::Key, operation::KDF_TLS1_PRF>::postprocess(std::shared_ptr<Module> module, operation::KDF_TLS1_PRF& op, const ExecutorBase<component::Key, operation::KDF_TLS1_PRF>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n\n    if ( result.second != std::nullopt ) {\n        fuzzing::memory::memory_test_msan(result.second->GetPtr(), result.second->GetSize());\n    }\n}\n\ntemplate<> std::optional<component::Key> ExecutorBase<component::Key, operation::KDF_TLS1_PRF>::callModule(std::shared_ptr<Module> module, operation::KDF_TLS1_PRF& op) const {\n    RETURN_IF_DISABLED(options.digests, op.digestType.Get());\n\n    return module->OpKDF_TLS1_PRF(op);\n}\n\n\ntemplate class ExecutorBase<component::Key, operation::KDF_TLS1_PRF>;"}
{"text_input": "Generate KDF_X963 code for executor.cpp", "output": "/* Specialization for operation::KDF_X963 */template<> void ExecutorBase<component::Key, operation::KDF_X963>::postprocess(std::shared_ptr<Module> module, operation::KDF_X963& op, const ExecutorBase<component::Key, operation::KDF_X963>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n\n    if ( result.second != std::nullopt ) {\n        fuzzing::memory::memory_test_msan(result.second->GetPtr(), result.second->GetSize());\n    }\n}\n\ntemplate<> std::optional<component::Key> ExecutorBase<component::Key, operation::KDF_X963>::callModule(std::shared_ptr<Module> module, operation::KDF_X963& op) const {\n    RETURN_IF_DISABLED(options.digests, op.digestType.Get());\n\n    return module->OpKDF_X963(op);\n}\n\n\ntemplate class ExecutorBase<component::Key, operation::KDF_X963>;"}
{"text_input": "Generate KDF_BCRYPT code for executor.cpp", "output": "/* Specialization for operation::KDF_BCRYPT */template<> void ExecutorBase<component::Key, operation::KDF_BCRYPT>::postprocess(std::shared_ptr<Module> module, operation::KDF_BCRYPT& op, const ExecutorBase<component::Key, operation::KDF_BCRYPT>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n\n    if ( result.second != std::nullopt ) {\n        fuzzing::memory::memory_test_msan(result.second->GetPtr(), result.second->GetSize());\n    }\n}\n\ntemplate<> std::optional<component::Key> ExecutorBase<component::Key, operation::KDF_BCRYPT>::callModule(std::shared_ptr<Module> module, operation::KDF_BCRYPT& op) const {\n    RETURN_IF_DISABLED(options.digests, op.digestType.Get());\n\n    return module->OpKDF_BCRYPT(op);\n}\n\n\ntemplate class ExecutorBase<component::Key, operation::KDF_BCRYPT>;"}
{"text_input": "Generate KDF_SP_800_108 code for executor.cpp", "output": "/* Specialization for operation::KDF_SP_800_108 */template<> void ExecutorBase<component::Key, operation::KDF_SP_800_108>::postprocess(std::shared_ptr<Module> module, operation::KDF_SP_800_108& op, const ExecutorBase<component::Key, operation::KDF_SP_800_108>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n\n    if ( result.second != std::nullopt ) {\n        fuzzing::memory::memory_test_msan(result.second->GetPtr(), result.second->GetSize());\n    }\n}\n\ntemplate<> std::optional<component::Key> ExecutorBase<component::Key, operation::KDF_SP_800_108>::callModule(std::shared_ptr<Module> module, operation::KDF_SP_800_108& op) const {\n    if ( op.mech.mode == true ) {\n        RETURN_IF_DISABLED(options.digests, op.mech.type.Get());\n    }\n\n    return module->OpKDF_SP_800_108(op);\n}\n\n\ntemplate class ExecutorBase<component::Key, operation::KDF_SP_800_108>;"}
{"text_input": "Generate KDF_SRTP code for executor.cpp", "output": "/* Specialization for operation::KDF_SRTP */template<> void ExecutorBase<component::Key3, operation::KDF_SRTP>::postprocess(std::shared_ptr<Module> module, operation::KDF_SRTP& op, const ExecutorBase<component::Key3, operation::KDF_SRTP>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n    (void)result;\n}\n\ntemplate<> std::optional<component::Key3> ExecutorBase<component::Key3, operation::KDF_SRTP>::callModule(std::shared_ptr<Module> module, operation::KDF_SRTP& op) const {\n    return module->OpKDF_SRTP(op);\n}\n\n\ntemplate class ExecutorBase<component::Key3, operation::KDF_SRTP>;"}
{"text_input": "Generate KDF_SRTCP code for executor.cpp", "output": "/* Specialization for operation::KDF_SRTCP */template<> void ExecutorBase<component::Key3, operation::KDF_SRTCP>::postprocess(std::shared_ptr<Module> module, operation::KDF_SRTCP& op, const ExecutorBase<component::Key3, operation::KDF_SRTCP>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n    (void)result;\n}\n\ntemplate<> std::optional<component::Key3> ExecutorBase<component::Key3, operation::KDF_SRTCP>::callModule(std::shared_ptr<Module> module, operation::KDF_SRTCP& op) const {\n    return module->OpKDF_SRTCP(op);\n}\n\n\ntemplate class ExecutorBase<component::Key3, operation::KDF_SRTCP>;"}
{"text_input": "Generate ECC_PrivateToPublic code for executor.cpp", "output": "/* Specialization for operation::ECC_PrivateToPublic */template<> void ExecutorBase<component::ECC_PublicKey, operation::ECC_PrivateToPublic>::postprocess(std::shared_ptr<Module> module, operation::ECC_PrivateToPublic& op, const ExecutorBase<component::ECC_PublicKey, operation::ECC_PrivateToPublic>::ResultPair& result) const {\n    (void)module;\n\n    if ( result.second != std::nullopt  ) {\n        const auto curveID = op.curveType.Get();\n        const auto privkey = op.priv.ToTrimmedString();\n        const auto pub_x = result.second->first.ToTrimmedString();\n        const auto pub_y = result.second->second.ToTrimmedString();\n\n        Pool_CurvePrivkey.Set({ curveID, privkey });\n        Pool_CurveKeypair.Set({ curveID, privkey, pub_x, pub_y });\n        Pool_CurveECC_Point.Set({ curveID, pub_x, pub_y });\n\n        if ( pub_x.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(pub_x); }\n        if ( pub_y.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(pub_y); }\n    }\n}\n\ntemplate<> std::optional<component::ECC_PublicKey> ExecutorBase<component::ECC_PublicKey, operation::ECC_PrivateToPublic>::callModule(std::shared_ptr<Module> module, operation::ECC_PrivateToPublic& op) const {\n    RETURN_IF_DISABLED(options.curves, op.curveType.Get());\n\n    const size_t size = op.priv.ToTrimmedString().size();\n\n    if ( size == 0 || size > 4096 ) {\n        return std::nullopt;\n    }\n\n    return module->OpECC_PrivateToPublic(op);\n}\n\n\ntemplate class ExecutorBase<component::ECC_PublicKey, operation::ECC_PrivateToPublic>;"}
{"text_input": "Generate ECC_ValidatePubkey code for executor.cpp", "output": "/* Specialization for operation::ECC_ValidatePubkey */template<> void ExecutorBase<bool, operation::ECC_ValidatePubkey>::postprocess(std::shared_ptr<Module> module, operation::ECC_ValidatePubkey& op, const ExecutorBase<bool, operation::ECC_ValidatePubkey>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n    (void)result;\n}\n\ntemplate<> std::optional<bool> ExecutorBase<bool, operation::ECC_ValidatePubkey>::callModule(std::shared_ptr<Module> module, operation::ECC_ValidatePubkey& op) const {\n    RETURN_IF_DISABLED(options.curves, op.curveType.Get());\n\n    return module->OpECC_ValidatePubkey(op);\n}\n\n\ntemplate class ExecutorBase<bool, operation::ECC_ValidatePubkey>;"}
{"text_input": "Generate ECC_GenerateKeyPair code for executor.cpp", "output": "/* Specialization for operation::ECC_GenerateKeyPair */\n/* Do not compare DH_GenerateKeyPair results, because the result can be produced indeterministically */\ntemplate <>\nvoid ExecutorBase<component::DH_KeyPair, operation::DH_GenerateKeyPair>::compare(const std::vector< std::pair<std::shared_ptr<Module>, operation::DH_GenerateKeyPair> >& operations, const ResultSet& results, const uint8_t* data, const size_t size) const {\n    (void)operations;\n    (void)results;\n    (void)data;\n    (void)size;\n}\n\ntemplate<> void ExecutorBase<component::ECC_KeyPair, operation::ECC_GenerateKeyPair>::postprocess(std::shared_ptr<Module> module, operation::ECC_GenerateKeyPair& op, const ExecutorBase<component::ECC_KeyPair, operation::ECC_GenerateKeyPair>::ResultPair& result) const {\n    (void)module;\n\n    if ( result.second != std::nullopt  ) {\n        const auto curveID = op.curveType.Get();\n        const auto privkey = result.second->priv.ToTrimmedString();\n        const auto pub_x = result.second->pub.first.ToTrimmedString();\n        const auto pub_y = result.second->pub.second.ToTrimmedString();\n\n        Pool_CurvePrivkey.Set({ curveID, privkey });\n        Pool_CurveKeypair.Set({ curveID, privkey, pub_x, pub_y });\n        Pool_CurveECC_Point.Set({ curveID, pub_x, pub_y });\n\n        {\n            auto opValidate = operation::ECC_ValidatePubkey(\n                    op.curveType,\n                    result.second->pub,\n                    op.modifier);\n\n            const auto validateResult = module->OpECC_ValidatePubkey(opValidate);\n            CF_ASSERT(\n                    validateResult == std::nullopt ||\n                    *validateResult == true,\n                    \"Cannot validate generated public key\");\n        }\n    }\n}\n\ntemplate<> std::optional<component::ECC_KeyPair> ExecutorBase<component::ECC_KeyPair, operation::ECC_GenerateKeyPair>::callModule(std::shared_ptr<Module> module, operation::ECC_GenerateKeyPair& op) const {\n    RETURN_IF_DISABLED(options.curves, op.curveType.Get());\n\n    return module->OpECC_GenerateKeyPair(op);\n}\n\n/* Do not compare ECC_GenerateKeyPair results, because the result can be produced indeterministically */\ntemplate <>\nvoid ExecutorBase<component::ECC_KeyPair, operation::ECC_GenerateKeyPair>::compare(const std::vector< std::pair<std::shared_ptr<Module>, operation::ECC_GenerateKeyPair> >& operations, const ResultSet& results, const uint8_t* data, const size_t size) const {\n    (void)operations;\n    (void)results;\n    (void)data;\n    (void)size;\n}\n\n\ntemplate class ExecutorBase<component::ECC_KeyPair, operation::ECC_GenerateKeyPair>;"}
{"text_input": "Generate ECCSI_Sign code for executor.cpp", "output": "/* Specialization for operation::ECCSI_Sign */template<> void ExecutorBase<component::ECCSI_Signature, operation::ECCSI_Sign>::postprocess(std::shared_ptr<Module> module, operation::ECCSI_Sign& op, const ExecutorBase<component::ECCSI_Signature, operation::ECCSI_Sign>::ResultPair& result) const {\n    (void)module;\n\n    if ( result.second != std::nullopt  ) {\n        const auto curveID = op.curveType.Get();\n        const auto cleartext = op.cleartext.ToHex();\n        const auto id = op.id.ToHex();\n        const auto pub_x = result.second->pub.first.ToTrimmedString();\n        const auto pub_y = result.second->pub.second.ToTrimmedString();\n        const auto pvt_x = result.second->pvt.first.ToTrimmedString();\n        const auto pvt_y = result.second->pvt.second.ToTrimmedString();\n        const auto sig_r = result.second->signature.first.ToTrimmedString();\n        const auto sig_s = result.second->signature.second.ToTrimmedString();\n\n        Pool_CurveECCSISignature.Set({\n                curveID,\n                cleartext,\n                id,\n                pub_x, pub_y,\n                pvt_x, pvt_y,\n                sig_r, sig_s});\n        Pool_CurveECC_Point.Set({ curveID, pub_x, pub_y });\n        Pool_CurveECC_Point.Set({ curveID, pvt_x, pvt_y });\n        Pool_CurveECC_Point.Set({ curveID, sig_r, sig_s });\n\n        if ( pub_x.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(pub_x); }\n        if ( pub_y.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(pub_y); }\n        if ( pvt_x.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(pvt_x); }\n        if ( pvt_y.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(pvt_y); }\n        if ( sig_r.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(sig_r); }\n        if ( sig_s.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(sig_s); }\n\n        {\n            auto opVerify = operation::ECCSI_Verify(\n                    op,\n                    *(result.second),\n                    op.modifier);\n\n            const auto verifyResult = module->OpECCSI_Verify(opVerify);\n            CF_ASSERT(\n                    verifyResult == std::nullopt ||\n                    *verifyResult == true,\n                    \"Cannot verify generated signature\");\n        }\n    }\n}\n\ntemplate<> std::optional<component::ECCSI_Signature> ExecutorBase<component::ECCSI_Signature, operation::ECCSI_Sign>::callModule(std::shared_ptr<Module> module, operation::ECCSI_Sign& op) const {\n    RETURN_IF_DISABLED(options.curves, op.curveType.Get());\n    RETURN_IF_DISABLED(options.digests, op.digestType.Get());\n\n    const size_t size = op.priv.ToTrimmedString().size();\n\n    if ( size == 0 || size > 4096 ) {\n        return std::nullopt;\n    }\n\n    return module->OpECCSI_Sign(op);\n}\n\n\ntemplate <>\nbool ExecutorBase<component::ECCSI_Signature, operation::ECCSI_Sign>::dontCompare(const operation::ECCSI_Sign& operation) const {\n    (void)operation;\n    return true;\n}\n\n\ntemplate class ExecutorBase<component::ECCSI_Signature, operation::ECCSI_Sign>;"}
{"text_input": "Generate ECDSA_Sign code for executor.cpp", "output": "/* Specialization for operation::ECDSA_Sign */template<> void ExecutorBase<component::ECDSA_Signature, operation::ECDSA_Sign>::postprocess(std::shared_ptr<Module> module, operation::ECDSA_Sign& op, const ExecutorBase<component::ECDSA_Signature, operation::ECDSA_Sign>::ResultPair& result) const {\n    (void)module;\n\n    if ( result.second != std::nullopt  ) {\n        const auto curveID = op.curveType.Get();\n        const auto cleartext = op.cleartext.ToHex();\n        const auto pub_x = result.second->pub.first.ToTrimmedString();\n        const auto pub_y = result.second->pub.second.ToTrimmedString();\n        const auto sig_r = result.second->signature.first.ToTrimmedString();\n        const auto sig_s = result.second->signature.second.ToTrimmedString();\n\n        Pool_CurveECDSASignature.Set({ curveID, cleartext, pub_x, pub_y, sig_r, sig_s});\n        Pool_CurveECC_Point.Set({ curveID, pub_x, pub_y });\n        Pool_CurveECC_Point.Set({ curveID, sig_r, sig_s });\n\n        if ( pub_x.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(pub_x); }\n        if ( pub_y.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(pub_y); }\n        if ( sig_r.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(sig_r); }\n        if ( sig_s.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(sig_s); }\n\n        {\n            auto opVerify = operation::ECDSA_Verify(\n                    op,\n                    *(result.second),\n                    op.modifier);\n\n            const auto verifyResult = module->OpECDSA_Verify(opVerify);\n            CF_ASSERT(\n                    verifyResult == std::nullopt ||\n                    *verifyResult == true,\n                    \"Cannot verify generated signature\");\n        }\n    }\n}\n\ntemplate<> std::optional<component::ECDSA_Signature> ExecutorBase<component::ECDSA_Signature, operation::ECDSA_Sign>::callModule(std::shared_ptr<Module> module, operation::ECDSA_Sign& op) const {\n    RETURN_IF_DISABLED(options.curves, op.curveType.Get());\n    RETURN_IF_DISABLED(options.digests, op.digestType.Get());\n\n    const size_t size = op.priv.ToTrimmedString().size();\n\n    if ( size == 0 || size > 4096 ) {\n        return std::nullopt;\n    }\n\n    return module->OpECDSA_Sign(op);\n}\n\ntemplate <>\nbool ExecutorBase<component::ECDSA_Signature, operation::ECDSA_Sign>::dontCompare(const operation::ECDSA_Sign& operation) const {\n    if (\n            operation.curveType.Get() != CF_ECC_CURVE(\"ed25519\") &&\n            operation.curveType.Get() != CF_ECC_CURVE(\"ed448\") ) {\n        if ( operation.UseRandomNonce() ) {\n            /* Don't compare ECDSA signatures comptued from a randomly generated nonce */\n            return true;\n        }\n    }\n\n    return false;\n}\n\n\ntemplate class ExecutorBase<component::ECDSA_Signature, operation::ECDSA_Sign>;"}
{"text_input": "Generate ECGDSA_Sign code for executor.cpp", "output": "/* Specialization for operation::ECGDSA_Sign */template<> void ExecutorBase<component::ECGDSA_Signature, operation::ECGDSA_Sign>::postprocess(std::shared_ptr<Module> module, operation::ECGDSA_Sign& op, const ExecutorBase<component::ECGDSA_Signature, operation::ECGDSA_Sign>::ResultPair& result) const {\n    (void)module;\n\n    if ( result.second != std::nullopt  ) {\n        const auto curveID = op.curveType.Get();\n        const auto cleartext = op.cleartext.ToHex();\n        const auto pub_x = result.second->pub.first.ToTrimmedString();\n        const auto pub_y = result.second->pub.second.ToTrimmedString();\n        const auto sig_r = result.second->signature.first.ToTrimmedString();\n        const auto sig_s = result.second->signature.second.ToTrimmedString();\n\n        Pool_CurveECDSASignature.Set({ curveID, cleartext, pub_x, pub_y, sig_r, sig_s});\n        Pool_CurveECC_Point.Set({ curveID, pub_x, pub_y });\n        Pool_CurveECC_Point.Set({ curveID, sig_r, sig_s });\n\n        if ( pub_x.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(pub_x); }\n        if ( pub_y.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(pub_y); }\n        if ( sig_r.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(sig_r); }\n        if ( sig_s.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(sig_s); }\n    }\n}\n\ntemplate<> std::optional<component::ECGDSA_Signature> ExecutorBase<component::ECGDSA_Signature, operation::ECGDSA_Sign>::callModule(std::shared_ptr<Module> module, operation::ECGDSA_Sign& op) const {\n    RETURN_IF_DISABLED(options.curves, op.curveType.Get());\n    RETURN_IF_DISABLED(options.digests, op.digestType.Get());\n\n    const size_t size = op.priv.ToTrimmedString().size();\n\n    if ( size == 0 || size > 4096 ) {\n        return std::nullopt;\n    }\n\n    return module->OpECGDSA_Sign(op);\n}\n\ntemplate <>\nbool ExecutorBase<component::ECGDSA_Signature, operation::ECGDSA_Sign>::dontCompare(const operation::ECGDSA_Sign& operation) const {\n    if (\n            operation.curveType.Get() != CF_ECC_CURVE(\"ed25519\") &&\n            operation.curveType.Get() != CF_ECC_CURVE(\"ed448\") ) {\n        if ( operation.UseRandomNonce() ) {\n            /* Don't compare ECGDSA signatures comptued from a randomly generated nonce */\n            return true;\n        }\n    }\n\n    return false;\n}\n\n\ntemplate class ExecutorBase<component::ECGDSA_Signature, operation::ECGDSA_Sign>;"}
{"text_input": "Generate ECRDSA_Sign code for executor.cpp", "output": "/* Specialization for operation::ECRDSA_Sign */template<> void ExecutorBase<component::ECRDSA_Signature, operation::ECRDSA_Sign>::postprocess(std::shared_ptr<Module> module, operation::ECRDSA_Sign& op, const ExecutorBase<component::ECRDSA_Signature, operation::ECRDSA_Sign>::ResultPair& result) const {\n    (void)module;\n\n    if ( result.second != std::nullopt  ) {\n        const auto curveID = op.curveType.Get();\n        const auto cleartext = op.cleartext.ToHex();\n        const auto pub_x = result.second->pub.first.ToTrimmedString();\n        const auto pub_y = result.second->pub.second.ToTrimmedString();\n        const auto sig_r = result.second->signature.first.ToTrimmedString();\n        const auto sig_s = result.second->signature.second.ToTrimmedString();\n\n        Pool_CurveECDSASignature.Set({ curveID, cleartext, pub_x, pub_y, sig_r, sig_s});\n        Pool_CurveECC_Point.Set({ curveID, pub_x, pub_y });\n        Pool_CurveECC_Point.Set({ curveID, sig_r, sig_s });\n\n        if ( pub_x.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(pub_x); }\n        if ( pub_y.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(pub_y); }\n        if ( sig_r.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(sig_r); }\n        if ( sig_s.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(sig_s); }\n    }\n}\n\ntemplate<> std::optional<component::ECRDSA_Signature> ExecutorBase<component::ECRDSA_Signature, operation::ECRDSA_Sign>::callModule(std::shared_ptr<Module> module, operation::ECRDSA_Sign& op) const {\n    RETURN_IF_DISABLED(options.curves, op.curveType.Get());\n    RETURN_IF_DISABLED(options.digests, op.digestType.Get());\n\n    const size_t size = op.priv.ToTrimmedString().size();\n\n    if ( size == 0 || size > 4096 ) {\n        return std::nullopt;\n    }\n\n    return module->OpECRDSA_Sign(op);\n}\n\ntemplate <>\nbool ExecutorBase<component::ECRDSA_Signature, operation::ECRDSA_Sign>::dontCompare(const operation::ECRDSA_Sign& operation) const {\n    if (\n            operation.curveType.Get() != CF_ECC_CURVE(\"ed25519\") &&\n            operation.curveType.Get() != CF_ECC_CURVE(\"ed448\") ) {\n        if ( operation.UseRandomNonce() ) {\n            /* Don't compare ECRDSA signatures comptued from a randomly generated nonce */\n            return true;\n        }\n    }\n\n    return false;\n}\n\n\ntemplate class ExecutorBase<component::ECRDSA_Signature, operation::ECRDSA_Sign>;"}
{"text_input": "Generate Schnorr_Sign code for executor.cpp", "output": "/* Specialization for operation::Schnorr_Sign */template<> void ExecutorBase<component::Schnorr_Signature, operation::Schnorr_Sign>::postprocess(std::shared_ptr<Module> module, operation::Schnorr_Sign& op, const ExecutorBase<component::Schnorr_Signature, operation::Schnorr_Sign>::ResultPair& result) const {\n    (void)module;\n\n    if ( result.second != std::nullopt  ) {\n        const auto curveID = op.curveType.Get();\n        const auto cleartext = op.cleartext.ToHex();\n        const auto pub_x = result.second->pub.first.ToTrimmedString();\n        const auto pub_y = result.second->pub.second.ToTrimmedString();\n        const auto sig_r = result.second->signature.first.ToTrimmedString();\n        const auto sig_s = result.second->signature.second.ToTrimmedString();\n\n        Pool_CurveECDSASignature.Set({ curveID, cleartext, pub_x, pub_y, sig_r, sig_s});\n        Pool_CurveECC_Point.Set({ curveID, pub_x, pub_y });\n        Pool_CurveECC_Point.Set({ curveID, sig_r, sig_s });\n\n        if ( pub_x.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(pub_x); }\n        if ( pub_y.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(pub_y); }\n        if ( sig_r.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(sig_r); }\n        if ( sig_s.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(sig_s); }\n    }\n}\n\ntemplate<> std::optional<component::Schnorr_Signature> ExecutorBase<component::Schnorr_Signature, operation::Schnorr_Sign>::callModule(std::shared_ptr<Module> module, operation::Schnorr_Sign& op) const {\n    RETURN_IF_DISABLED(options.curves, op.curveType.Get());\n    RETURN_IF_DISABLED(options.digests, op.digestType.Get());\n\n    const size_t size = op.priv.ToTrimmedString().size();\n\n    if ( size == 0 || size > 4096 ) {\n        return std::nullopt;\n    }\n\n    return module->OpSchnorr_Sign(op);\n}\n\n\ntemplate class ExecutorBase<component::Schnorr_Signature, operation::Schnorr_Sign>;"}
{"text_input": "Generate ECCSI_Verify code for executor.cpp", "output": "/* Specialization for operation::ECCSI_Verify */template<> void ExecutorBase<bool, operation::ECCSI_Verify>::postprocess(std::shared_ptr<Module> module, operation::ECCSI_Verify& op, const ExecutorBase<bool, operation::ECCSI_Verify>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n    (void)result;\n}\n\ntemplate<> std::optional<bool> ExecutorBase<bool, operation::ECCSI_Verify>::callModule(std::shared_ptr<Module> module, operation::ECCSI_Verify& op) const {\n    RETURN_IF_DISABLED(options.curves, op.curveType.Get());\n    RETURN_IF_DISABLED(options.digests, op.digestType.Get());\n\n    return module->OpECCSI_Verify(op);\n}\n\n\ntemplate class ExecutorBase<bool, operation::ECCSI_Verify>;"}
{"text_input": "Generate ECDSA_Verify code for executor.cpp", "output": "/* Specialization for operation::ECDSA_Verify */template<> void ExecutorBase<bool, operation::ECDSA_Verify>::postprocess(std::shared_ptr<Module> module, operation::ECDSA_Verify& op, const ExecutorBase<bool, operation::ECDSA_Verify>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n    (void)result;\n}\n\ntemplate<> std::optional<bool> ExecutorBase<bool, operation::ECDSA_Verify>::callModule(std::shared_ptr<Module> module, operation::ECDSA_Verify& op) const {\n    RETURN_IF_DISABLED(options.curves, op.curveType.Get());\n    RETURN_IF_DISABLED(options.digests, op.digestType.Get());\n\n    /* Intentionally do not constrain the size of the public key or\n     * signature (like we do for BignumCalc).\n     *\n     * If any large public key or signature causes a time-out (or\n     * worse), this is something that needs attention;\n     * because verifiers sometimes process untrusted public keys,\n     * signatures or both, they should be resistant to bugs\n     * arising from large inputs.\n     */\n\n    return module->OpECDSA_Verify(op);\n}\n\n\ntemplate class ExecutorBase<bool, operation::ECDSA_Verify>;"}
{"text_input": "Generate ECGDSA_Verify code for executor.cpp", "output": "/* Specialization for operation::ECGDSA_Verify */template<> void ExecutorBase<bool, operation::ECGDSA_Verify>::postprocess(std::shared_ptr<Module> module, operation::ECGDSA_Verify& op, const ExecutorBase<bool, operation::ECGDSA_Verify>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n    (void)result;\n}\n\ntemplate<> std::optional<bool> ExecutorBase<bool, operation::ECGDSA_Verify>::callModule(std::shared_ptr<Module> module, operation::ECGDSA_Verify& op) const {\n    RETURN_IF_DISABLED(options.curves, op.curveType.Get());\n    RETURN_IF_DISABLED(options.digests, op.digestType.Get());\n\n    /* Intentionally do not constrain the size of the public key or\n     * signature (like we do for BignumCalc).\n     *\n     * If any large public key or signature causes a time-out (or\n     * worse), this is something that needs attention;\n     * because verifiers sometimes process untrusted public keys,\n     * signatures or both, they should be resistant to bugs\n     * arising from large inputs.\n     */\n\n    return module->OpECGDSA_Verify(op);\n}\n\n\ntemplate class ExecutorBase<bool, operation::ECGDSA_Verify>;"}
{"text_input": "Generate ECRDSA_Verify code for executor.cpp", "output": "/* Specialization for operation::ECRDSA_Verify */template<> void ExecutorBase<bool, operation::ECRDSA_Verify>::postprocess(std::shared_ptr<Module> module, operation::ECRDSA_Verify& op, const ExecutorBase<bool, operation::ECRDSA_Verify>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n    (void)result;\n}\n\ntemplate<> std::optional<bool> ExecutorBase<bool, operation::ECRDSA_Verify>::callModule(std::shared_ptr<Module> module, operation::ECRDSA_Verify& op) const {\n    RETURN_IF_DISABLED(options.curves, op.curveType.Get());\n    RETURN_IF_DISABLED(options.digests, op.digestType.Get());\n\n    /* Intentionally do not constrain the size of the public key or\n     * signature (like we do for BignumCalc).\n     *\n     * If any large public key or signature causes a time-out (or\n     * worse), this is something that needs attention;\n     * because verifiers sometimes process untrusted public keys,\n     * signatures or both, they should be resistant to bugs\n     * arising from large inputs.\n     */\n\n    return module->OpECRDSA_Verify(op);\n}\n\n\ntemplate class ExecutorBase<bool, operation::ECRDSA_Verify>;"}
{"text_input": "Generate Schnorr_Verify code for executor.cpp", "output": "/* Specialization for operation::Schnorr_Verify */template<> void ExecutorBase<bool, operation::Schnorr_Verify>::postprocess(std::shared_ptr<Module> module, operation::Schnorr_Verify& op, const ExecutorBase<bool, operation::Schnorr_Verify>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n    (void)result;\n}\n\ntemplate<> std::optional<bool> ExecutorBase<bool, operation::Schnorr_Verify>::callModule(std::shared_ptr<Module> module, operation::Schnorr_Verify& op) const {\n    RETURN_IF_DISABLED(options.curves, op.curveType.Get());\n    RETURN_IF_DISABLED(options.digests, op.digestType.Get());\n\n    /* Intentionally do not constrain the size of the public key or\n     * signature (like we do for BignumCalc).\n     *\n     * If any large public key or signature causes a time-out (or\n     * worse), this is something that needs attention;\n     * because verifiers sometimes process untrusted public keys,\n     * signatures or both, they should be resistant to bugs\n     * arising from large inputs.\n     */\n\n    return module->OpSchnorr_Verify(op);\n}\n\n\n\ntemplate class ExecutorBase<bool, operation::Schnorr_Verify>;"}
{"text_input": "Generate ECDSA_Recover code for executor.cpp", "output": "/* Specialization for operation::ECDSA_Recover */template<> void ExecutorBase<component::ECC_PublicKey, operation::ECDSA_Recover>::postprocess(std::shared_ptr<Module> module, operation::ECDSA_Recover& op, const ExecutorBase<component::ECC_PublicKey, operation::ECDSA_Recover>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n    (void)result;\n}\n\ntemplate<> std::optional<component::ECC_PublicKey> ExecutorBase<component::ECC_PublicKey, operation::ECDSA_Recover>::callModule(std::shared_ptr<Module> module, operation::ECDSA_Recover& op) const {\n    RETURN_IF_DISABLED(options.curves, op.curveType.Get());\n    RETURN_IF_DISABLED(options.digests, op.digestType.Get());\n\n    return module->OpECDSA_Recover(op);\n}\n\n\ntemplate class ExecutorBase<component::ECC_PublicKey, operation::ECDSA_Recover>;"}
{"text_input": "Generate DSA_Verify code for executor.cpp", "output": "/* Specialization for operation::DSA_Verify */template<> void ExecutorBase<bool, operation::DSA_Verify>::updateExtraCounters(const uint64_t moduleID, operation::DSA_Verify& op) const {\n    (void)moduleID;\n    (void)op;\n\n    /* TODO */\n}\n\ntemplate<> void ExecutorBase<bool, operation::DSA_Verify>::postprocess(std::shared_ptr<Module> module, operation::DSA_Verify& op, const ExecutorBase<bool, operation::DSA_Verify>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n    (void)result;\n}\n\ntemplate<> std::optional<bool> ExecutorBase<bool, operation::DSA_Verify>::callModule(std::shared_ptr<Module> module, operation::DSA_Verify& op) const {\n    const std::vector<size_t> sizes = {\n        op.parameters.p.ToTrimmedString().size(),\n        op.parameters.q.ToTrimmedString().size(),\n        op.parameters.g.ToTrimmedString().size(),\n        op.pub.ToTrimmedString().size(),\n        op.signature.first.ToTrimmedString().size(),\n        op.signature.second.ToTrimmedString().size(),\n    };\n\n    for (const auto& size : sizes) {\n        if ( size == 0 || size > 4096 ) {\n            return std::nullopt;\n        }\n    }\n\n    return module->OpDSA_Verify(op);\n}\n\n\ntemplate class ExecutorBase<bool, operation::DSA_Verify>;"}
{"text_input": "Generate DSA_Sign code for executor.cpp", "output": "/* Specialization for operation::DSA_Sign *//* Do not compare DSA_Sign results, because the result can be produced indeterministically */\ntemplate <>\nvoid ExecutorBase<component::DSA_Signature, operation::DSA_Sign>::compare(const std::vector< std::pair<std::shared_ptr<Module>, operation::DSA_Sign> >& operations, const ResultSet& results, const uint8_t* data, const size_t size) const {\n    (void)operations;\n    (void)results;\n    (void)data;\n    (void)size;\n}\ntemplate<> void ExecutorBase<component::DSA_Signature, operation::DSA_Sign>::updateExtraCounters(const uint64_t moduleID, operation::DSA_Sign& op) const {\n    (void)moduleID;\n    (void)op;\n\n    /* TODO */\n}\n\ntemplate<> void ExecutorBase<component::DSA_Signature, operation::DSA_Sign>::postprocess(std::shared_ptr<Module> module, operation::DSA_Sign& op, const ExecutorBase<component::DSA_Signature, operation::DSA_Sign>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n    if ( result.second != std::nullopt ) {\n        const auto cleartext = op.cleartext.ToHex();\n        const auto p = op.parameters.p.ToTrimmedString();\n        const auto q = op.parameters.q.ToTrimmedString();\n        const auto g = op.parameters.g.ToTrimmedString();\n        const auto r = result.second->signature.first.ToTrimmedString();\n        const auto s = result.second->signature.second.ToTrimmedString();\n        const auto pub = result.second->pub.ToTrimmedString();\n\n        Pool_DSASignature.Set({\n                cleartext,\n                p,\n                q,\n                g,\n                pub,\n                r,\n                s\n        });\n\n        if ( r.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(r); }\n        if ( s.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(s); }\n    }\n}\n\ntemplate<> std::optional<component::DSA_Signature> ExecutorBase<component::DSA_Signature, operation::DSA_Sign>::callModule(std::shared_ptr<Module> module, operation::DSA_Sign& op) const {\n    const std::vector<size_t> sizes = {\n        op.parameters.p.ToTrimmedString().size(),\n        op.parameters.q.ToTrimmedString().size(),\n        op.parameters.g.ToTrimmedString().size(),\n        op.priv.ToTrimmedString().size(),\n    };\n\n    for (const auto& size : sizes) {\n        if ( size == 0 || size > 4096 ) {\n            return std::nullopt;\n        }\n    }\n\n    return module->OpDSA_Sign(op);\n}\n\n\ntemplate class ExecutorBase<component::DSA_Signature, operation::DSA_Sign>;"}
{"text_input": "Generate DSA_PrivateToPublic code for executor.cpp", "output": "/* Specialization for operation::DSA_PrivateToPublic */\ntemplate<> void ExecutorBase<component::Bignum, operation::DSA_PrivateToPublic>::updateExtraCounters(const uint64_t moduleID, operation::DSA_PrivateToPublic& op) const {\n    (void)moduleID;\n    (void)op;\n\n    /* TODO */\n}\n\ntemplate<> void ExecutorBase<component::Bignum, operation::DSA_PrivateToPublic>::postprocess(std::shared_ptr<Module> module, operation::DSA_PrivateToPublic& op, const ExecutorBase<component::Bignum, operation::DSA_PrivateToPublic>::ResultPair& result) const {\n    (void)result;\n    (void)module;\n    (void)op;\n    if ( result.second != std::nullopt ) {\n        //Pool_DSA_PubPriv.Set({pub, priv});\n    }\n}\n\ntemplate<> std::optional<component::Bignum> ExecutorBase<component::Bignum, operation::DSA_PrivateToPublic>::callModule(std::shared_ptr<Module> module, operation::DSA_PrivateToPublic& op) const {\n    return module->OpDSA_PrivateToPublic(op);\n}\n\n\ntemplate class ExecutorBase<component::Bignum, operation::DSA_PrivateToPublic>;"}
{"text_input": "Generate DSA_GenerateKeyPair code for executor.cpp", "output": "/* Specialization for operation::DSA_GenerateKeyPair */\n/* Do not compare DSA_GenerateKeyPair results, because the result can be produced indeterministically */\ntemplate <>\nvoid ExecutorBase<component::DSA_KeyPair, operation::DSA_GenerateKeyPair>::compare(const std::vector< std::pair<std::shared_ptr<Module>, operation::DSA_GenerateKeyPair> >& operations, const ResultSet& results, const uint8_t* data, const size_t size) const {\n    (void)operations;\n    (void)results;\n    (void)data;\n    (void)size;\n}\n\ntemplate<> void ExecutorBase<component::DSA_KeyPair, operation::DSA_GenerateKeyPair>::updateExtraCounters(const uint64_t moduleID, operation::DSA_GenerateKeyPair& op) const {\n    (void)moduleID;\n    (void)op;\n\n    /* TODO */\n}\n\ntemplate<> void ExecutorBase<component::DSA_KeyPair, operation::DSA_GenerateKeyPair>::postprocess(std::shared_ptr<Module> module, operation::DSA_GenerateKeyPair& op, const ExecutorBase<component::DSA_KeyPair, operation::DSA_GenerateKeyPair>::ResultPair& result) const {\n    (void)result;\n    (void)module;\n    (void)op;\n    if ( result.second != std::nullopt && (PRNG() % 4) == 0 ) {\n        const auto priv = result.second->first.ToTrimmedString();\n        const auto pub = result.second->second.ToTrimmedString();\n\n        Pool_DSA_PubPriv.Set({pub, priv});\n    }\n}\n\ntemplate<> std::optional<component::DSA_KeyPair> ExecutorBase<component::DSA_KeyPair, operation::DSA_GenerateKeyPair>::callModule(std::shared_ptr<Module> module, operation::DSA_GenerateKeyPair& op) const {\n    const std::vector<size_t> sizes = {\n        op.p.ToTrimmedString().size(),\n        op.q.ToTrimmedString().size(),\n        op.g.ToTrimmedString().size(),\n    };\n\n    for (const auto& size : sizes) {\n        if ( size == 0 || size > 4096 ) {\n            return std::nullopt;\n        }\n    }\n\n    return module->OpDSA_GenerateKeyPair(op);\n}\n\n\ntemplate class ExecutorBase<component::DSA_KeyPair, operation::DSA_GenerateKeyPair>;"}
{"text_input": "Generate DSA_GenerateParameters code for executor.cpp", "output": "/* Specialization for operation::DSA_GenerateParameters */\ntemplate <>\nvoid ExecutorBase<component::DSA_Parameters, operation::DSA_GenerateParameters>::compare(const std::vector< std::pair<std::shared_ptr<Module>, operation::DSA_GenerateParameters> >& operations, const ResultSet& results, const uint8_t* data, const size_t size) const {\n    (void)operations;\n    (void)results;\n    (void)data;\n    (void)size;\n}\n\ntemplate<> void ExecutorBase<component::DSA_Parameters, operation::DSA_GenerateParameters>::updateExtraCounters(const uint64_t moduleID, operation::DSA_GenerateParameters& op) const {\n    (void)moduleID;\n    (void)op;\n\n    /* TODO */\n}\n\ntemplate<> void ExecutorBase<component::DSA_Parameters, operation::DSA_GenerateParameters>::postprocess(std::shared_ptr<Module> module, operation::DSA_GenerateParameters& op, const ExecutorBase<component::DSA_Parameters, operation::DSA_GenerateParameters>::ResultPair& result) const {\n    (void)result;\n    (void)module;\n    (void)op;\n    if ( result.second != std::nullopt && (PRNG() % 4) == 0 ) {\n        const auto P = result.second->p.ToTrimmedString();\n        const auto Q = result.second->q.ToTrimmedString();\n        const auto G = result.second->g.ToTrimmedString();\n\n        Pool_DSA_PQG.Set({P, Q, G});\n\n        if ( P.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(P); }\n        if ( Q.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(Q); }\n        if ( G.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(G); }\n    }\n}\n\ntemplate<> std::optional<component::DSA_Parameters> ExecutorBase<component::DSA_Parameters, operation::DSA_GenerateParameters>::callModule(std::shared_ptr<Module> module, operation::DSA_GenerateParameters& op) const {\n    return module->OpDSA_GenerateParameters(op);\n}\n\n\ntemplate class ExecutorBase<component::DSA_Parameters, operation::DSA_GenerateParameters>;"}
{"text_input": "Generate ECDH_Derive code for executor.cpp", "output": "/* Specialization for operation::ECDH_Derive */template<> void ExecutorBase<component::Secret, operation::ECDH_Derive>::postprocess(std::shared_ptr<Module> module, operation::ECDH_Derive& op, const ExecutorBase<component::Secret, operation::ECDH_Derive>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n    (void)result;\n}\n\ntemplate<> std::optional<component::Secret> ExecutorBase<component::Secret, operation::ECDH_Derive>::callModule(std::shared_ptr<Module> module, operation::ECDH_Derive& op) const {\n    RETURN_IF_DISABLED(options.curves, op.curveType.Get());\n\n    return module->OpECDH_Derive(op);\n}\n\n\ntemplate class ExecutorBase<component::Secret, operation::ECDH_Derive>;"}
{"text_input": "Generate ECIES_Encrypt code for executor.cpp", "output": "/* Specialization for operation::ECIES_Encrypt */template <>\nvoid ExecutorBase<component::Ciphertext, operation::ECIES_Encrypt>::compare(const std::vector< std::pair<std::shared_ptr<Module>, operation::ECIES_Encrypt> >& operations, const ResultSet& results, const uint8_t* data, const size_t size) const {\n    (void)operations;\n    (void)results;\n    (void)data;\n    (void)size;\n}\ntemplate<> void ExecutorBase<component::Ciphertext, operation::ECIES_Encrypt>::postprocess(std::shared_ptr<Module> module, operation::ECIES_Encrypt& op, const ExecutorBase<component::Ciphertext, operation::ECIES_Encrypt>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n    (void)result;\n}\n\ntemplate<> std::optional<component::Ciphertext> ExecutorBase<component::Ciphertext, operation::ECIES_Encrypt>::callModule(std::shared_ptr<Module> module, operation::ECIES_Encrypt& op) const {\n    RETURN_IF_DISABLED(options.curves, op.curveType.Get());\n\n    return module->OpECIES_Encrypt(op);\n}\n\n\ntemplate class ExecutorBase<component::Ciphertext, operation::ECIES_Encrypt>;"}
{"text_input": "Generate ECIES_Decrypt code for executor.cpp", "output": "/* Specialization for operation::ECIES_Decrypt */template<> void ExecutorBase<component::Cleartext, operation::ECIES_Decrypt>::postprocess(std::shared_ptr<Module> module, operation::ECIES_Decrypt& op, const ExecutorBase<component::Cleartext, operation::ECIES_Decrypt>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n    (void)result;\n}\n\ntemplate<> std::optional<component::Cleartext> ExecutorBase<component::Cleartext, operation::ECIES_Decrypt>::callModule(std::shared_ptr<Module> module, operation::ECIES_Decrypt& op) const {\n    RETURN_IF_DISABLED(options.curves, op.curveType.Get());\n\n    return module->OpECIES_Decrypt(op);\n}\n\n\ntemplate class ExecutorBase<component::Cleartext, operation::ECIES_Decrypt>;"}
{"text_input": "Generate ECC_Point_Add code for executor.cpp", "output": "/* Specialization for operation::ECC_Point_Add */template<> void ExecutorBase<component::ECC_Point, operation::ECC_Point_Add>::postprocess(std::shared_ptr<Module> module, operation::ECC_Point_Add& op, const ExecutorBase<component::ECC_Point, operation::ECC_Point_Add>::ResultPair& result) const {\n    (void)module;\n\n    if ( result.second != std::nullopt  ) {\n        const auto curveID = op.curveType.Get();\n        const auto x = result.second->first.ToTrimmedString();\n        const auto y = result.second->second.ToTrimmedString();\n\n        Pool_CurveECC_Point.Set({ curveID, x, y });\n\n        if ( x.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(x); }\n        if ( y.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(y); }\n    }\n}\n\ntemplate<> std::optional<component::ECC_Point> ExecutorBase<component::ECC_Point, operation::ECC_Point_Add>::callModule(std::shared_ptr<Module> module, operation::ECC_Point_Add& op) const {\n    RETURN_IF_DISABLED(options.curves, op.curveType.Get());\n\n    return module->OpECC_Point_Add(op);\n}\n\n\ntemplate class ExecutorBase<component::ECC_Point, operation::ECC_Point_Add>;"}
{"text_input": "Generate ECC_Point_Sub code for executor.cpp", "output": "/* Specialization for operation::ECC_Point_Sub */template<> void ExecutorBase<component::ECC_Point, operation::ECC_Point_Sub>::postprocess(std::shared_ptr<Module> module, operation::ECC_Point_Sub& op, const ExecutorBase<component::ECC_Point, operation::ECC_Point_Sub>::ResultPair& result) const {\n    (void)module;\n\n    if ( result.second != std::nullopt  ) {\n        const auto curveID = op.curveType.Get();\n        const auto x = result.second->first.ToTrimmedString();\n        const auto y = result.second->second.ToTrimmedString();\n\n        Pool_CurveECC_Point.Set({ curveID, x, y });\n\n        if ( x.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(x); }\n        if ( y.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(y); }\n    }\n}\n\ntemplate<> std::optional<component::ECC_Point> ExecutorBase<component::ECC_Point, operation::ECC_Point_Sub>::callModule(std::shared_ptr<Module> module, operation::ECC_Point_Sub& op) const {\n    RETURN_IF_DISABLED(options.curves, op.curveType.Get());\n\n    return module->OpECC_Point_Sub(op);\n}\n\n\ntemplate class ExecutorBase<component::ECC_Point, operation::ECC_Point_Sub>;"}
{"text_input": "Generate ECC_Point_Mul code for executor.cpp", "output": "/* Specialization for operation::ECC_Point_Mul */template<> void ExecutorBase<component::ECC_Point, operation::ECC_Point_Mul>::postprocess(std::shared_ptr<Module> module, operation::ECC_Point_Mul& op, const ExecutorBase<component::ECC_Point, operation::ECC_Point_Mul>::ResultPair& result) const {\n    (void)module;\n\n    if ( result.second != std::nullopt  ) {\n        const auto curveID = op.curveType.Get();\n        const auto x = result.second->first.ToTrimmedString();\n        const auto y = result.second->second.ToTrimmedString();\n\n        Pool_CurveECC_Point.Set({ curveID, x, y });\n\n        if ( x.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(x); }\n        if ( y.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(y); }\n    }\n}\n\ntemplate<> std::optional<component::ECC_Point> ExecutorBase<component::ECC_Point, operation::ECC_Point_Mul>::callModule(std::shared_ptr<Module> module, operation::ECC_Point_Mul& op) const {\n    RETURN_IF_DISABLED(options.curves, op.curveType.Get());\n\n    return module->OpECC_Point_Mul(op);\n}\n\n\ntemplate class ExecutorBase<component::ECC_Point, operation::ECC_Point_Mul>;"}
{"text_input": "Generate ECC_Point_Neg code for executor.cpp", "output": "/* Specialization for operation::ECC_Point_Neg */template<> void ExecutorBase<component::ECC_Point, operation::ECC_Point_Neg>::postprocess(std::shared_ptr<Module> module, operation::ECC_Point_Neg& op, const ExecutorBase<component::ECC_Point, operation::ECC_Point_Neg>::ResultPair& result) const {\n    (void)module;\n\n    if ( result.second != std::nullopt  ) {\n        const auto curveID = op.curveType.Get();\n        const auto x = result.second->first.ToTrimmedString();\n        const auto y = result.second->second.ToTrimmedString();\n\n        Pool_CurveECC_Point.Set({ curveID, x, y });\n\n        if ( x.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(x); }\n        if ( y.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(y); }\n    }\n}\n\ntemplate<> std::optional<component::ECC_Point> ExecutorBase<component::ECC_Point, operation::ECC_Point_Neg>::callModule(std::shared_ptr<Module> module, operation::ECC_Point_Neg& op) const {\n    RETURN_IF_DISABLED(options.curves, op.curveType.Get());\n\n    return module->OpECC_Point_Neg(op);\n}\n\n\ntemplate class ExecutorBase<component::ECC_Point, operation::ECC_Point_Neg>;"}
{"text_input": "Generate ECC_Point_Dbl code for executor.cpp", "output": "/* Specialization for operation::ECC_Point_Dbl */template<> void ExecutorBase<component::ECC_Point, operation::ECC_Point_Dbl>::postprocess(std::shared_ptr<Module> module, operation::ECC_Point_Dbl& op, const ExecutorBase<component::ECC_Point, operation::ECC_Point_Dbl>::ResultPair& result) const {\n    (void)module;\n\n    if ( result.second != std::nullopt  ) {\n        const auto curveID = op.curveType.Get();\n        const auto x = result.second->first.ToTrimmedString();\n        const auto y = result.second->second.ToTrimmedString();\n\n        Pool_CurveECC_Point.Set({ curveID, x, y });\n\n        if ( x.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(x); }\n        if ( y.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(y); }\n    }\n}\n\ntemplate<> std::optional<component::ECC_Point> ExecutorBase<component::ECC_Point, operation::ECC_Point_Dbl>::callModule(std::shared_ptr<Module> module, operation::ECC_Point_Dbl& op) const {\n    RETURN_IF_DISABLED(options.curves, op.curveType.Get());\n\n    return module->OpECC_Point_Dbl(op);\n}\n\n\ntemplate class ExecutorBase<component::ECC_Point, operation::ECC_Point_Dbl>;"}
{"text_input": "Generate ECC_Point_Cmp code for executor.cpp", "output": "/* Specialization for operation::ECC_Point_Cmp */template<> void ExecutorBase<bool, operation::ECC_Point_Cmp>::postprocess(std::shared_ptr<Module> module, operation::ECC_Point_Cmp& op, const ExecutorBase<bool, operation::ECC_Point_Cmp>::ResultPair& result) const {\n    (void)module;\n    (void)result;\n    (void)op;\n}\n\ntemplate<> std::optional<bool> ExecutorBase<bool, operation::ECC_Point_Cmp>::callModule(std::shared_ptr<Module> module, operation::ECC_Point_Cmp& op) const {\n    RETURN_IF_DISABLED(options.curves, op.curveType.Get());\n\n    return module->OpECC_Point_Cmp(op);\n}\n\n\ntemplate class ExecutorBase<bool, operation::ECC_Point_Cmp>;"}
{"text_input": "Generate DH_Derive code for executor.cpp", "output": "/* Specialization for operation::DH_Derive */template<> void ExecutorBase<component::Bignum, operation::DH_Derive>::postprocess(std::shared_ptr<Module> module, operation::DH_Derive& op, const ExecutorBase<component::Bignum, operation::DH_Derive>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n    (void)result;\n}\n\ntemplate<> std::optional<component::Bignum> ExecutorBase<component::Bignum, operation::DH_Derive>::callModule(std::shared_ptr<Module> module, operation::DH_Derive& op) const {\n    if ( op.prime.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.base.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.pub.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.priv.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n\n    return module->OpDH_Derive(op);\n}\n\n\ntemplate class ExecutorBase<component::Bignum, operation::DH_Derive>;"}
{"text_input": "Generate DH_GenerateKeyPair code for executor.cpp", "output": "/* Specialization for operation::DH_GenerateKeyPair */template<> void ExecutorBase<component::DH_KeyPair, operation::DH_GenerateKeyPair>::postprocess(std::shared_ptr<Module> module, operation::DH_GenerateKeyPair& op, const ExecutorBase<component::DH_KeyPair, operation::DH_GenerateKeyPair>::ResultPair& result) const {\n    (void)result;\n    (void)op;\n    (void)module;\n\n    if ( result.second != std::nullopt && (PRNG() % 4) == 0 ) {\n        const auto priv = result.second->first.ToTrimmedString();\n        const auto pub = result.second->second.ToTrimmedString();\n\n        Pool_DH_PrivateKey.Set(priv);\n        Pool_DH_PublicKey.Set(pub);\n    }\n}\n\ntemplate<> std::optional<component::DH_KeyPair> ExecutorBase<component::DH_KeyPair, operation::DH_GenerateKeyPair>::callModule(std::shared_ptr<Module> module, operation::DH_GenerateKeyPair& op) const {\n    if ( op.prime.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.base.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n\n    return module->OpDH_GenerateKeyPair(op);\n}\n\n\ntemplate class ExecutorBase<component::DH_KeyPair, operation::DH_GenerateKeyPair>;"}
{"text_input": "Generate BignumCalc code for executor.cpp", "output": "/* Specialization for operation::BignumCalc */template<> void ExecutorBase<component::Bignum, operation::BignumCalc>::postprocess(std::shared_ptr<Module> module, operation::BignumCalc& op, const ExecutorBase<component::Bignum, operation::BignumCalc>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n\n    if ( result.second != std::nullopt  ) {\n        const auto bignum = result.second->ToTrimmedString();\n\n        if ( bignum.size() <= config::kMaxBignumSize ) {\n            Pool_Bignum.Set(bignum);\n            if ( op.calcOp.Is(CF_CALCOP(\"Prime()\")) ) {\n                Pool_Bignum_Primes.Set(bignum);\n            }\n        }\n        if ( op.calcOp.Is(CF_CALCOP(\"IsPrime(A)\")) ) {\n            if ( bignum == \"1\" ) {\n                Pool_Bignum_Primes.Set(op.bn0.ToTrimmedString());\n            }\n        }\n    }\n}\n\nstd::optional<component::Bignum> ExecutorBignumCalc::callModule(std::shared_ptr<Module> module, operation::BignumCalc& op) const {\n    RETURN_IF_DISABLED(options.calcOps, op.calcOp.Get());\n\n    /* Prevent timeouts */\n    if ( op.bn0.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn1.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn2.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn3.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n\n    if ( op.modulo != std::nullopt && !module->SupportsModularBignumCalc() ) {\n        return std::nullopt;\n    }\n\n    switch ( op.calcOp.Get() ) {\n        case    CF_CALCOP(\"SetBit(A,B)\"):\n            /* Don't allow setting very high bit positions (risk of memory exhaustion) */\n            if ( op.bn1.GetSize() > 4 ) {\n                return std::nullopt;\n            }\n            break;\n        case    CF_CALCOP(\"Exp(A,B)\"):\n            if ( op.bn0.GetSize() > 5 || op.bn1.GetSize() > 2 ) {\n                return std::nullopt;\n            }\n            break;\n        case    CF_CALCOP(\"ModLShift(A,B,C)\"):\n            if ( op.bn1.GetSize() > 4 ) {\n                return std::nullopt;\n            }\n            break;\n        case    CF_CALCOP(\"Exp2(A)\"):\n            if ( op.bn0.GetSize() > 4 ) {\n                return std::nullopt;\n            }\n            break;\n    }\n\n    return module->OpBignumCalc(op);\n}\n\n\ntemplate class ExecutorBase<component::Bignum, operation::BignumCalc>;"}
{"text_input": "Generate BignumCalc_Fp2 code for executor.cpp", "output": "/* Specialization for operation::BignumCalc_Fp2 */template<> void ExecutorBase<component::Fp2, operation::BignumCalc_Fp2>::postprocess(std::shared_ptr<Module> module, operation::BignumCalc_Fp2& op, const ExecutorBase<component::Fp2, operation::BignumCalc_Fp2>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n\n    if ( result.second != std::nullopt  ) {\n        const auto bignum_first = result.second->first.ToTrimmedString();\n        const auto bignum_second = result.second->second.ToTrimmedString();\n\n        if ( bignum_first.size() <= config::kMaxBignumSize ) {\n            Pool_Bignum.Set(bignum_first);\n        }\n        if ( bignum_second.size() <= config::kMaxBignumSize ) {\n            Pool_Bignum.Set(bignum_second);\n        }\n    }\n}\n\nstd::optional<component::Fp2> ExecutorBignumCalc_Fp2::callModule(std::shared_ptr<Module> module, operation::BignumCalc_Fp2& op) const {\n    RETURN_IF_DISABLED(options.calcOps, op.calcOp.Get());\n\n    /* Prevent timeouts */\n    if ( op.bn0.first.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn0.second.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn1.first.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn1.second.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn2.first.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn2.second.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn3.first.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn3.second.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n\n    if ( op.modulo != std::nullopt && !module->SupportsModularBignumCalc() ) {\n        return std::nullopt;\n    }\n\n    return module->OpBignumCalc_Fp2(op);\n}\n\n\ntemplate class ExecutorBase<component::Fp2, operation::BignumCalc_Fp2>;"}
{"text_input": "Generate BignumCalc_Fp12 code for executor.cpp", "output": "/* Specialization for operation::BignumCalc_Fp12 */template<> void ExecutorBase<component::Fp12, operation::BignumCalc_Fp12>::postprocess(std::shared_ptr<Module> module, operation::BignumCalc_Fp12& op, const ExecutorBase<component::Fp12, operation::BignumCalc_Fp12>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n\n    if ( result.second != std::nullopt  ) {\n        Pool_Fp12.Set({\n                result.second->bn1.ToTrimmedString(),\n                result.second->bn2.ToTrimmedString(),\n                result.second->bn3.ToTrimmedString(),\n                result.second->bn4.ToTrimmedString(),\n                result.second->bn5.ToTrimmedString(),\n                result.second->bn6.ToTrimmedString(),\n                result.second->bn7.ToTrimmedString(),\n                result.second->bn8.ToTrimmedString(),\n                result.second->bn9.ToTrimmedString(),\n                result.second->bn10.ToTrimmedString(),\n                result.second->bn11.ToTrimmedString(),\n                result.second->bn12.ToTrimmedString()\n        });\n        /* TODO */\n#if 0\n        const auto bignum_first = result.second->first.ToTrimmedString();\n        const auto bignum_second = result.second->second.ToTrimmedString();\n\n        if ( bignum_first.size() <= config::kMaxBignumSize ) {\n            Pool_Bignum.Set(bignum_first);\n        }\n        if ( bignum_second.size() <= config::kMaxBignumSize ) {\n            Pool_Bignum.Set(bignum_second);\n        }\n#endif\n    }\n}\n\nstd::optional<component::Fp12> ExecutorBignumCalc_Fp12::callModule(std::shared_ptr<Module> module, operation::BignumCalc_Fp12& op) const {\n    RETURN_IF_DISABLED(options.calcOps, op.calcOp.Get());\n\n    /* Prevent timeouts */\n    if ( op.bn0.bn1.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn0.bn2.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn0.bn3.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn0.bn4.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn0.bn5.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn0.bn6.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn0.bn7.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn0.bn8.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn0.bn9.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn0.bn10.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn0.bn11.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn0.bn12.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n\n    if ( op.bn1.bn1.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn1.bn2.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn1.bn3.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn1.bn4.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn1.bn5.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn1.bn6.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn1.bn7.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn1.bn8.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn1.bn9.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn1.bn10.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn1.bn11.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn1.bn12.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n\n    if ( op.bn2.bn1.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn2.bn2.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn2.bn3.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn2.bn4.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn2.bn5.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn2.bn6.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn2.bn7.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn2.bn8.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn2.bn9.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn2.bn10.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn2.bn11.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn2.bn12.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n\n    if ( op.bn3.bn1.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn3.bn2.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn3.bn3.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn3.bn4.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn3.bn5.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn3.bn6.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn3.bn7.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn3.bn8.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn3.bn9.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn3.bn10.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn3.bn11.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn3.bn12.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n\n    if ( op.modulo != std::nullopt && !module->SupportsModularBignumCalc() ) {\n        return std::nullopt;\n    }\n\n    return module->OpBignumCalc_Fp12(op);\n}\n\n\ntemplate class ExecutorBase<component::Fp12, operation::BignumCalc_Fp12>;"}
{"text_input": "Generate BLS_PrivateToPublic code for executor.cpp", "output": "/* Specialization for operation::BLS_PrivateToPublic */template<> void ExecutorBase<component::BLS_PublicKey, operation::BLS_PrivateToPublic>::postprocess(std::shared_ptr<Module> module, operation::BLS_PrivateToPublic& op, const ExecutorBase<component::BLS_PublicKey, operation::BLS_PrivateToPublic>::ResultPair& result) const {\n    (void)module;\n\n    if ( result.second != std::nullopt  ) {\n        const auto curveID = op.curveType.Get();\n        const auto g1_x = result.second->first.ToTrimmedString();\n        const auto g1_y = result.second->second.ToTrimmedString();\n\n        G1AddToPool(curveID, g1_x, g1_y);\n\n        if ( g1_x.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(g1_x); }\n        if ( g1_y.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(g1_y); }\n    }\n}\n\ntemplate<> std::optional<component::BLS_PublicKey> ExecutorBase<component::BLS_PublicKey, operation::BLS_PrivateToPublic>::callModule(std::shared_ptr<Module> module, operation::BLS_PrivateToPublic& op) const {\n    RETURN_IF_DISABLED(options.curves, op.curveType.Get());\n\n    const size_t size = op.priv.ToTrimmedString().size();\n\n    if ( size == 0 || size > 4096 ) {\n        return std::nullopt;\n    }\n\n    return module->OpBLS_PrivateToPublic(op);\n}\n\n\ntemplate class ExecutorBase<component::BLS_PublicKey, operation::BLS_PrivateToPublic>;"}
{"text_input": "Generate BLS_PrivateToPublic_G2 code for executor.cpp", "output": "/* Specialization for operation::BLS_PrivateToPublic_G2 */template<> void ExecutorBase<component::G2, operation::BLS_PrivateToPublic_G2>::postprocess(std::shared_ptr<Module> module, operation::BLS_PrivateToPublic_G2& op, const ExecutorBase<component::G2, operation::BLS_PrivateToPublic_G2>::ResultPair& result) const {\n    (void)module;\n    if ( result.second != std::nullopt  ) {\n        const auto curveID = op.curveType.Get();\n        const auto g2_v = result.second->first.first.ToTrimmedString();\n        const auto g2_w = result.second->first.second.ToTrimmedString();\n        const auto g2_x = result.second->second.first.ToTrimmedString();\n        const auto g2_y = result.second->second.second.ToTrimmedString();\n\n        G2AddToPool(curveID, g2_v, g2_w, g2_x, g2_y);\n\n        if ( g2_v.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(g2_v); }\n        if ( g2_w.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(g2_w); }\n        if ( g2_x.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(g2_x); }\n        if ( g2_y.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(g2_y); }\n    }\n}\n\ntemplate<> std::optional<component::G2> ExecutorBase<component::G2, operation::BLS_PrivateToPublic_G2>::callModule(std::shared_ptr<Module> module, operation::BLS_PrivateToPublic_G2& op) const {\n    const size_t size = op.priv.ToTrimmedString().size();\n\n    if ( size == 0 || size > 4096 ) {\n        return std::nullopt;\n    }\n\n    return module->OpBLS_PrivateToPublic_G2(op);\n}\n\n\ntemplate class ExecutorBase<component::G2, operation::BLS_PrivateToPublic_G2>;"}
{"text_input": "Generate BLS_Sign code for executor.cpp", "output": "/* Specialization for operation::BLS_Sign */template<> void ExecutorBase<component::BLS_Signature, operation::BLS_Sign>::postprocess(std::shared_ptr<Module> module, operation::BLS_Sign& op, const ExecutorBase<component::BLS_Signature, operation::BLS_Sign>::ResultPair& result) const {\n    (void)module;\n\n    if ( result.second != std::nullopt  ) {\n        const auto curveID = op.curveType.Get();\n        const auto point_v = op.hashOrPoint ? op.point.first.first.ToTrimmedString() : \"\";\n        const auto point_w = op.hashOrPoint ? op.point.first.second.ToTrimmedString() : \"\";\n        const auto point_x = op.hashOrPoint ? op.point.second.first.ToTrimmedString() : \"\";\n        const auto point_y = op.hashOrPoint ? op.point.second.second.ToTrimmedString() : \"\";\n        const auto cleartext = op.hashOrPoint ? op.cleartext.ToHex() : \"\";\n        const auto dest = op.dest.ToHex();\n        const auto aug = op.aug.ToHex();\n        const auto pub_x = result.second->pub.first.ToTrimmedString();\n        const auto pub_y = result.second->pub.second.ToTrimmedString();\n        const auto sig_v = result.second->signature.first.first.ToTrimmedString();\n        const auto sig_w = result.second->signature.first.second.ToTrimmedString();\n        const auto sig_x = result.second->signature.second.first.ToTrimmedString();\n        const auto sig_y = result.second->signature.second.second.ToTrimmedString();\n\n        G1AddToPool(curveID, pub_x, pub_y);\n        G2AddToPool(curveID, sig_v, sig_w, sig_x, sig_y);\n        Pool_CurveBLSSignature.Set({ curveID, op.hashOrPoint, point_v, point_w, point_x, point_y, cleartext, dest, aug, pub_x, pub_y, sig_v, sig_w, sig_x, sig_y});\n\n        if ( pub_x.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(pub_x); }\n        if ( pub_y.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(pub_y); }\n        if ( sig_v.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(sig_v); }\n        if ( sig_w.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(sig_w); }\n        if ( sig_x.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(sig_x); }\n        if ( sig_y.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(sig_y); }\n    }\n}\n\ntemplate<> std::optional<component::BLS_Signature> ExecutorBase<component::BLS_Signature, operation::BLS_Sign>::callModule(std::shared_ptr<Module> module, operation::BLS_Sign& op) const {\n    const size_t size = op.priv.ToTrimmedString().size();\n\n    if ( size == 0 || size > 4096 ) {\n        return std::nullopt;\n    }\n\n    return module->OpBLS_Sign(op);\n}\n\n\ntemplate class ExecutorBase<component::BLS_Signature, operation::BLS_Sign>;"}
{"text_input": "Generate BLS_Verify code for executor.cpp", "output": "/* Specialization for operation::BLS_Verify */template<> void ExecutorBase<bool, operation::BLS_Verify>::postprocess(std::shared_ptr<Module> module, operation::BLS_Verify& op, const ExecutorBase<bool, operation::BLS_Verify>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n    (void)result;\n}\n\ntemplate<> std::optional<bool> ExecutorBase<bool, operation::BLS_Verify>::callModule(std::shared_ptr<Module> module, operation::BLS_Verify& op) const {\n#if 0\n    const std::vector<size_t> sizes = {\n        op.pub.first.ToTrimmedString().size(),\n        op.pub.second.ToTrimmedString().size(),\n        op.signature.first.ToTrimmedString().size(),\n        op.signature.second.ToTrimmedString().size(),\n    };\n\n    for (const auto& size : sizes) {\n        if ( size == 0 || size > 4096 ) {\n            return std::nullopt;\n        }\n    }\n#endif\n\n    return module->OpBLS_Verify(op);\n}\n\n\ntemplate class ExecutorBase<bool, operation::BLS_Verify>;"}
{"text_input": "Generate BLS_BatchSign code for executor.cpp", "output": "/* Specialization for operation::BLS_BatchSign */template<> void ExecutorBase<component::BLS_BatchSignature, operation::BLS_BatchSign>::postprocess(std::shared_ptr<Module> module, operation::BLS_BatchSign& op, const ExecutorBase<component::BLS_BatchSignature, operation::BLS_BatchSign>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n\n    if ( result.second != std::nullopt  ) {\n        std::vector< std::pair<BLS_BatchSignature_::G1, BLS_BatchSignature_::G2> > msgpub;\n        for (const auto& mp : result.second->msgpub) {\n            msgpub.push_back(\n                    std::pair<BLS_BatchSignature_::G1, BLS_BatchSignature_::G2>{\n                        {\n                            mp.first.first.ToTrimmedString(),\n                            mp.first.second.ToTrimmedString()\n                        },\n                        {\n                            mp.second.first.first.ToTrimmedString(),\n                            mp.second.first.second.ToTrimmedString(),\n                            mp.second.second.first.ToTrimmedString(),\n                            mp.second.second.second.ToTrimmedString()\n                        }\n                    }\n            );\n            G1AddToPool(CF_ECC_CURVE(\"BLS12_381\"), mp.first.first.ToTrimmedString(), mp.first.second.ToTrimmedString());\n            Pool_CurveBLSG2.Set({\n                    CF_ECC_CURVE(\"BLS12_381\"),\n                    mp.second.first.first.ToTrimmedString(),\n                    mp.second.first.second.ToTrimmedString(),\n                    mp.second.second.first.ToTrimmedString(),\n                    mp.second.second.second.ToTrimmedString()\n            });\n        }\n        Pool_BLS_BatchSignature.Set({msgpub});\n    }\n}\n\ntemplate<> std::optional<component::BLS_BatchSignature> ExecutorBase<component::BLS_BatchSignature, operation::BLS_BatchSign>::callModule(std::shared_ptr<Module> module, operation::BLS_BatchSign& op) const {\n    return module->OpBLS_BatchSign(op);\n}\n\n\ntemplate class ExecutorBase<component::BLS_BatchSignature, operation::BLS_BatchSign>;"}
{"text_input": "Generate BLS_BatchVerify code for executor.cpp", "output": "/* Specialization for operation::BLS_BatchVerify */template<> void ExecutorBase<bool, operation::BLS_BatchVerify>::postprocess(std::shared_ptr<Module> module, operation::BLS_BatchVerify& op, const ExecutorBase<bool, operation::BLS_BatchVerify>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n    (void)result;\n}\n\ntemplate<> std::optional<bool> ExecutorBase<bool, operation::BLS_BatchVerify>::callModule(std::shared_ptr<Module> module, operation::BLS_BatchVerify& op) const {\n    return module->OpBLS_BatchVerify(op);\n}\n\n\ntemplate class ExecutorBase<bool, operation::BLS_BatchVerify>;"}
{"text_input": "Generate BLS_Aggregate_G1 code for executor.cpp", "output": "/* Specialization for operation::BLS_Aggregate_G1 */template<> void ExecutorBase<component::G1, operation::BLS_Aggregate_G1>::postprocess(std::shared_ptr<Module> module, operation::BLS_Aggregate_G1& op, const ExecutorBase<component::G1, operation::BLS_Aggregate_G1>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n    (void)result;\n}\n\ntemplate<> std::optional<component::G1> ExecutorBase<component::G1, operation::BLS_Aggregate_G1>::callModule(std::shared_ptr<Module> module, operation::BLS_Aggregate_G1& op) const {\n    return module->OpBLS_Aggregate_G1(op);\n}\n\n\ntemplate class ExecutorBase<component::G1, operation::BLS_Aggregate_G1>;"}
{"text_input": "Generate BLS_Aggregate_G2 code for executor.cpp", "output": "/* Specialization for operation::BLS_Aggregate_G2 */template<> void ExecutorBase<component::G2, operation::BLS_Aggregate_G2>::postprocess(std::shared_ptr<Module> module, operation::BLS_Aggregate_G2& op, const ExecutorBase<component::G2, operation::BLS_Aggregate_G2>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n    (void)result;\n}\n\ntemplate<> std::optional<component::G2> ExecutorBase<component::G2, operation::BLS_Aggregate_G2>::callModule(std::shared_ptr<Module> module, operation::BLS_Aggregate_G2& op) const {\n    return module->OpBLS_Aggregate_G2(op);\n}\n\n\ntemplate class ExecutorBase<component::G2, operation::BLS_Aggregate_G2>;"}
{"text_input": "Generate BLS_Pairing code for executor.cpp", "output": "/* Specialization for operation::BLS_Pairing */template<> void ExecutorBase<component::Fp12, operation::BLS_Pairing>::postprocess(std::shared_ptr<Module> module, operation::BLS_Pairing& op, const ExecutorBase<component::Fp12, operation::BLS_Pairing>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n\n    if ( result.second != std::nullopt  ) {\n        Pool_Fp12.Set({\n                result.second->bn1.ToTrimmedString(),\n                result.second->bn2.ToTrimmedString(),\n                result.second->bn3.ToTrimmedString(),\n                result.second->bn4.ToTrimmedString(),\n                result.second->bn5.ToTrimmedString(),\n                result.second->bn6.ToTrimmedString(),\n                result.second->bn7.ToTrimmedString(),\n                result.second->bn8.ToTrimmedString(),\n                result.second->bn9.ToTrimmedString(),\n                result.second->bn10.ToTrimmedString(),\n                result.second->bn11.ToTrimmedString(),\n                result.second->bn12.ToTrimmedString()\n        });\n    }\n}\n\ntemplate<> std::optional<component::Fp12> ExecutorBase<component::Fp12, operation::BLS_Pairing>::callModule(std::shared_ptr<Module> module, operation::BLS_Pairing& op) const {\n    return module->OpBLS_Pairing(op);\n}\n\n\ntemplate class ExecutorBase<component::Fp12, operation::BLS_Pairing>;"}
{"text_input": "Generate BLS_MillerLoop code for executor.cpp", "output": "/* Specialization for operation::BLS_MillerLoop */template<> void ExecutorBase<component::Fp12, operation::BLS_MillerLoop>::postprocess(std::shared_ptr<Module> module, operation::BLS_MillerLoop& op, const ExecutorBase<component::Fp12, operation::BLS_MillerLoop>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n\n    if ( result.second != std::nullopt  ) {\n        Pool_Fp12.Set({\n                result.second->bn1.ToTrimmedString(),\n                result.second->bn2.ToTrimmedString(),\n                result.second->bn3.ToTrimmedString(),\n                result.second->bn4.ToTrimmedString(),\n                result.second->bn5.ToTrimmedString(),\n                result.second->bn6.ToTrimmedString(),\n                result.second->bn7.ToTrimmedString(),\n                result.second->bn8.ToTrimmedString(),\n                result.second->bn9.ToTrimmedString(),\n                result.second->bn10.ToTrimmedString(),\n                result.second->bn11.ToTrimmedString(),\n                result.second->bn12.ToTrimmedString()\n        });\n    }\n}\n\ntemplate<> std::optional<component::Fp12> ExecutorBase<component::Fp12, operation::BLS_MillerLoop>::callModule(std::shared_ptr<Module> module, operation::BLS_MillerLoop& op) const {\n    return module->OpBLS_MillerLoop(op);\n}\n\n\ntemplate class ExecutorBase<component::Fp12, operation::BLS_MillerLoop>;"}
{"text_input": "Generate BLS_FinalExp code for executor.cpp", "output": "/* Specialization for operation::BLS_FinalExp */template<> void ExecutorBase<component::Fp12, operation::BLS_FinalExp>::postprocess(std::shared_ptr<Module> module, operation::BLS_FinalExp& op, const ExecutorBase<component::Fp12, operation::BLS_FinalExp>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n\n    if ( result.second != std::nullopt  ) {\n        Pool_Fp12.Set({\n                result.second->bn1.ToTrimmedString(),\n                result.second->bn2.ToTrimmedString(),\n                result.second->bn3.ToTrimmedString(),\n                result.second->bn4.ToTrimmedString(),\n                result.second->bn5.ToTrimmedString(),\n                result.second->bn6.ToTrimmedString(),\n                result.second->bn7.ToTrimmedString(),\n                result.second->bn8.ToTrimmedString(),\n                result.second->bn9.ToTrimmedString(),\n                result.second->bn10.ToTrimmedString(),\n                result.second->bn11.ToTrimmedString(),\n                result.second->bn12.ToTrimmedString()\n        });\n    }\n}\n\ntemplate<> std::optional<component::Fp12> ExecutorBase<component::Fp12, operation::BLS_FinalExp>::callModule(std::shared_ptr<Module> module, operation::BLS_FinalExp& op) const {\n    RETURN_IF_DISABLED(options.curves, op.curveType.Get());\n    return module->OpBLS_FinalExp(op);\n}\n\n\ntemplate class ExecutorBase<component::Fp12, operation::BLS_FinalExp>;"}
{"text_input": "Generate BLS_HashToG1 code for executor.cpp", "output": "/* Specialization for operation::BLS_HashToG1 */template<> void ExecutorBase<component::G1, operation::BLS_HashToG1>::postprocess(std::shared_ptr<Module> module, operation::BLS_HashToG1& op, const ExecutorBase<component::G1, operation::BLS_HashToG1>::ResultPair& result) const {\n    (void)module;\n\n    if ( result.second != std::nullopt  ) {\n        const auto curveID = op.curveType.Get();\n        const auto g1_x = result.second->first.ToTrimmedString();\n        const auto g1_y = result.second->second.ToTrimmedString();\n\n        G1AddToPool(curveID, g1_x, g1_y);\n\n        if ( g1_x.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(g1_x); }\n        if ( g1_y.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(g1_y); }\n    }\n}\n\ntemplate<> std::optional<component::G1> ExecutorBase<component::G1, operation::BLS_HashToG1>::callModule(std::shared_ptr<Module> module, operation::BLS_HashToG1& op) const {\n    RETURN_IF_DISABLED(options.curves, op.curveType.Get());\n    return module->OpBLS_HashToG1(op);\n}\n\n\ntemplate class ExecutorBase<component::G1, operation::BLS_HashToG1>;"}
{"text_input": "Generate BLS_MapToG1 code for executor.cpp", "output": "/* Specialization for operation::BLS_MapToG1 */template<> void ExecutorBase<component::G1, operation::BLS_MapToG1>::postprocess(std::shared_ptr<Module> module, operation::BLS_MapToG1& op, const ExecutorBase<component::G1, operation::BLS_MapToG1>::ResultPair& result) const {\n    (void)module;\n\n    if ( result.second != std::nullopt  ) {\n        const auto curveID = op.curveType.Get();\n        const auto g1_x = result.second->first.ToTrimmedString();\n        const auto g1_y = result.second->second.ToTrimmedString();\n\n        G1AddToPool(curveID, g1_x, g1_y);\n\n        if ( g1_x.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(g1_x); }\n        if ( g1_y.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(g1_y); }\n    }\n}\n\ntemplate<> std::optional<component::G1> ExecutorBase<component::G1, operation::BLS_MapToG1>::callModule(std::shared_ptr<Module> module, operation::BLS_MapToG1& op) const {\n    return module->OpBLS_MapToG1(op);\n}\n\n\ntemplate class ExecutorBase<component::G1, operation::BLS_MapToG1>;"}
{"text_input": "Generate BLS_MapToG2 code for executor.cpp", "output": "/* Specialization for operation::BLS_MapToG2 */template<> void ExecutorBase<component::G2, operation::BLS_MapToG2>::postprocess(std::shared_ptr<Module> module, operation::BLS_MapToG2& op, const ExecutorBase<component::G2, operation::BLS_MapToG2>::ResultPair& result) const {\n    (void)module;\n\n    if ( result.second != std::nullopt  ) {\n        const auto curveID = op.curveType.Get();\n        const auto g2_v = result.second->first.first.ToTrimmedString();\n        const auto g2_w = result.second->first.second.ToTrimmedString();\n        const auto g2_x = result.second->second.first.ToTrimmedString();\n        const auto g2_y = result.second->second.second.ToTrimmedString();\n\n        G2AddToPool(curveID, g2_v, g2_w, g2_x, g2_y);\n\n        if ( g2_v.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(g2_v); }\n        if ( g2_w.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(g2_w); }\n        if ( g2_x.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(g2_x); }\n        if ( g2_y.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(g2_y); }\n    }\n}\n\ntemplate<> std::optional<component::G2> ExecutorBase<component::G2, operation::BLS_MapToG2>::callModule(std::shared_ptr<Module> module, operation::BLS_MapToG2& op) const {\n    return module->OpBLS_MapToG2(op);\n}\n\n\ntemplate class ExecutorBase<component::G2, operation::BLS_MapToG2>;"}
{"text_input": "Generate BLS_IsG1OnCurve code for executor.cpp", "output": "/* Specialization for operation::BLS_IsG1OnCurve */template<> void ExecutorBase<bool, operation::BLS_IsG1OnCurve>::postprocess(std::shared_ptr<Module> module, operation::BLS_IsG1OnCurve& op, const ExecutorBase<bool, operation::BLS_IsG1OnCurve>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n    (void)result;\n}\n\ntemplate<> std::optional<bool> ExecutorBase<bool, operation::BLS_IsG1OnCurve>::callModule(std::shared_ptr<Module> module, operation::BLS_IsG1OnCurve& op) const {\n    RETURN_IF_DISABLED(options.curves, op.curveType.Get());\n    if ( op.g1.first.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.g1.second.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n\n    return module->OpBLS_IsG1OnCurve(op);\n}\n\n\ntemplate class ExecutorBase<bool, operation::BLS_IsG1OnCurve>;"}
{"text_input": "Generate BLS_IsG2OnCurve code for executor.cpp", "output": "/* Specialization for operation::BLS_IsG2OnCurve */template<> void ExecutorBase<bool, operation::BLS_IsG2OnCurve>::postprocess(std::shared_ptr<Module> module, operation::BLS_IsG2OnCurve& op, const ExecutorBase<bool, operation::BLS_IsG2OnCurve>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n    (void)result;\n}\n\ntemplate<> std::optional<bool> ExecutorBase<bool, operation::BLS_IsG2OnCurve>::callModule(std::shared_ptr<Module> module, operation::BLS_IsG2OnCurve& op) const {\n    if ( op.g2.first.first.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.g2.first.second.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.g2.second.first.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.g2.second.second.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n\n    return module->OpBLS_IsG2OnCurve(op);\n}\n\n\ntemplate class ExecutorBase<bool, operation::BLS_IsG2OnCurve>;"}
{"text_input": "Generate BLS_GenerateKeyPair code for executor.cpp", "output": "/* Specialization for operation::BLS_GenerateKeyPair */template<> void ExecutorBase<component::BLS_KeyPair, operation::BLS_GenerateKeyPair>::postprocess(std::shared_ptr<Module> module, operation::BLS_GenerateKeyPair& op, const ExecutorBase<component::BLS_KeyPair, operation::BLS_GenerateKeyPair>::ResultPair& result) const {\n    (void)module;\n\n    if ( result.second != std::nullopt  ) {\n        const auto curveID = op.curveType.Get();\n        const auto priv = result.second->priv.ToTrimmedString();\n        const auto g1_x = result.second->pub.first.ToTrimmedString();\n        const auto g1_y = result.second->pub.second.ToTrimmedString();\n\n        G1AddToPool(curveID, g1_x, g1_y);\n\n        if ( priv.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(priv); }\n        if ( g1_x.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(g1_x); }\n        if ( g1_y.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(g1_y); }\n    }\n}\n\ntemplate<> std::optional<component::BLS_KeyPair> ExecutorBase<component::BLS_KeyPair, operation::BLS_GenerateKeyPair>::callModule(std::shared_ptr<Module> module, operation::BLS_GenerateKeyPair& op) const {\n    return module->OpBLS_GenerateKeyPair(op);\n}\n\n\ntemplate class ExecutorBase<component::BLS_KeyPair, operation::BLS_GenerateKeyPair>;"}
{"text_input": "Generate BLS_Decompress_G1 code for executor.cpp", "output": "/* Specialization for operation::BLS_Decompress_G1 */template<> void ExecutorBase<component::G1, operation::BLS_Decompress_G1>::postprocess(std::shared_ptr<Module> module, operation::BLS_Decompress_G1& op, const ExecutorBase<component::G1, operation::BLS_Decompress_G1>::ResultPair& result) const {\n    (void)module;\n\n    if ( result.second != std::nullopt  ) {\n        const auto curveID = op.curveType.Get();\n        const auto g1_x = result.second->first.ToTrimmedString();\n        const auto g1_y = result.second->second.ToTrimmedString();\n\n        G1AddToPool(curveID, g1_x, g1_y);\n\n        if ( g1_x.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(g1_x); }\n        if ( g1_y.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(g1_y); }\n    }\n}\n\ntemplate<> std::optional<component::G1> ExecutorBase<component::G1, operation::BLS_Decompress_G1>::callModule(std::shared_ptr<Module> module, operation::BLS_Decompress_G1& op) const {\n    return module->OpBLS_Decompress_G1(op);\n}\n\n\ntemplate class ExecutorBase<component::G1, operation::BLS_Decompress_G1>;"}
{"text_input": "Generate BLS_Compress_G1 code for executor.cpp", "output": "/* Specialization for operation::BLS_Compress_G1 */template<> void ExecutorBase<component::Bignum, operation::BLS_Compress_G1>::postprocess(std::shared_ptr<Module> module, operation::BLS_Compress_G1& op, const ExecutorBase<component::Bignum, operation::BLS_Compress_G1>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n\n    if ( result.second != std::nullopt  ) {\n        const auto compressed = result.second->ToTrimmedString();\n\n        if ( compressed.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(compressed); }\n    }\n}\n\ntemplate<> std::optional<component::Bignum> ExecutorBase<component::Bignum, operation::BLS_Compress_G1>::callModule(std::shared_ptr<Module> module, operation::BLS_Compress_G1& op) const {\n    return module->OpBLS_Compress_G1(op);\n}\n\n\ntemplate class ExecutorBase<component::Bignum, operation::BLS_Compress_G1>;"}
{"text_input": "Generate BLS_Decompress_G2 code for executor.cpp", "output": "/* Specialization for operation::BLS_Decompress_G2 */template<> void ExecutorBase<component::G2, operation::BLS_Decompress_G2>::postprocess(std::shared_ptr<Module> module, operation::BLS_Decompress_G2& op, const ExecutorBase<component::G2, operation::BLS_Decompress_G2>::ResultPair& result) const {\n    (void)module;\n\n    if ( result.second != std::nullopt  ) {\n        const auto curveID = op.curveType.Get();\n        const auto g2_v = result.second->first.first.ToTrimmedString();\n        const auto g2_w = result.second->first.second.ToTrimmedString();\n        const auto g2_x = result.second->second.first.ToTrimmedString();\n        const auto g2_y = result.second->second.second.ToTrimmedString();\n\n        G2AddToPool(curveID, g2_v, g2_w, g2_x, g2_y);\n\n        if ( g2_v.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(g2_v); }\n        if ( g2_w.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(g2_w); }\n        if ( g2_x.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(g2_x); }\n        if ( g2_y.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(g2_y); }\n    }\n}\n\ntemplate<> std::optional<component::G2> ExecutorBase<component::G2, operation::BLS_Decompress_G2>::callModule(std::shared_ptr<Module> module, operation::BLS_Decompress_G2& op) const {\n    return module->OpBLS_Decompress_G2(op);\n}\n\n\ntemplate class ExecutorBase<component::G2, operation::BLS_Decompress_G2>;"}
{"text_input": "Generate BLS_Compress_G2 code for executor.cpp", "output": "/* Specialization for operation::BLS_Compress_G2 */template<> void ExecutorBase<component::G1, operation::BLS_Compress_G2>::postprocess(std::shared_ptr<Module> module, operation::BLS_Compress_G2& op, const ExecutorBase<component::G1, operation::BLS_Compress_G2>::ResultPair& result) const {\n    (void)module;\n\n    if ( result.second != std::nullopt  ) {\n        const auto curveID = op.curveType.Get();\n        const auto g1_x = result.second->first.ToTrimmedString();\n        const auto g1_y = result.second->second.ToTrimmedString();\n\n        G1AddToPool(curveID, g1_x, g1_y);\n\n        if ( g1_x.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(g1_x); }\n        if ( g1_y.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(g1_y); }\n    }\n}\n\ntemplate<> std::optional<component::G1> ExecutorBase<component::G1, operation::BLS_Compress_G2>::callModule(std::shared_ptr<Module> module, operation::BLS_Compress_G2& op) const {\n    return module->OpBLS_Compress_G2(op);\n}\n\n\ntemplate class ExecutorBase<component::G1, operation::BLS_Compress_G2>;"}
{"text_input": "Generate BLS_G1_Add code for executor.cpp", "output": "/* Specialization for operation::BLS_G1_Add */template<> void ExecutorBase<component::G1, operation::BLS_G1_Add>::postprocess(std::shared_ptr<Module> module, operation::BLS_G1_Add& op, const ExecutorBase<component::G1, operation::BLS_G1_Add>::ResultPair& result) const {\n    (void)module;\n\n    if ( result.second != std::nullopt  ) {\n        const auto curveID = op.curveType.Get();\n        const auto g1_x = result.second->first.ToTrimmedString();\n        const auto g1_y = result.second->second.ToTrimmedString();\n\n        G1AddToPool(curveID, g1_x, g1_y);\n\n        if ( g1_x.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(g1_x); }\n        if ( g1_y.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(g1_y); }\n    }\n}\n\ntemplate<> std::optional<component::G1> ExecutorBase<component::G1, operation::BLS_G1_Add>::callModule(std::shared_ptr<Module> module, operation::BLS_G1_Add& op) const {\n    RETURN_IF_DISABLED(options.curves, op.curveType.Get());\n    if ( op.a.first.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.a.second.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.b.first.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.b.second.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n\n    return module->OpBLS_G1_Add(op);\n}\n\n\ntemplate class ExecutorBase<component::G1, operation::BLS_G1_Add>;"}
{"text_input": "Generate BLS_G1_Mul code for executor.cpp", "output": "/* Specialization for operation::BLS_G1_Mul */template<> void ExecutorBase<component::G1, operation::BLS_G1_Mul>::postprocess(std::shared_ptr<Module> module, operation::BLS_G1_Mul& op, const ExecutorBase<component::G1, operation::BLS_G1_Mul>::ResultPair& result) const {\n    (void)module;\n\n    if ( result.second != std::nullopt  ) {\n        const auto curveID = op.curveType.Get();\n        const auto g1_x = result.second->first.ToTrimmedString();\n        const auto g1_y = result.second->second.ToTrimmedString();\n\n        G1AddToPool(curveID, g1_x, g1_y);\n\n        if ( g1_x.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(g1_x); }\n        if ( g1_y.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(g1_y); }\n    }\n}\n\ntemplate<> std::optional<component::G1> ExecutorBase<component::G1, operation::BLS_G1_Mul>::callModule(std::shared_ptr<Module> module, operation::BLS_G1_Mul& op) const {\n    RETURN_IF_DISABLED(options.curves, op.curveType.Get());\n    if ( op.a.first.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.a.second.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.b.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n\n    return module->OpBLS_G1_Mul(op);\n}\n\n\ntemplate class ExecutorBase<component::G1, operation::BLS_G1_Mul>;"}
{"text_input": "Generate BLS_G1_IsEq code for executor.cpp", "output": "/* Specialization for operation::BLS_G1_IsEq */template<> void ExecutorBase<bool, operation::BLS_G1_IsEq>::postprocess(std::shared_ptr<Module> module, operation::BLS_G1_IsEq& op, const ExecutorBase<bool, operation::BLS_G1_IsEq>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n    (void)result;\n}\n\ntemplate<> std::optional<bool> ExecutorBase<bool, operation::BLS_G1_IsEq>::callModule(std::shared_ptr<Module> module, operation::BLS_G1_IsEq& op) const {\n    RETURN_IF_DISABLED(options.curves, op.curveType.Get());\n    if ( op.a.first.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.a.second.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.b.first.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.b.second.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n\n    return module->OpBLS_G1_IsEq(op);\n}\n\n\ntemplate class ExecutorBase<bool, operation::BLS_G1_IsEq>;"}
{"text_input": "Generate BLS_G1_Neg code for executor.cpp", "output": "/* Specialization for operation::BLS_G1_Neg */template<> void ExecutorBase<component::G1, operation::BLS_G1_Neg>::postprocess(std::shared_ptr<Module> module, operation::BLS_G1_Neg& op, const ExecutorBase<component::G1, operation::BLS_G1_Neg>::ResultPair& result) const {\n    (void)module;\n\n    if ( result.second != std::nullopt  ) {\n        const auto curveID = op.curveType.Get();\n        const auto g1_x = result.second->first.ToTrimmedString();\n        const auto g1_y = result.second->second.ToTrimmedString();\n\n        G1AddToPool(curveID, g1_x, g1_y);\n\n        if ( g1_x.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(g1_x); }\n        if ( g1_y.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(g1_y); }\n    }\n}\n\ntemplate<> std::optional<component::G1> ExecutorBase<component::G1, operation::BLS_G1_Neg>::callModule(std::shared_ptr<Module> module, operation::BLS_G1_Neg& op) const {\n    RETURN_IF_DISABLED(options.curves, op.curveType.Get());\n    if ( op.a.first.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.a.second.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n\n    return module->OpBLS_G1_Neg(op);\n}\n\n\ntemplate class ExecutorBase<component::G1, operation::BLS_G1_Neg>;"}
{"text_input": "Generate BLS_G2_Add code for executor.cpp", "output": "/* Specialization for operation::BLS_G2_Add */template<> void ExecutorBase<component::G2, operation::BLS_G2_Add>::postprocess(std::shared_ptr<Module> module, operation::BLS_G2_Add& op, const ExecutorBase<component::G2, operation::BLS_G2_Add>::ResultPair& result) const {\n    (void)module;\n\n    if ( result.second != std::nullopt  ) {\n        const auto curveID = op.curveType.Get();\n        const auto g2_v = result.second->first.first.ToTrimmedString();\n        const auto g2_w = result.second->first.second.ToTrimmedString();\n        const auto g2_x = result.second->second.first.ToTrimmedString();\n        const auto g2_y = result.second->second.second.ToTrimmedString();\n\n        G2AddToPool(curveID, g2_v, g2_w, g2_x, g2_y);\n\n        if ( g2_v.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(g2_v); }\n        if ( g2_w.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(g2_w); }\n        if ( g2_x.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(g2_x); }\n        if ( g2_y.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(g2_y); }\n    }\n}\n\ntemplate<> std::optional<component::G2> ExecutorBase<component::G2, operation::BLS_G2_Add>::callModule(std::shared_ptr<Module> module, operation::BLS_G2_Add& op) const {\n    RETURN_IF_DISABLED(options.curves, op.curveType.Get());\n    if ( op.a.first.first.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.a.first.second.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.a.second.first.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.a.second.second.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.b.first.first.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.b.first.second.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.b.second.first.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.b.second.second.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n\n    return module->OpBLS_G2_Add(op);\n}\n\n\ntemplate class ExecutorBase<component::G2, operation::BLS_G2_Add>;"}
{"text_input": "Generate BLS_G2_Mul code for executor.cpp", "output": "/* Specialization for operation::BLS_G2_Mul */template<> void ExecutorBase<component::G2, operation::BLS_G2_Mul>::postprocess(std::shared_ptr<Module> module, operation::BLS_G2_Mul& op, const ExecutorBase<component::G2, operation::BLS_G2_Mul>::ResultPair& result) const {\n    (void)module;\n\n    if ( result.second != std::nullopt  ) {\n        const auto curveID = op.curveType.Get();\n        const auto g2_v = result.second->first.first.ToTrimmedString();\n        const auto g2_w = result.second->first.second.ToTrimmedString();\n        const auto g2_x = result.second->second.first.ToTrimmedString();\n        const auto g2_y = result.second->second.second.ToTrimmedString();\n\n        G2AddToPool(curveID, g2_v, g2_w, g2_x, g2_y);\n\n        if ( g2_v.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(g2_v); }\n        if ( g2_w.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(g2_w); }\n        if ( g2_x.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(g2_x); }\n        if ( g2_y.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(g2_y); }\n    }\n}\n\ntemplate<> std::optional<component::G2> ExecutorBase<component::G2, operation::BLS_G2_Mul>::callModule(std::shared_ptr<Module> module, operation::BLS_G2_Mul& op) const {\n    RETURN_IF_DISABLED(options.curves, op.curveType.Get());\n    if ( op.a.first.first.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.a.first.second.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.a.second.first.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.a.second.second.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.b.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n\n    return module->OpBLS_G2_Mul(op);\n}\n\n\ntemplate class ExecutorBase<component::G2, operation::BLS_G2_Mul>;"}
{"text_input": "Generate BLS_G2_IsEq code for executor.cpp", "output": "/* Specialization for operation::BLS_G2_IsEq */template<> void ExecutorBase<bool, operation::BLS_G2_IsEq>::postprocess(std::shared_ptr<Module> module, operation::BLS_G2_IsEq& op, const ExecutorBase<bool, operation::BLS_G2_IsEq>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n    (void)result;\n}\n\ntemplate<> std::optional<bool> ExecutorBase<bool, operation::BLS_G2_IsEq>::callModule(std::shared_ptr<Module> module, operation::BLS_G2_IsEq& op) const {\n    RETURN_IF_DISABLED(options.curves, op.curveType.Get());\n    if ( op.a.first.first.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.a.first.second.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.a.second.first.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.a.second.second.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.b.first.first.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.b.first.second.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.b.second.first.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.b.second.second.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n\n    return module->OpBLS_G2_IsEq(op);\n}\n\n\ntemplate class ExecutorBase<bool, operation::BLS_G2_IsEq>;"}
{"text_input": "Generate BLS_G2_Neg code for executor.cpp", "output": "/* Specialization for operation::BLS_G2_Neg */template<> void ExecutorBase<component::G2, operation::BLS_G2_Neg>::postprocess(std::shared_ptr<Module> module, operation::BLS_G2_Neg& op, const ExecutorBase<component::G2, operation::BLS_G2_Neg>::ResultPair& result) const {\n    (void)module;\n\n    if ( result.second != std::nullopt  ) {\n        const auto curveID = op.curveType.Get();\n        const auto g2_v = result.second->first.first.ToTrimmedString();\n        const auto g2_w = result.second->first.second.ToTrimmedString();\n        const auto g2_x = result.second->second.first.ToTrimmedString();\n        const auto g2_y = result.second->second.second.ToTrimmedString();\n\n        G2AddToPool(curveID, g2_v, g2_w, g2_x, g2_y);\n\n        if ( g2_v.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(g2_v); }\n        if ( g2_w.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(g2_w); }\n        if ( g2_x.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(g2_x); }\n        if ( g2_y.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(g2_y); }\n    }\n}\n\ntemplate<> std::optional<component::G2> ExecutorBase<component::G2, operation::BLS_G2_Neg>::callModule(std::shared_ptr<Module> module, operation::BLS_G2_Neg& op) const {\n    RETURN_IF_DISABLED(options.curves, op.curveType.Get());\n    if ( op.a.first.first.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.a.first.second.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.a.second.first.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.a.second.second.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n\n    return module->OpBLS_G2_Neg(op);\n}\n\n\ntemplate class ExecutorBase<component::G2, operation::BLS_G2_Neg>;"}
{"text_input": "Generate BLS_G1_MultiExp code for executor.cpp", "output": "/* Specialization for operation::BLS_G1_MultiExp */template<> void ExecutorBase<component::G1, operation::BLS_G1_MultiExp>::postprocess(std::shared_ptr<Module> module, operation::BLS_G1_MultiExp& op, const ExecutorBase<component::G1, operation::BLS_G1_MultiExp>::ResultPair& result) const {\n    (void)module;\n\n    if ( result.second != std::nullopt  ) {\n        const auto curveID = op.curveType.Get();\n        const auto g1_x = result.second->first.ToTrimmedString();\n        const auto g1_y = result.second->second.ToTrimmedString();\n\n        G1AddToPool(curveID, g1_x, g1_y);\n\n        if ( g1_x.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(g1_x); }\n        if ( g1_y.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(g1_y); }\n    }\n}\n\ntemplate<> std::optional<component::G1> ExecutorBase<component::G1, operation::BLS_G1_MultiExp>::callModule(std::shared_ptr<Module> module, operation::BLS_G1_MultiExp& op) const {\n    RETURN_IF_DISABLED(options.curves, op.curveType.Get());\n\n    for (const auto& point_scalar : op.points_scalars.points_scalars) {\n        if ( point_scalar.first.first.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n        if ( point_scalar.first.second.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n        if ( point_scalar.second.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    }\n\n    return module->OpBLS_G1_MultiExp(op);\n}\n\n\ntemplate class ExecutorBase<component::G1, operation::BLS_G1_MultiExp>;"}
{"text_input": "Generate Misc code for executor.cpp", "output": "/* Specialization for operation::Misc */template<> void ExecutorBase<Buffer, operation::Misc>::postprocess(std::shared_ptr<Module> module, operation::Misc& op, const ExecutorBase<Buffer, operation::Misc>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n    (void)result;\n}\n\ntemplate<> std::optional<Buffer> ExecutorBase<Buffer, operation::Misc>::callModule(std::shared_ptr<Module> module, operation::Misc& op) const {\n    return module->OpMisc(op);\n}\n\n\ntemplate class ExecutorBase<Buffer, operation::Misc>;"}
{"text_input": "Generate BLS_HashToG2 code for executor.cpp", "output": "/* Specialization for operation::BLS_HashToG2 */template<> void ExecutorBase<component::G2, operation::BLS_HashToG2>::postprocess(std::shared_ptr<Module> module, operation::BLS_HashToG2& op, const ExecutorBase<component::G2, operation::BLS_HashToG2>::ResultPair& result) const {\n    (void)module;\n\n    if ( result.second != std::nullopt  ) {\n        const auto curveID = op.curveType.Get();\n        const auto g2_v = result.second->first.first.ToTrimmedString();\n        const auto g2_w = result.second->first.second.ToTrimmedString();\n        const auto g2_x = result.second->second.first.ToTrimmedString();\n        const auto g2_y = result.second->second.second.ToTrimmedString();\n\n        G2AddToPool(curveID, g2_v, g2_w, g2_x, g2_y);\n\n        if ( g2_v.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(g2_v); }\n        if ( g2_w.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(g2_w); }\n        if ( g2_x.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(g2_x); }\n        if ( g2_y.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(g2_y); }\n    }\n}\n\ntemplate<> std::optional<component::G2> ExecutorBase<component::G2, operation::BLS_HashToG2>::callModule(std::shared_ptr<Module> module, operation::BLS_HashToG2& op) const {\n    RETURN_IF_DISABLED(options.curves, op.curveType.Get());\n    return module->OpBLS_HashToG2(op);\n}\n\n\ntemplate class ExecutorBase<component::G2, operation::BLS_HashToG2>;"}
{"text_input": "Generate SR25519_Verify code for executor.cpp", "output": "/* Specialization for operation::SR25519_Verify */template<> void ExecutorBase<bool, operation::SR25519_Verify>::postprocess(std::shared_ptr<Module> module, operation::SR25519_Verify& op, const ExecutorBase<bool, operation::SR25519_Verify>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n    (void)result;\n}\n\ntemplate<> std::optional<bool> ExecutorBase<bool, operation::SR25519_Verify>::callModule(std::shared_ptr<Module> module, operation::SR25519_Verify& op) const {\n    return module->OpSR25519_Verify(op);\n}\n\n\ntemplate class ExecutorBase<bool, operation::SR25519_Verify>;"}
{"text_input": "Generate Digest code for driver.cpp", "output": "    static ExecutorDigest executorDigest(CF_OPERATION(\"Digest\"), modules, options);\n            case CF_OPERATION(\"Digest\"):                executorDigest.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate HMAC code for driver.cpp", "output": "    static ExecutorHMAC executorHMAC(CF_OPERATION(\"HMAC\"), modules, options);\n            case CF_OPERATION(\"HMAC\"):                executorHMAC.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate UMAC code for driver.cpp", "output": "    static ExecutorUMAC executorUMAC(CF_OPERATION(\"UMAC\"), modules, options);\n            case CF_OPERATION(\"UMAC\"):                executorUMAC.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate CMAC code for driver.cpp", "output": "    static ExecutorCMAC executorCMAC(CF_OPERATION(\"CMAC\"), modules, options);\n            case CF_OPERATION(\"CMAC\"):                executorCMAC.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate SymmetricEncrypt code for driver.cpp", "output": "    static ExecutorSymmetricEncrypt executorSymmetricEncrypt(CF_OPERATION(\"SymmetricEncrypt\"), modules, options);\n            case CF_OPERATION(\"SymmetricEncrypt\"):                executorSymmetricEncrypt.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate SymmetricDecrypt code for driver.cpp", "output": "    static ExecutorSymmetricDecrypt executorSymmetricDecrypt(CF_OPERATION(\"SymmetricDecrypt\"), modules, options);\n            case CF_OPERATION(\"SymmetricDecrypt\"):                executorSymmetricDecrypt.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate KDF_SCRYPT code for driver.cpp", "output": "    static ExecutorKDF_SCRYPT executorKDF_SCRYPT(CF_OPERATION(\"KDF_SCRYPT\"), modules, options);\n            case CF_OPERATION(\"KDF_SCRYPT\"):                executorKDF_SCRYPT.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate KDF_HKDF code for driver.cpp", "output": "    static ExecutorKDF_HKDF executorKDF_HKDF(CF_OPERATION(\"KDF_HKDF\"), modules, options);\n            case CF_OPERATION(\"KDF_HKDF\"):                executorKDF_HKDF.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate KDF_TLS1_PRF code for driver.cpp", "output": "    static ExecutorKDF_TLS1_PRF executorKDF_TLS1_PRF(CF_OPERATION(\"KDF_TLS1_PRF\"), modules, options);\n            case CF_OPERATION(\"KDF_TLS1_PRF\"):                executorKDF_TLS1_PRF.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate KDF_PBKDF code for driver.cpp", "output": "    static ExecutorKDF_PBKDF executorKDF_PBKDF(CF_OPERATION(\"KDF_PBKDF\"), modules, options);\n            case CF_OPERATION(\"KDF_PBKDF\"):                executorKDF_PBKDF.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate KDF_PBKDF1 code for driver.cpp", "output": "    static ExecutorKDF_PBKDF1 executorKDF_PBKDF1(CF_OPERATION(\"KDF_PBKDF1\"), modules, options);\n            case CF_OPERATION(\"KDF_PBKDF1\"):                executorKDF_PBKDF1.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate KDF_PBKDF2 code for driver.cpp", "output": "    static ExecutorKDF_PBKDF2 executorKDF_PBKDF2(CF_OPERATION(\"KDF_PBKDF2\"), modules, options);\n            case CF_OPERATION(\"KDF_PBKDF2\"):                executorKDF_PBKDF2.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate KDF_ARGON2 code for driver.cpp", "output": "    static ExecutorKDF_ARGON2 executorKDF_ARGON2(CF_OPERATION(\"KDF_ARGON2\"), modules, options);\n            case CF_OPERATION(\"KDF_ARGON2\"):                executorKDF_ARGON2.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate KDF_SSH code for driver.cpp", "output": "    static ExecutorKDF_SSH executorKDF_SSH(ID(\"KDF_SSH\"), modules, options);\n            case CF_OPERATION(\"KDF_SSH\"):                executorKDF_SSH.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate KDF_X963 code for driver.cpp", "output": "    static ExecutorKDF_X963 executorKDF_X963(CF_OPERATION(\"KDF_X963\"), modules, options);\n            case CF_OPERATION(\"KDF_X963\"):                executorKDF_X963.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate KDF_BCRYPT code for driver.cpp", "output": "    static ExecutorKDF_BCRYPT executorKDF_BCRYPT(CF_OPERATION(\"KDF_BCRYPT\"), modules, options);\n            case CF_OPERATION(\"KDF_BCRYPT\"):                executorKDF_BCRYPT.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate KDF_SP_800_108 code for driver.cpp", "output": "    static ExecutorKDF_SP_800_108 executorKDF_SP_800_108(CF_OPERATION(\"KDF_SP_800_108\"), modules, options);\n            case CF_OPERATION(\"KDF_SP_800_108\"):                executorKDF_SP_800_108.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate KDF_SRTP code for driver.cpp", "output": "    static ExecutorKDF_SRTP executorKDF_SRTP(CF_OPERATION(\"KDF_SRTP\"), modules, options);\n            case CF_OPERATION(\"KDF_SRTP\"):                executorKDF_SRTP.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate KDF_SRTCP code for driver.cpp", "output": "    static ExecutorKDF_SRTCP executorKDF_SRTCP(CF_OPERATION(\"KDF_SRTCP\"), modules, options);\n            case CF_OPERATION(\"KDF_SRTCP\"):                executorKDF_SRTCP.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate ECC_PrivateToPublic code for driver.cpp", "output": "    static ExecutorECC_PrivateToPublic executorECC_PrivateToPublic(CF_OPERATION(\"ECC_PrivateToPublic\"), modules, options);\n            case CF_OPERATION(\"ECC_PrivateToPublic\"):                executorECC_PrivateToPublic.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate ECC_ValidatePubkey code for driver.cpp", "output": "    static ExecutorECC_ValidatePubkey executorECC_ValidatePubkey(CF_OPERATION(\"ECC_ValidatePubkey\"), modules, options);\n            case CF_OPERATION(\"ECC_ValidatePubkey\"):                executorECC_ValidatePubkey.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate ECC_GenerateKeyPair code for driver.cpp", "output": "    static ExecutorECC_GenerateKeyPair executorECC_GenerateKeyPair(CF_OPERATION(\"ECC_GenerateKeyPair\"), modules, options);\n            case CF_OPERATION(\"ECC_GenerateKeyPair\"):                executorECC_GenerateKeyPair.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate ECCSI_Sign code for driver.cpp", "output": "    static ExecutorECCSI_Sign executorECCSI_Sign(CF_OPERATION(\"ECCSI_Sign\"), modules, options);\n            case CF_OPERATION(\"ECCSI_Sign\"):                executorECCSI_Sign.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate ECDSA_Sign code for driver.cpp", "output": "    static ExecutorECDSA_Sign executorECDSA_Sign(CF_OPERATION(\"ECDSA_Sign\"), modules, options);\n            case CF_OPERATION(\"ECDSA_Sign\"):                executorECDSA_Sign.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate ECGDSA_Sign code for driver.cpp", "output": "    static ExecutorECGDSA_Sign executorECGDSA_Sign(CF_OPERATION(\"ECGDSA_Sign\"), modules, options);\n            case CF_OPERATION(\"ECGDSA_Sign\"):                executorECGDSA_Sign.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate ECRDSA_Sign code for driver.cpp", "output": "    static ExecutorECRDSA_Sign executorECRDSA_Sign(CF_OPERATION(\"ECRDSA_Sign\"), modules, options);\n            case CF_OPERATION(\"ECRDSA_Sign\"):                executorECRDSA_Sign.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate Schnorr_Sign code for driver.cpp", "output": "    static ExecutorSchnorr_Sign executorSchnorr_Sign(CF_OPERATION(\"Schnorr_Sign\"), modules, options);\n            case CF_OPERATION(\"Schnorr_Sign\"):                executorSchnorr_Sign.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate ECCSI_Verify code for driver.cpp", "output": "    static ExecutorECCSI_Verify executorECCSI_Verify(CF_OPERATION(\"ECCSI_Verify\"), modules, options);\n            case CF_OPERATION(\"ECCSI_Verify\"):                executorECCSI_Verify.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate ECDSA_Verify code for driver.cpp", "output": "    static ExecutorECDSA_Verify executorECDSA_Verify(CF_OPERATION(\"ECDSA_Verify\"), modules, options);\n            case CF_OPERATION(\"ECDSA_Verify\"):                executorECDSA_Verify.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate ECGDSA_Verify code for driver.cpp", "output": "    static ExecutorECGDSA_Verify executorECGDSA_Verify(CF_OPERATION(\"ECGDSA_Verify\"), modules, options);\n            case CF_OPERATION(\"ECGDSA_Verify\"):                executorECGDSA_Verify.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate ECRDSA_Verify code for driver.cpp", "output": "    static ExecutorECRDSA_Verify executorECRDSA_Verify(CF_OPERATION(\"ECRDSA_Verify\"), modules, options);\n            case CF_OPERATION(\"ECRDSA_Verify\"):                executorECRDSA_Verify.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate Schnorr_Verify code for driver.cpp", "output": "    static ExecutorSchnorr_Verify executorSchnorr_Verify(CF_OPERATION(\"Schnorr_Verify\"), modules, options);\n            case CF_OPERATION(\"Schnorr_Verify\"):                executorSchnorr_Verify.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate ECDSA_Recover code for driver.cpp", "output": "    static ExecutorECDSA_Recover executorECDSA_Recover(CF_OPERATION(\"ECDSA_Recover\"), modules, options);\n            case CF_OPERATION(\"ECDSA_Recover\"):                executorECDSA_Recover.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate DSA_Verify code for driver.cpp", "output": "    static ExecutorDSA_Verify executorDSA_Verify(CF_OPERATION(\"DSA_Verify\"), modules, options);\n            case CF_OPERATION(\"DSA_Verify\"):                executorDSA_Verify.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate DSA_Sign code for driver.cpp", "output": "    static ExecutorDSA_Sign executorDSA_Sign(CF_OPERATION(\"DSA_Sign\"), modules, options);\n            case CF_OPERATION(\"DSA_Sign\"):                executorDSA_Sign.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate DSA_GenerateParameters code for driver.cpp", "output": "    static ExecutorDSA_GenerateParameters executorDSA_GenerateParameters(CF_OPERATION(\"DSA_GenerateParameters\"), modules, options);\n            case CF_OPERATION(\"DSA_GenerateParameters\"):                executorDSA_GenerateParameters.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate DSA_PrivateToPublic code for driver.cpp", "output": "    static ExecutorDSA_PrivateToPublic executorDSA_PrivateToPublic(CF_OPERATION(\"DSA_PrivateToPublic\"), modules, options);\n            case CF_OPERATION(\"DSA_PrivateToPublic\"):                executorDSA_PrivateToPublic.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate DSA_GenerateKeyPair code for driver.cpp", "output": "    static ExecutorDSA_GenerateKeyPair executorDSA_GenerateKeyPair(CF_OPERATION(\"DSA_GenerateKeyPair\"), modules, options);\n            case CF_OPERATION(\"DSA_GenerateKeyPair\"):                executorDSA_GenerateKeyPair.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate ECDH_Derive code for driver.cpp", "output": "    static ExecutorECDH_Derive executorECDH_Derive(CF_OPERATION(\"ECDH_Derive\"), modules, options);\n            case CF_OPERATION(\"ECDH_Derive\"):                executorECDH_Derive.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate ECIES_Encrypt code for driver.cpp", "output": "    static ExecutorECIES_Encrypt executorECIES_Encrypt(CF_OPERATION(\"ECIES_Encrypt\"), modules, options);\n            case CF_OPERATION(\"ECIES_Encrypt\"):                executorECIES_Encrypt.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate ECIES_Decrypt code for driver.cpp", "output": "    static ExecutorECIES_Decrypt executorECIES_Decrypt(CF_OPERATION(\"ECIES_Decrypt\"), modules, options);\n            case CF_OPERATION(\"ECIES_Decrypt\"):                executorECIES_Decrypt.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate ECC_Point_Add code for driver.cpp", "output": "    static ExecutorECC_Point_Add executorECC_Point_Add(CF_OPERATION(\"ECC_Point_Add\"), modules, options);\n            case CF_OPERATION(\"ECC_Point_Add\"):                executorECC_Point_Add.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate ECC_Point_Sub code for driver.cpp", "output": "    static ExecutorECC_Point_Sub executorECC_Point_Sub(CF_OPERATION(\"ECC_Point_Sub\"), modules, options);\n            case CF_OPERATION(\"ECC_Point_Sub\"):                executorECC_Point_Sub.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate ECC_Point_Mul code for driver.cpp", "output": "    static ExecutorECC_Point_Mul executorECC_Point_Mul(CF_OPERATION(\"ECC_Point_Mul\"), modules, options);\n            case CF_OPERATION(\"ECC_Point_Mul\"):                executorECC_Point_Mul.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate ECC_Point_Neg code for driver.cpp", "output": "    static ExecutorECC_Point_Neg executorECC_Point_Neg(CF_OPERATION(\"ECC_Point_Neg\"), modules, options);\n            case CF_OPERATION(\"ECC_Point_Neg\"):                executorECC_Point_Neg.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate ECC_Point_Dbl code for driver.cpp", "output": "    static ExecutorECC_Point_Dbl executorECC_Point_Dbl(CF_OPERATION(\"ECC_Point_Dbl\"), modules, options);\n            case CF_OPERATION(\"ECC_Point_Dbl\"):                executorECC_Point_Dbl.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate ECC_Point_Cmp code for driver.cpp", "output": "    static ExecutorECC_Point_Cmp executorECC_Point_Cmp(CF_OPERATION(\"ECC_Point_Cmp\"), modules, options);\n            case CF_OPERATION(\"ECC_Point_Cmp\"):                executorECC_Point_Cmp.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate DH_GenerateKeyPair code for driver.cpp", "output": "    static ExecutorDH_GenerateKeyPair executorDH_GenerateKeyPair(CF_OPERATION(\"DH_GenerateKeyPair\"), modules, options);\n            case CF_OPERATION(\"DH_GenerateKeyPair\"):                executorDH_GenerateKeyPair.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate DH_Derive code for driver.cpp", "output": "    static ExecutorDH_Derive executorDH_Derive(CF_OPERATION(\"DH_Derive\"), modules, options);\n            case CF_OPERATION(\"DH_Derive\"):                executorDH_Derive.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate BignumCalc code for driver.cpp", "output": "    static ExecutorBignumCalc executorBignumCalc(CF_OPERATION(\"BignumCalc\"), modules, options);\n            case CF_OPERATION(\"BignumCalc\"):                executorBignumCalc.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate BignumCalc_Fp2 code for driver.cpp", "output": "    static ExecutorBignumCalc_Fp2 executorBignumCalc_Fp2(CF_OPERATION(\"BignumCalc_Fp2\"), modules, options);\n            case CF_OPERATION(\"BignumCalc_Fp2\"):                executorBignumCalc_Fp2.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate BignumCalc_Fp12 code for driver.cpp", "output": "    static ExecutorBignumCalc_Fp12 executorBignumCalc_Fp12(CF_OPERATION(\"BignumCalc_Fp12\"), modules, options);\n            case CF_OPERATION(\"BignumCalc_Fp12\"):                executorBignumCalc_Fp12.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate BignumCalc_Mod_BLS12_381_R code for driver.cpp", "output": "    static ExecutorBignumCalc_Mod_BLS12_381_R executorBignumCalc_mod_bls12_381_r(CF_OPERATION(\"BignumCalc_Mod_BLS12_381_R\"), modules, options);\n            case CF_OPERATION(\"BignumCalc_Mod_BLS12_381_R\"):                executorBignumCalc_mod_bls12_381_r.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate BignumCalc_Mod_BLS12_381_P code for driver.cpp", "output": "    static ExecutorBignumCalc_Mod_BLS12_381_P executorBignumCalc_mod_bls12_381_p(CF_OPERATION(\"BignumCalc_Mod_BLS12_381_P\"), modules, options);\n            case CF_OPERATION(\"BignumCalc_Mod_BLS12_381_P\"):                executorBignumCalc_mod_bls12_381_p.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate BignumCalc_Mod_BLS12_377_R code for driver.cpp", "output": "    static ExecutorBignumCalc_Mod_BLS12_377_R executorBignumCalc_mod_bls12_377_r(CF_OPERATION(\"BignumCalc_Mod_BLS12_377_R\"), modules, options);\n            case CF_OPERATION(\"BignumCalc_Mod_BLS12_377_R\"):                executorBignumCalc_mod_bls12_377_r.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate BignumCalc_Mod_BLS12_377_P code for driver.cpp", "output": "    static ExecutorBignumCalc_Mod_BLS12_377_P executorBignumCalc_mod_bls12_377_p(CF_OPERATION(\"BignumCalc_Mod_BLS12_377_P\"), modules, options);\n            case CF_OPERATION(\"BignumCalc_Mod_BLS12_377_P\"):                executorBignumCalc_mod_bls12_377_p.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate BignumCalc_Mod_BN128_R code for driver.cpp", "output": "    static ExecutorBignumCalc_Mod_BN128_R executorBignumCalc_mod_bn128_r(CF_OPERATION(\"BignumCalc_Mod_BN128_R\"), modules, options);\n            case CF_OPERATION(\"BignumCalc_Mod_BN128_R\"):                executorBignumCalc_mod_bn128_r.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate BignumCalc_Mod_BN128_P code for driver.cpp", "output": "    static ExecutorBignumCalc_Mod_BN128_P executorBignumCalc_mod_bn128_p(CF_OPERATION(\"BignumCalc_Mod_BN128_P\"), modules, options);\n            case CF_OPERATION(\"BignumCalc_Mod_BN128_P\"):                executorBignumCalc_mod_bn128_p.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate BignumCalc_Mod_Vesta_R code for driver.cpp", "output": "    static ExecutorBignumCalc_Mod_Vesta_R executorBignumCalc_mod_vesta_r(CF_OPERATION(\"BignumCalc_Mod_Vesta_R\"), modules, options);\n            case CF_OPERATION(\"BignumCalc_Mod_Vesta_R\"):                executorBignumCalc_mod_vesta_r.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate BignumCalc_Mod_Vesta_P code for driver.cpp", "output": "    static ExecutorBignumCalc_Mod_Vesta_P executorBignumCalc_mod_vesta_p(CF_OPERATION(\"BignumCalc_Mod_Vesta_P\"), modules, options);\n            case CF_OPERATION(\"BignumCalc_Mod_Vesta_P\"):                executorBignumCalc_mod_vesta_p.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate BignumCalc_Mod_ED25519 code for driver.cpp", "output": "    static ExecutorBignumCalc_Mod_ED25519 executorBignumCalc_mod_ed25519(CF_OPERATION(\"BignumCalc_Mod_ED25519\"), modules, options);\n            case CF_OPERATION(\"BignumCalc_Mod_ED25519\"):                executorBignumCalc_mod_ed25519.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate BignumCalc_Mod_Edwards_R code for driver.cpp", "output": "    static ExecutorBignumCalc_Mod_Edwards_R executorBignumCalc_mod_edwards_r(CF_OPERATION(\"BignumCalc_Mod_Edwards_R\"), modules, options);\n            case CF_OPERATION(\"BignumCalc_Mod_Edwards_R\"):                executorBignumCalc_mod_edwards_r.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate BignumCalc_Mod_Edwards_P code for driver.cpp", "output": "    static ExecutorBignumCalc_Mod_Edwards_P executorBignumCalc_mod_edwards_p(CF_OPERATION(\"BignumCalc_Mod_Edwards_P\"), modules, options);\n            case CF_OPERATION(\"BignumCalc_Mod_Edwards_P\"):                executorBignumCalc_mod_edwards_p.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate BignumCalc_Mod_Goldilocks code for driver.cpp", "output": "    static ExecutorBignumCalc_Mod_Goldilocks executorBignumCalc_mod_goldilocks(CF_OPERATION(\"BignumCalc_Mod_Goldilocks\"), modules, options);\n            case CF_OPERATION(\"BignumCalc_Mod_Goldilocks\"):                executorBignumCalc_mod_goldilocks.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate BignumCalc_Mod_MNT4_R code for driver.cpp", "output": "    static ExecutorBignumCalc_Mod_MNT4_R executorBignumCalc_mod_mnt4_r(CF_OPERATION(\"BignumCalc_Mod_MNT4_R\"), modules, options);\n            case CF_OPERATION(\"BignumCalc_Mod_MNT4_R\"):                executorBignumCalc_mod_mnt4_r.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate BignumCalc_Mod_MNT4_P code for driver.cpp", "output": "    static ExecutorBignumCalc_Mod_MNT4_P executorBignumCalc_mod_mnt4_p(CF_OPERATION(\"BignumCalc_Mod_MNT4_P\"), modules, options);\n            case CF_OPERATION(\"BignumCalc_Mod_MNT4_P\"):                executorBignumCalc_mod_mnt4_p.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate BignumCalc_Mod_MNT6_R code for driver.cpp", "output": "    static ExecutorBignumCalc_Mod_MNT6_R executorBignumCalc_mod_mnt6_r(CF_OPERATION(\"BignumCalc_Mod_MNT6_R\"), modules, options);\n            case CF_OPERATION(\"BignumCalc_Mod_MNT6_R\"):                executorBignumCalc_mod_mnt6_r.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate BignumCalc_Mod_MNT6_P code for driver.cpp", "output": "    static ExecutorBignumCalc_Mod_MNT6_P executorBignumCalc_mod_mnt6_p(CF_OPERATION(\"BignumCalc_Mod_MNT6_P\"), modules, options);\n            case CF_OPERATION(\"BignumCalc_Mod_MNT6_P\"):                executorBignumCalc_mod_mnt6_p.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate BignumCalc_Mod_2Exp64 code for driver.cpp", "output": "    static ExecutorBignumCalc_Mod_2Exp64 executorBignumCalc_mod_2exp64(CF_OPERATION(\"BignumCalc_Mod_2Exp64\"), modules, options);\n            case CF_OPERATION(\"BignumCalc_Mod_2Exp64\"):                executorBignumCalc_mod_2exp64.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate BignumCalc_Mod_2Exp128 code for driver.cpp", "output": "    static ExecutorBignumCalc_Mod_2Exp128 executorBignumCalc_mod_2exp128(CF_OPERATION(\"BignumCalc_Mod_2Exp128\"), modules, options);\n            case CF_OPERATION(\"BignumCalc_Mod_2Exp128\"):                executorBignumCalc_mod_2exp128.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate BignumCalc_Mod_2Exp256 code for driver.cpp", "output": "    static ExecutorBignumCalc_Mod_2Exp256 executorBignumCalc_mod_2exp256(CF_OPERATION(\"BignumCalc_Mod_2Exp256\"), modules, options);\n            case CF_OPERATION(\"BignumCalc_Mod_2Exp256\"):                executorBignumCalc_mod_2exp256.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate BignumCalc_Mod_2Exp512 code for driver.cpp", "output": "    static ExecutorBignumCalc_Mod_2Exp512 executorBignumCalc_mod_2exp512(CF_OPERATION(\"BignumCalc_Mod_2Exp512\"), modules, options);\n            case CF_OPERATION(\"BignumCalc_Mod_2Exp512\"):                executorBignumCalc_mod_2exp512.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate BignumCalc_Mod_SECP256K1 code for driver.cpp", "output": "    static ExecutorBignumCalc_Mod_SECP256K1 executorBignumCalc_mod_secp256k1(CF_OPERATION(\"BignumCalc_Mod_SECP256K1\"), modules, options);\n            case CF_OPERATION(\"BignumCalc_Mod_SECP256K1\"):                executorBignumCalc_mod_secp256k1.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate BignumCalc_Mod_SECP256K1_P code for driver.cpp", "output": "    static ExecutorBignumCalc_Mod_SECP256K1_P executorBignumCalc_mod_secp256k1_p(CF_OPERATION(\"BignumCalc_Mod_SECP256K1_P\"), modules, options);\n            case CF_OPERATION(\"BignumCalc_Mod_SECP256K1_P\"):                executorBignumCalc_mod_secp256k1_p.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate BLS_PrivateToPublic code for driver.cpp", "output": "    static ExecutorBLS_PrivateToPublic executorBLS_PrivateToPublic(CF_OPERATION(\"BLS_PrivateToPublic\"), modules, options);\n            case CF_OPERATION(\"BLS_PrivateToPublic\"):                executorBLS_PrivateToPublic.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate BLS_PrivateToPublic_G2 code for driver.cpp", "output": "    static ExecutorBLS_PrivateToPublic_G2 executorBLS_PrivateToPublic_G2(CF_OPERATION(\"BLS_PrivateToPublic_G2\"), modules, options);\n            case CF_OPERATION(\"BLS_PrivateToPublic_G2\"):                executorBLS_PrivateToPublic_G2.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate BLS_Sign code for driver.cpp", "output": "    static ExecutorBLS_Sign executorBLS_Sign(CF_OPERATION(\"BLS_Sign\"), modules, options);\n            case CF_OPERATION(\"BLS_Sign\"):                executorBLS_Sign.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate BLS_Verify code for driver.cpp", "output": "    static ExecutorBLS_Verify executorBLS_Verify(CF_OPERATION(\"BLS_Verify\"), modules, options);\n            case CF_OPERATION(\"BLS_Verify\"):                executorBLS_Verify.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate BLS_BatchSign code for driver.cpp", "output": "    static ExecutorBLS_BatchSign executorBLS_BatchSign(CF_OPERATION(\"BLS_BatchSign\"), modules, options);\n            case CF_OPERATION(\"BLS_BatchSign\"):                executorBLS_BatchSign.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate BLS_BatchVerify code for driver.cpp", "output": "    static ExecutorBLS_BatchVerify executorBLS_BatchVerify(CF_OPERATION(\"BLS_BatchVerify\"), modules, options);\n            case CF_OPERATION(\"BLS_BatchVerify\"):                executorBLS_BatchVerify.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate BLS_Aggregate_G1 code for driver.cpp", "output": "    static ExecutorBLS_Aggregate_G1 executorBLS_Aggregate_G1(CF_OPERATION(\"BLS_Aggregate_G1\"), modules, options);\n            case CF_OPERATION(\"BLS_Aggregate_G1\"):                executorBLS_Aggregate_G1.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate BLS_Aggregate_G2 code for driver.cpp", "output": "    static ExecutorBLS_Aggregate_G2 executorBLS_Aggregate_G2(CF_OPERATION(\"BLS_Aggregate_G2\"), modules, options);\n            case CF_OPERATION(\"BLS_Aggregate_G2\"):                executorBLS_Aggregate_G2.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate BLS_Pairing code for driver.cpp", "output": "    static ExecutorBLS_Pairing executorBLS_Pairing(CF_OPERATION(\"BLS_Pairing\"), modules, options);\n            case CF_OPERATION(\"BLS_Pairing\"):                executorBLS_Pairing.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate BLS_MillerLoop code for driver.cpp", "output": "    static ExecutorBLS_MillerLoop executorBLS_MillerLoop(CF_OPERATION(\"BLS_MillerLoop\"), modules, options);\n            case CF_OPERATION(\"BLS_MillerLoop\"):                executorBLS_MillerLoop.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate BLS_FinalExp code for driver.cpp", "output": "    static ExecutorBLS_FinalExp executorBLS_FinalExp(CF_OPERATION(\"BLS_FinalExp\"), modules, options);\n            case CF_OPERATION(\"BLS_FinalExp\"):                executorBLS_FinalExp.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate BLS_HashToG1 code for driver.cpp", "output": "    static ExecutorBLS_HashToG1 executorBLS_HashToG1(CF_OPERATION(\"BLS_HashToG1\"), modules, options);\n            case CF_OPERATION(\"BLS_HashToG1\"):                executorBLS_HashToG1.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate BLS_HashToG2 code for driver.cpp", "output": "    static ExecutorBLS_HashToG2 executorBLS_HashToG2(CF_OPERATION(\"BLS_HashToG2\"), modules, options);\n            case CF_OPERATION(\"BLS_HashToG2\"):                executorBLS_HashToG2.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate BLS_MapToG1 code for driver.cpp", "output": "    static ExecutorBLS_MapToG1 executorBLS_MapToG1(CF_OPERATION(\"BLS_MapToG1\"), modules, options);\n            case CF_OPERATION(\"BLS_MapToG1\"):                executorBLS_MapToG1.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate BLS_MapToG2 code for driver.cpp", "output": "    static ExecutorBLS_MapToG2 executorBLS_MapToG2(CF_OPERATION(\"BLS_MapToG2\"), modules, options);\n            case CF_OPERATION(\"BLS_MapToG2\"):                executorBLS_MapToG2.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate BLS_IsG1OnCurve code for driver.cpp", "output": "    static ExecutorBLS_IsG1OnCurve executorBLS_IsG1OnCurve(CF_OPERATION(\"BLS_IsG1OnCurve\"), modules, options);\n            case CF_OPERATION(\"BLS_IsG1OnCurve\"):                executorBLS_IsG1OnCurve.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate BLS_IsG2OnCurve code for driver.cpp", "output": "    static ExecutorBLS_IsG2OnCurve executorBLS_IsG2OnCurve(CF_OPERATION(\"BLS_IsG2OnCurve\"), modules, options);\n            case CF_OPERATION(\"BLS_IsG2OnCurve\"):                executorBLS_IsG2OnCurve.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate BLS_GenerateKeyPair code for driver.cpp", "output": "    static ExecutorBLS_GenerateKeyPair executorBLS_GenerateKeyPair(CF_OPERATION(\"BLS_GenerateKeyPair\"), modules, options);\n            case CF_OPERATION(\"BLS_GenerateKeyPair\"):                executorBLS_GenerateKeyPair.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate BLS_Decompress_G1 code for driver.cpp", "output": "    static ExecutorBLS_Decompress_G1 executorBLS_Decompress_G1(CF_OPERATION(\"BLS_Decompress_G1\"), modules, options);\n            case CF_OPERATION(\"BLS_Decompress_G1\"):                executorBLS_Decompress_G1.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate BLS_Compress_G1 code for driver.cpp", "output": "    static ExecutorBLS_Compress_G1 executorBLS_Compress_G1(CF_OPERATION(\"BLS_Compress_G1\"), modules, options);\n            case CF_OPERATION(\"BLS_Compress_G1\"):                executorBLS_Compress_G1.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate BLS_Decompress_G2 code for driver.cpp", "output": "    static ExecutorBLS_Decompress_G2 executorBLS_Decompress_G2(CF_OPERATION(\"BLS_Decompress_G2\"), modules, options);\n            case CF_OPERATION(\"BLS_Decompress_G2\"):                executorBLS_Decompress_G2.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate BLS_Compress_G2 code for driver.cpp", "output": "    static ExecutorBLS_Compress_G2 executorBLS_Compress_G2(CF_OPERATION(\"BLS_Compress_G2\"), modules, options);\n            case CF_OPERATION(\"BLS_Compress_G2\"):                executorBLS_Compress_G2.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate BLS_G1_Add code for driver.cpp", "output": "    static ExecutorBLS_G1_Add executorBLS_G1_Add(CF_OPERATION(\"BLS_G1_Add\"), modules, options);\n            case CF_OPERATION(\"BLS_G1_Add\"):                executorBLS_G1_Add.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate BLS_G1_Mul code for driver.cpp", "output": "    static ExecutorBLS_G1_Mul executorBLS_G1_Mul(CF_OPERATION(\"BLS_G1_Mul\"), modules, options);\n            case CF_OPERATION(\"BLS_G1_Mul\"):                executorBLS_G1_Mul.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate BLS_G1_IsEq code for driver.cpp", "output": "    static ExecutorBLS_G1_IsEq executorBLS_G1_IsEq(CF_OPERATION(\"BLS_G1_IsEq\"), modules, options);\n            case CF_OPERATION(\"BLS_G1_IsEq\"):                executorBLS_G1_IsEq.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate BLS_G1_Neg code for driver.cpp", "output": "    static ExecutorBLS_G1_Neg executorBLS_G1_Neg(CF_OPERATION(\"BLS_G1_Neg\"), modules, options);\n            case CF_OPERATION(\"BLS_G1_Neg\"):                executorBLS_G1_Neg.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate BLS_G2_Add code for driver.cpp", "output": "    static ExecutorBLS_G2_Add executorBLS_G2_Add(CF_OPERATION(\"BLS_G2_Add\"), modules, options);\n            case CF_OPERATION(\"BLS_G2_Add\"):                executorBLS_G2_Add.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate BLS_G2_Mul code for driver.cpp", "output": "    static ExecutorBLS_G2_Mul executorBLS_G2_Mul(CF_OPERATION(\"BLS_G2_Mul\"), modules, options);\n            case CF_OPERATION(\"BLS_G2_Mul\"):                executorBLS_G2_Mul.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate BLS_G2_IsEq code for driver.cpp", "output": "    static ExecutorBLS_G2_IsEq executorBLS_G2_IsEq(CF_OPERATION(\"BLS_G2_IsEq\"), modules, options);\n            case CF_OPERATION(\"BLS_G2_IsEq\"):                executorBLS_G2_IsEq.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate BLS_G2_Neg code for driver.cpp", "output": "    static ExecutorBLS_G2_Neg executorBLS_G2_Neg(CF_OPERATION(\"BLS_G2_Neg\"), modules, options);\n            case CF_OPERATION(\"BLS_G2_Neg\"):                executorBLS_G2_Neg.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate BLS_G1_MultiExp code for driver.cpp", "output": "    static ExecutorBLS_G1_MultiExp executorBLS_G1_MultiExp(CF_OPERATION(\"BLS_G1_MultiExp\"), modules, options);\n            case CF_OPERATION(\"BLS_G1_MultiExp\"):                executorBLS_G1_MultiExp.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate Misc code for driver.cpp", "output": "    static ExecutorMisc executorMisc(CF_OPERATION(\"Misc\"), modules, options);\n            case CF_OPERATION(\"Misc\"):                executorMisc.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate SR25519_Verify code for driver.cpp", "output": "    static ExecutorSR25519_Verify executorSR25519_Verify(CF_OPERATION(\"SR25519_Verify\"), modules, options);\n\n\n            case CF_OPERATION(\"SR25519_Verify\"):                executorSR25519_Verify.Run(ds, payload.data(), payload.size());\n                break;\n"}
{"text_input": "Generate Digest code for mutator.cpp", "output": "            case    CF_OPERATION(\"Digest\"):                {\n                    parameters[\"modifier\"] = \"\";\n                    parameters[\"cleartext\"] = getBuffer(PRNG64() % maxSize);\n                    parameters[\"digestType\"] = getRandomDigest();\n\n                    cryptofuzz::operation::Digest op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}
{"text_input": "Generate HMAC code for mutator.cpp", "output": "            case    CF_OPERATION(\"HMAC\"):                {\n                    size_t numParts = 0;\n\n                    numParts++; /* modifier */\n                    numParts++; /* cleartext */\n                    numParts++; /* iv */\n                    numParts++; /* key */\n\n                    const auto lengths = SplitLength(maxSize - 64, numParts);\n\n                    parameters[\"modifier\"] = getBuffer(lengths[0]);\n                    parameters[\"cleartext\"] = getBuffer(lengths[1]);\n                    parameters[\"cipher\"][\"iv\"] = getBuffer(lengths[2], true);\n                    parameters[\"cipher\"][\"key\"] = getBuffer(lengths[3], true);\n                    parameters[\"cipher\"][\"cipherType\"] = getRandomCipher();\n                    parameters[\"digestType\"] = getRandomDigest();\n\n                    cryptofuzz::operation::HMAC op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}
{"text_input": "Generate UMAC code for mutator.cpp", "output": "            case    CF_OPERATION(\"UMAC\"):                {\n                    parameters[\"modifier\"] = \"\";\n                    parameters[\"cleartext\"] = getBuffer(PRNG64() % maxSize);\n                    parameters[\"key\"] = getBuffer(16);\n                    parameters[\"iv\"] = getBuffer(PRNG() % 17);\n                    parameters[\"type\"] = PRNG() % 4;\n                    parameters[\"outSize\"] = PRNG() % 1024;\n\n                    cryptofuzz::operation::UMAC op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}
{"text_input": "Generate CMAC code for mutator.cpp", "output": "            case    CF_OPERATION(\"CMAC\"):                {\n                    size_t numParts = 0;\n\n                    numParts++; /* modifier */\n                    numParts++; /* cleartext */\n                    numParts++; /* iv */\n                    numParts++; /* key */\n\n                    const auto lengths = SplitLength(maxSize - 64, numParts);\n\n                    parameters[\"modifier\"] = getBuffer(lengths[0]);\n                    parameters[\"cleartext\"] = getBuffer(lengths[1]);\n                    parameters[\"cipher\"][\"iv\"] = getBuffer(lengths[2], true);\n                    parameters[\"cipher\"][\"key\"] = getBuffer(lengths[3], true);\n                    parameters[\"cipher\"][\"cipherType\"] = getRandomCipher();\n\n                    cryptofuzz::operation::CMAC op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}
{"text_input": "Generate SymmetricEncrypt code for mutator.cpp", "output": "            case    CF_OPERATION(\"SymmetricEncrypt\"):                {\n                    const bool aad_enabled = PRNG() % 2;\n                    const bool tagSize_enabled = PRNG() % 2;\n                    size_t numParts = 0;\n\n                    numParts++; /* modifier */\n                    numParts++; /* cleartext */\n                    numParts++; /* iv */\n                    numParts++; /* key */\n\n                    if ( aad_enabled ) {\n                        numParts++; /* aad */\n                    }\n\n                    auto lengths = SplitLength(maxSize - 64, numParts);\n\n                    parameters[\"modifier\"] = getBuffer(lengths[0]);\n                    if ( getBool() ) {\n                        if ( 16 < lengths[1] ) {\n                            lengths[1] = 16;\n                        }\n                    }\n                    parameters[\"cleartext\"] = getBuffer(lengths[1]);\n\n                    parameters[\"cipher\"][\"iv\"] = getBuffer(lengths[2], true);\n                    parameters[\"cipher\"][\"key\"] = getBuffer(lengths[3], true);\n\n                    if ( aad_enabled ) {\n                        parameters[\"aad_enabled\"] = true;\n                        if ( getBool() ) {\n                            lengths[4] = 0;\n                        }\n                        parameters[\"aad\"] = getBuffer(lengths[4]);\n                    } else {\n                        parameters[\"aad_enabled\"] = false;\n                    }\n\n                    if ( tagSize_enabled ) {\n                        parameters[\"tagSize_enabled\"] = true;\n                        if ( getBool() ) {\n                            parameters[\"tagSize\"] = getDefaultSize();\n                        } else {\n                            parameters[\"tagSize\"] = PRNG() % 102400;\n                        }\n                    } else {\n                        parameters[\"tagSize_enabled\"] = false;\n                    }\n\n                    parameters[\"cipher\"][\"cipherType\"] = getRandomCipher();\n                    parameters[\"ciphertextSize\"] = PRNG() % (lengths[1] + 9);\n\n                    cryptofuzz::operation::SymmetricEncrypt op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}
{"text_input": "Generate SymmetricDecrypt code for mutator.cpp", "output": "            case    CF_OPERATION(\"SymmetricDecrypt\"):                {\n                    const bool aad_enabled = PRNG() % 2;\n                    const bool tag_enabled = PRNG() % 2;\n                    size_t numParts = 0;\n\n                    numParts++; /* modifier */\n                    numParts++; /* cleartext */\n                    numParts++; /* iv */\n                    numParts++; /* key */\n\n                    if ( aad_enabled ) {\n                        numParts++; /* aad */\n                    }\n                    if ( tag_enabled ) {\n                        numParts++; /* tag */\n                    }\n\n                    auto lengths = SplitLength(maxSize - 64, numParts);\n\n                    parameters[\"modifier\"] = getBuffer(lengths[0]);\n                    if ( getBool() ) {\n                        if ( 16 < lengths[1] ) {\n                            lengths[1] = 16;\n                        }\n                    }\n                    parameters[\"ciphertext\"] = getBuffer(lengths[1]);\n\n                    parameters[\"cipher\"][\"iv\"] = getBuffer(lengths[2], true);\n                    parameters[\"cipher\"][\"key\"] = getBuffer(lengths[3], true);\n\n                    if ( aad_enabled ) {\n                        parameters[\"aad_enabled\"] = true;\n                        if ( getBool() ) {\n                            lengths[4] = 0;\n                        }\n                        parameters[\"aad\"] = getBuffer(lengths[4]);\n                    } else {\n                        parameters[\"aad_enabled\"] = false;\n                    }\n\n                    if ( tag_enabled ) {\n                        parameters[\"tag_enabled\"] = true;\n                        parameters[\"tag\"] = getBuffer(lengths[aad_enabled ? 5 : 4], true);\n                    } else {\n                        parameters[\"tag_enabled\"] = false;\n                    }\n\n                    parameters[\"cipher\"][\"cipherType\"] = getRandomCipher();\n                    parameters[\"cleartextSize\"] = PRNG() % (lengths[1] + 9);\n\n                    cryptofuzz::operation::SymmetricDecrypt op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}
{"text_input": "Generate BignumCalc code for mutator.cpp", "output": "            case    CF_OPERATION(\"BignumCalc\"):"}
{"text_input": "Generate BignumCalc_Mod_BLS12_381_R code for mutator.cpp", "output": "            case    CF_OPERATION(\"BignumCalc_Mod_BLS12_381_R\"):"}
{"text_input": "Generate BignumCalc_Mod_BLS12_381_P code for mutator.cpp", "output": "            case    CF_OPERATION(\"BignumCalc_Mod_BLS12_381_P\"):"}
{"text_input": "Generate BignumCalc_Mod_BN128_R code for mutator.cpp", "output": "            case    CF_OPERATION(\"BignumCalc_Mod_BN128_R\"):"}
{"text_input": "Generate BignumCalc_Mod_BN128_P code for mutator.cpp", "output": "            case    CF_OPERATION(\"BignumCalc_Mod_BN128_P\"):"}
{"text_input": "Generate BignumCalc_Mod_Vesta_R code for mutator.cpp", "output": "            case    CF_OPERATION(\"BignumCalc_Mod_Vesta_R\"):"}
{"text_input": "Generate BignumCalc_Mod_Vesta_P code for mutator.cpp", "output": "            case    CF_OPERATION(\"BignumCalc_Mod_Vesta_P\"):"}
{"text_input": "Generate BignumCalc_Mod_ED25519 code for mutator.cpp", "output": "            case    CF_OPERATION(\"BignumCalc_Mod_ED25519\"):"}
{"text_input": "Generate BignumCalc_Mod_Edwards_R code for mutator.cpp", "output": "            case    CF_OPERATION(\"BignumCalc_Mod_Edwards_R\"):"}
{"text_input": "Generate BignumCalc_Mod_Edwards_P code for mutator.cpp", "output": "            case    CF_OPERATION(\"BignumCalc_Mod_Edwards_P\"):"}
{"text_input": "Generate BignumCalc_Mod_Goldilocks code for mutator.cpp", "output": "            case    CF_OPERATION(\"BignumCalc_Mod_Goldilocks\"):"}
{"text_input": "Generate BignumCalc_Mod_MNT4_R code for mutator.cpp", "output": "            case    CF_OPERATION(\"BignumCalc_Mod_MNT4_R\"):"}
{"text_input": "Generate BignumCalc_Mod_MNT4_P code for mutator.cpp", "output": "            case    CF_OPERATION(\"BignumCalc_Mod_MNT4_P\"):"}
{"text_input": "Generate BignumCalc_Mod_MNT6_R code for mutator.cpp", "output": "            case    CF_OPERATION(\"BignumCalc_Mod_MNT6_R\"):"}
{"text_input": "Generate BignumCalc_Mod_MNT6_P code for mutator.cpp", "output": "            case    CF_OPERATION(\"BignumCalc_Mod_MNT6_P\"):"}
{"text_input": "Generate BignumCalc_Mod_2Exp64 code for mutator.cpp", "output": "            case    CF_OPERATION(\"BignumCalc_Mod_2Exp64\"):"}
{"text_input": "Generate BignumCalc_Mod_2Exp128 code for mutator.cpp", "output": "            case    CF_OPERATION(\"BignumCalc_Mod_2Exp128\"):"}
{"text_input": "Generate BignumCalc_Mod_2Exp256 code for mutator.cpp", "output": "            case    CF_OPERATION(\"BignumCalc_Mod_2Exp256\"):"}
{"text_input": "Generate BignumCalc_Mod_2Exp512 code for mutator.cpp", "output": "            case    CF_OPERATION(\"BignumCalc_Mod_2Exp512\"):"}
{"text_input": "Generate BignumCalc_Mod_SECP256K1 code for mutator.cpp", "output": "            case    CF_OPERATION(\"BignumCalc_Mod_SECP256K1\"):"}
{"text_input": "Generate BignumCalc_Mod_SECP256K1_P code for mutator.cpp", "output": "            case    CF_OPERATION(\"BignumCalc_Mod_SECP256K1_P\"):"}
{"text_input": "Generate BignumCalc_Mod_BLS12_377_R code for mutator.cpp", "output": "            case    CF_OPERATION(\"BignumCalc_Mod_BLS12_377_R\"):"}
{"text_input": "Generate BignumCalc_Mod_BLS12_377_P code for mutator.cpp", "output": "            case    CF_OPERATION(\"BignumCalc_Mod_BLS12_377_P\"):                {\n                    parameters[\"modifier\"] = \"\";\n\n                    const auto calcop = getRandomCalcOp();\n                    parameters[\"calcOp\"] = calcop;\n\n                    auto bn1 = getBignum();\n                    const auto bn2 = getBignum();\n                    const auto bn3 = getBignum();\n\n                    if ( calcop == CF_CALCOP(\"InvMod(A,B)\") || calcop == CF_CALCOP(\"ExpMod(A,B,C)\") ) {\n                        std::optional<std::string> mod = get_op_mod(operation);\n\n                        if ( mod == std::nullopt ) {\n                            if ( calcop == CF_CALCOP(\"InvMod(A,B)\") ) {\n                                mod = bn2;\n                            } else if ( CF_CALCOP(\"ExpMod(A,B,C)\") ) {\n                                mod = bn3;\n                            } else {\n                                abort();\n                            }\n                        }\n\n                        const auto mont = from_mont(mutateBinary(getBignum()), *mod);\n                        Pool_Bignum.Set(mont);\n\n                        if ( getBool() ) {\n                            bn1 = mont;\n                        }\n                    }\n\n                    parameters[\"bn1\"] = bn1;\n                    parameters[\"bn2\"] = bn2;\n                    parameters[\"bn3\"] = bn3;\n                    parameters[\"bn4\"] = \"\";\n\n                    if ( calcop == CF_CALCOP(\"ExpMod(A,B,C)\") && operation == CF_OPERATION(\"BignumCalc\") ) {\n                        if ( PRNG() % 100 == 0 ) {\n                            const auto p = cryptofuzz::mutator::ExpModGenerator::generate_exp_mod(getBignum(true));\n\n                            if ( p != std::nullopt ) {\n                                parameters = *p;\n                            }\n                        }\n                    }\n#if defined(CRYPTOFUZZ_HAVE_Z3)\n                    else if ( (PRNG() % 1000) == 0 ) {\n                        const auto p = cryptofuzz::Z3::Generate(calcop);\n                        if ( p != std::nullopt ) {\n                            parameters = *p;\n                        }\n                    }\n#endif\n                    cryptofuzz::operation::BignumCalc op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}
{"text_input": "Generate BignumCalc_Fp2 code for mutator.cpp", "output": "            case    CF_OPERATION(\"BignumCalc_Fp2\"):                {\n                    parameters[\"modifier\"] = getBuffer(PRNG() % 1000);\n                    parameters[\"calcOp\"] = getRandomCalcOp();\n                    parameters[\"bn1\"][0] = getBignum();\n                    parameters[\"bn1\"][1] = getBignum();\n                    parameters[\"bn2\"][0] = getBignum();\n                    parameters[\"bn2\"][1] = getBignum();\n                    parameters[\"bn3\"][0] = \"\";\n                    parameters[\"bn3\"][1] = \"\";\n                    parameters[\"bn4\"][0] = \"\";\n                    parameters[\"bn4\"][1] = \"\";\n\n                    cryptofuzz::operation::BignumCalc_Fp2 op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n\n"}
{"text_input": "Generate BignumCalc_Fp12 code for mutator.cpp", "output": "            case    CF_OPERATION(\"BignumCalc_Fp12\"):                {\n                    parameters[\"modifier\"] = getBuffer(PRNG() % 1000);\n                    parameters[\"calcOp\"] = getRandomCalcOp();\n\n                    if ( Pool_Fp12.Have() && getBool() == true ) {\n                        const auto Fp12 = Pool_Fp12.Get();\n#if 0\n                        parameters[\"bn1\"][0] = GET_OR_BIGNUM(Fp12.bn1);\n                        parameters[\"bn1\"][1] = GET_OR_BIGNUM(Fp12.bn2);\n                        parameters[\"bn1\"][2] = GET_OR_BIGNUM(Fp12.bn3);\n                        parameters[\"bn1\"][3] = GET_OR_BIGNUM(Fp12.bn4);\n                        parameters[\"bn1\"][4] = GET_OR_BIGNUM(Fp12.bn5);\n                        parameters[\"bn1\"][5] = GET_OR_BIGNUM(Fp12.bn6);\n                        parameters[\"bn1\"][6] = GET_OR_BIGNUM(Fp12.bn7);\n                        parameters[\"bn1\"][7] = GET_OR_BIGNUM(Fp12.bn8);\n                        parameters[\"bn1\"][8] = GET_OR_BIGNUM(Fp12.bn9);\n                        parameters[\"bn1\"][9] = GET_OR_BIGNUM(Fp12.bn10);\n                        parameters[\"bn1\"][10] = GET_OR_BIGNUM(Fp12.bn11);\n                        parameters[\"bn1\"][11] = GET_OR_BIGNUM(Fp12.bn12);\n#endif\n                        parameters[\"bn1\"][0] = Fp12.bn1;\n                        parameters[\"bn1\"][1] = Fp12.bn2;\n                        parameters[\"bn1\"][2] = Fp12.bn3;\n                        parameters[\"bn1\"][3] = Fp12.bn4;\n                        parameters[\"bn1\"][4] = Fp12.bn5;\n                        parameters[\"bn1\"][5] = Fp12.bn6;\n                        parameters[\"bn1\"][6] = Fp12.bn7;\n                        parameters[\"bn1\"][7] = Fp12.bn8;\n                        parameters[\"bn1\"][8] = Fp12.bn9;\n                        parameters[\"bn1\"][9] = Fp12.bn10;\n                        parameters[\"bn1\"][10] = Fp12.bn11;\n                        parameters[\"bn1\"][11] = Fp12.bn12;\n                    } else {\n                        parameters[\"bn1\"][0] = getBignum();\n                        parameters[\"bn1\"][1] = getBignum();\n                        parameters[\"bn1\"][2] = getBignum();\n                        parameters[\"bn1\"][3] = getBignum();\n                        parameters[\"bn1\"][4] = getBignum();\n                        parameters[\"bn1\"][5] = getBignum();\n                        parameters[\"bn1\"][6] = getBignum();\n                        parameters[\"bn1\"][7] = getBignum();\n                        parameters[\"bn1\"][8] = getBignum();\n                        parameters[\"bn1\"][9] = getBignum();\n                        parameters[\"bn1\"][10] = getBignum();\n                        parameters[\"bn1\"][11] = getBignum();\n\n                        parameters[\"bn2\"][0] = getBignum();\n                        parameters[\"bn2\"][1] = getBignum();\n                        parameters[\"bn2\"][2] = getBignum();\n                        parameters[\"bn2\"][3] = getBignum();\n                        parameters[\"bn2\"][4] = getBignum();\n                        parameters[\"bn2\"][5] = getBignum();\n                        parameters[\"bn2\"][6] = getBignum();\n                        parameters[\"bn2\"][7] = getBignum();\n                        parameters[\"bn2\"][8] = getBignum();\n                        parameters[\"bn2\"][9] = getBignum();\n                        parameters[\"bn2\"][10] = getBignum();\n                        parameters[\"bn2\"][11] = getBignum();\n                    }\n\n                    if ( Pool_Fp12.Have() && getBool() == true ) {\n                        const auto Fp12 = Pool_Fp12.Get();\n#if 0\n                        parameters[\"bn2\"][0] = GET_OR_BIGNUM(Fp12.bn1);\n                        parameters[\"bn2\"][1] = GET_OR_BIGNUM(Fp12.bn2);\n                        parameters[\"bn2\"][2] = GET_OR_BIGNUM(Fp12.bn3);\n                        parameters[\"bn2\"][3] = GET_OR_BIGNUM(Fp12.bn4);\n                        parameters[\"bn2\"][4] = GET_OR_BIGNUM(Fp12.bn5);\n                        parameters[\"bn2\"][5] = GET_OR_BIGNUM(Fp12.bn6);\n                        parameters[\"bn2\"][6] = GET_OR_BIGNUM(Fp12.bn7);\n                        parameters[\"bn2\"][7] = GET_OR_BIGNUM(Fp12.bn8);\n                        parameters[\"bn2\"][8] = GET_OR_BIGNUM(Fp12.bn9);\n                        parameters[\"bn2\"][9] = GET_OR_BIGNUM(Fp12.bn10);\n                        parameters[\"bn2\"][10] = GET_OR_BIGNUM(Fp12.bn11);\n                        parameters[\"bn2\"][11] = GET_OR_BIGNUM(Fp12.bn12);\n#endif\n                        parameters[\"bn2\"][0] = Fp12.bn1;\n                        parameters[\"bn2\"][1] = Fp12.bn2;\n                        parameters[\"bn2\"][2] = Fp12.bn3;\n                        parameters[\"bn2\"][3] = Fp12.bn4;\n                        parameters[\"bn2\"][4] = Fp12.bn5;\n                        parameters[\"bn2\"][5] = Fp12.bn6;\n                        parameters[\"bn2\"][6] = Fp12.bn7;\n                        parameters[\"bn2\"][7] = Fp12.bn8;\n                        parameters[\"bn2\"][8] = Fp12.bn9;\n                        parameters[\"bn2\"][9] = Fp12.bn10;\n                        parameters[\"bn2\"][10] = Fp12.bn11;\n                        parameters[\"bn2\"][11] = Fp12.bn12;\n                    } else {\n                        parameters[\"bn2\"][0] = getBignum();\n                        parameters[\"bn2\"][1] = getBignum();\n                        parameters[\"bn2\"][2] = getBignum();\n                        parameters[\"bn2\"][3] = getBignum();\n                        parameters[\"bn2\"][4] = getBignum();\n                        parameters[\"bn2\"][5] = getBignum();\n                        parameters[\"bn2\"][6] = getBignum();\n                        parameters[\"bn2\"][7] = getBignum();\n                        parameters[\"bn2\"][8] = getBignum();\n                        parameters[\"bn2\"][9] = getBignum();\n                        parameters[\"bn2\"][10] = getBignum();\n                        parameters[\"bn2\"][11] = getBignum();\n                    }\n\n                    parameters[\"bn3\"][0] = \"\";\n                    parameters[\"bn3\"][1] = \"\";\n                    parameters[\"bn3\"][2] = \"\";\n                    parameters[\"bn3\"][3] = \"\";\n                    parameters[\"bn3\"][4] = \"\";\n                    parameters[\"bn3\"][5] = \"\";\n                    parameters[\"bn3\"][6] = \"\";\n                    parameters[\"bn3\"][7] = \"\";\n                    parameters[\"bn3\"][8] = \"\";\n                    parameters[\"bn3\"][9] = \"\";\n                    parameters[\"bn3\"][10] = \"\";\n                    parameters[\"bn3\"][11] = \"\";\n\n                    parameters[\"bn4\"][0] = \"\";\n                    parameters[\"bn4\"][1] = \"\";\n                    parameters[\"bn4\"][2] = \"\";\n                    parameters[\"bn4\"][3] = \"\";\n                    parameters[\"bn4\"][4] = \"\";\n                    parameters[\"bn4\"][5] = \"\";\n                    parameters[\"bn4\"][6] = \"\";\n                    parameters[\"bn4\"][7] = \"\";\n                    parameters[\"bn4\"][8] = \"\";\n                    parameters[\"bn4\"][9] = \"\";\n                    parameters[\"bn4\"][10] = \"\";\n                    parameters[\"bn4\"][11] = \"\";\n                    cryptofuzz::operation::BignumCalc_Fp12 op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}
{"text_input": "Generate ECC_PrivateToPublic code for mutator.cpp", "output": "            case    CF_OPERATION(\"ECC_PrivateToPublic\"):                {\n                    parameters[\"modifier\"] = getBuffer(PRNG() % 1000);\n\n                    if ( Pool_CurvePrivkey.Have() && getBool() == true ) {\n                        const auto P1 = Pool_CurvePrivkey.Get();\n\n                        parameters[\"curveType\"] = hint_ecc_mont(P1.curveID);\n                        parameters[\"priv\"] = P1.priv;\n                    } else {\n                        const auto curveID = getRandomCurve();\n                        parameters[\"curveType\"] = hint_ecc_mont(curveID);\n\n                        if ( getBool() ) {\n                            const auto order = cryptofuzz::repository::ECC_CurveToOrder(curveID);\n                            if ( order != std::nullopt ) {\n                                const auto o = boost::multiprecision::cpp_int(*order);\n                                parameters[\"priv\"] = boost::lexical_cast<std::string>(o-1);\n                            } else {\n                                parameters[\"priv\"] = getBignum();\n                            }\n                        } else {\n                            parameters[\"priv\"] = getBignum();\n                        }\n\n                    }\n\n                    cryptofuzz::operation::ECC_PrivateToPublic op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}
{"text_input": "Generate ECC_ValidatePubkey code for mutator.cpp", "output": "            case    CF_OPERATION(\"ECC_ValidatePubkey\"):                {\n                    parameters[\"modifier\"] = getBuffer(PRNG() % 1000);\n\n                    if ( getBool() && Pool_CurveKeypair.Have() ) {\n                        const auto P = Pool_CurveKeypair.Get();\n\n                        parameters[\"curveType\"] = hint_ecc_mont(P.curveID);\n\n                        parameters[\"pub_x\"] = getBool() ? getBignum() : P.pub_x;\n                        parameters[\"pub_y\"] = getBool() ? getBignum() : P.pub_y;\n                    } else if ( getBool() && Pool_CurveECC_Point.Have() == true ) {\n                        const auto P = Pool_CurveECC_Point.Get();\n                        parameters[\"curveType\"] = hint_ecc_mont(P.curveID);\n\n                        parameters[\"pub_x\"] = getBool() ? getBignum() : P.x;\n                        parameters[\"pub_y\"] = getBool() ? getBignum() : P.y;\n                    } else {\n                        parameters[\"curveType\"] = hint_ecc_mont(getRandomCurve());\n                        parameters[\"pub_x\"] = getBignum();\n                        parameters[\"pub_y\"] = getBignum();\n                    }\n\n                    cryptofuzz::operation::ECC_ValidatePubkey op(parameters);\n                    op.Serialize(dsOut2);\n\n                    generateECCPoint();\n                }\n                break;\n"}
{"text_input": "Generate DSA_GenerateParameters code for mutator.cpp", "output": "            case    CF_OPERATION(\"DSA_GenerateParameters\"):                {\n                    parameters[\"modifier\"] = getBuffer(PRNG() % 1000);\n                    cryptofuzz::operation::DSA_GenerateParameters op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}
{"text_input": "Generate DSA_PrivateToPublic code for mutator.cpp", "output": "            case    CF_OPERATION(\"DSA_PrivateToPublic\"):                {\n                    parameters[\"modifier\"] = \"\";\n\n                    if ( Pool_DSA_PQG.Have() && getBool() == true ) {\n                        const auto PQG = Pool_DSA_PQG.Get();\n                        parameters[\"p\"] = PQG.p;\n                        parameters[\"g\"] = PQG.g;\n                    } else {\n                        parameters[\"p\"] = getBignum();\n                        parameters[\"g\"] = getBignum();\n                    }\n\n                    parameters[\"priv\"] = getBignum();\n\n                    cryptofuzz::operation::DSA_PrivateToPublic op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}
{"text_input": "Generate DSA_GenerateKeyPair code for mutator.cpp", "output": "            case    CF_OPERATION(\"DSA_GenerateKeyPair\"):                {\n                    parameters[\"modifier\"] = getBuffer(PRNG() % 1000);\n\n                    if ( Pool_DSA_PQG.Have() && getBool() == true ) {\n                        const auto PQG = Pool_DSA_PQG.Get();\n                        parameters[\"p\"] = PQG.p;\n                        parameters[\"q\"] = PQG.q;\n                        parameters[\"g\"] = PQG.g;\n                    } else {\n                        parameters[\"p\"] = getBignum();\n                        parameters[\"q\"] = getBignum();\n                        parameters[\"g\"] = getBignum();\n                    }\n\n                    cryptofuzz::operation::DSA_GenerateKeyPair op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}
{"text_input": "Generate DSA_Verify code for mutator.cpp", "output": "            case    CF_OPERATION(\"DSA_Verify\"):                {\n                    parameters[\"modifier\"] = getBuffer(PRNG() % 1000);\n\n                    if ( Pool_DSASignature.Have() && getBool() == true ) {\n                        const auto sig = Pool_DSASignature.Get();\n\n                        nlohmann::json parameters_;\n                        parameters_[\"p\"] = sig.p;\n                        parameters_[\"q\"] = sig.q;\n                        parameters_[\"g\"] = sig.g;\n\n                        parameters[\"parameters\"] = parameters_;\n\n                        parameters[\"signature\"][0] = getBool() ? getBignum() : sig.r;\n                        parameters[\"signature\"][1] = getBool() ? getBignum() : sig.s;\n                        parameters[\"pub\"] = sig.pub;\n                        parameters[\"cleartext\"] = sig.cleartext;\n                    } else {\n                        nlohmann::json parameters_;\n                        parameters_[\"p\"] = getBignum();\n                        parameters_[\"q\"] = getBignum();\n                        parameters_[\"g\"] = getBignum();\n\n                        parameters[\"parameters\"] = parameters_;\n\n                        parameters[\"signature\"][0] = getBignum();\n                        parameters[\"signature\"][1] = getBignum();\n                        parameters[\"pub\"] = getBignum();\n                        parameters[\"cleartext\"] = getBuffer(PRNG() % 8);\n                    }\n\n\n                    cryptofuzz::operation::DSA_Verify op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}
{"text_input": "Generate DSA_Sign code for mutator.cpp", "output": "            case    CF_OPERATION(\"DSA_Sign\"):                {\n                    parameters[\"modifier\"] = getBuffer(PRNG() % 1000);\n\n                    if ( Pool_DSA_PQG.Have() && getBool() == true ) {\n                        const auto PQG = Pool_DSA_PQG.Get();\n\n                        nlohmann::json parameters_;\n                        parameters_[\"p\"] = PQG.p;\n                        parameters_[\"q\"] = PQG.q;\n                        parameters_[\"g\"] = PQG.g;\n\n                        parameters[\"parameters\"] = parameters_;\n                    } else {\n                        nlohmann::json parameters_;\n                        parameters_[\"p\"] = getBignum();\n                        parameters_[\"q\"] = getBignum();\n                        parameters_[\"g\"] = getBignum();\n\n                        parameters[\"parameters\"] = parameters_;\n                    }\n\n                    parameters[\"priv\"] = getBignum();\n\n                    parameters[\"cleartext\"] = getBuffer(PRNG() % 8);\n\n                    cryptofuzz::operation::DSA_Sign op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}
{"text_input": "Generate ECDH_Derive code for mutator.cpp", "output": "            case    CF_OPERATION(\"ECDH_Derive\"):                {\n                    parameters[\"modifier\"] = getBuffer(PRNG() % 1000);\n\n                    if ( Pool_CurvePrivkey.Have() && getBool() == true ) {\n                        const auto P1 = Pool_CurveKeypair.Get();\n                        const auto P2 = Pool_CurveKeypair.Get();\n\n                        CF_CHECK_EQ(P1.curveID, P2.curveID);\n\n                        parameters[\"curveType\"] = hint_ecc_mont(P1.curveID);\n\n                        parameters[\"priv\"] = P1.privkey;\n\n                        parameters[\"pub_x\"] = P1.pub_x;\n                        parameters[\"pub_y\"] = P1.pub_y;\n                    } else {\n                        parameters[\"curveType\"] = hint_ecc_mont(getRandomCurve());\n\n                        parameters[\"priv\"] = getBignum();\n\n                        parameters[\"pub_x\"] = getBignum();\n                        parameters[\"pub_y\"] = getBignum();\n                    }\n\n                    cryptofuzz::operation::ECDH_Derive op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}
{"text_input": "Generate ECCSI_Sign code for mutator.cpp", "output": "            case    CF_OPERATION(\"ECCSI_Sign\"):                {\n                    parameters[\"modifier\"] = getBuffer(PRNG() % 1000);\n\n                    const auto P1 = Pool_CurvePrivkey.Get();\n\n                    parameters[\"curveType\"] = hint_ecc_mont(P1.curveID);\n                    parameters[\"priv\"] = P1.priv;\n\n                    if ( getBool() ) {\n                        parameters[\"cleartext\"] = cryptofuzz::util::DecToHex(getBignum(true), (PRNG() % 64) * 2);\n                    } else {\n                        parameters[\"cleartext\"] = getBuffer(PRNG() % 32);\n                    }\n                    parameters[\"digestType\"] = getRandomDigest();\n                    parameters[\"id\"] = getBuffer(PRNG() % 1024);\n\n                    cryptofuzz::operation::ECCSI_Sign op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}
{"text_input": "Generate ECDSA_Sign code for mutator.cpp", "output": "            case    CF_OPERATION(\"ECDSA_Sign\"):                {\n                    parameters[\"modifier\"] = getBuffer(PRNG() % 1000);\n\n\t\t            // Was broken: empty string is not valid priv key (copy-paste from getPublicKey)\n                    if ( Pool_CurvePrivkey.Have() && getBool() == true ) {\n                        const auto P1 = Pool_CurvePrivkey.Get();\n\n                        parameters[\"curveType\"] = hint_ecc_mont(P1.curveID);\n                        parameters[\"priv\"] = P1.priv;\n                    } else {\n                        const auto curveID = getRandomCurve();\n                        parameters[\"curveType\"] = hint_ecc_mont(curveID);\n\n                        if ( getBool() ) {\n                            const auto order = cryptofuzz::repository::ECC_CurveToOrder(curveID);\n                            if ( order != std::nullopt ) {\n                                const auto o = boost::multiprecision::cpp_int(*order);\n                                parameters[\"priv\"] = boost::lexical_cast<std::string>(o-1);\n                            } else {\n                                parameters[\"priv\"] = getBignum();\n                            }\n                        } else {\n                            parameters[\"priv\"] = getBignum();\n                        }\n\n                    }\n                    parameters[\"nonce\"] = getBignum();\n\n                    if ( getBool() ) {\n                        parameters[\"cleartext\"] = cryptofuzz::util::DecToHex(getBignum(true), (PRNG() % 64) * 2);\n                    } else {\n                        parameters[\"cleartext\"] = getBuffer(PRNG() % 32);\n                    }\n\n                    parameters[\"nonceSource\"] = PRNG() % 3;\n                    parameters[\"digestType\"] = getRandomDigest();\n\n                    cryptofuzz::operation::ECDSA_Sign op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}
{"text_input": "Generate ECGDSA_Sign code for mutator.cpp", "output": "            case    CF_OPERATION(\"ECGDSA_Sign\"):                {\n                    parameters[\"modifier\"] = getBuffer(PRNG() % 1000);\n\n                    const auto P1 = Pool_CurvePrivkey.Get();\n\n                    parameters[\"curveType\"] = hint_ecc_mont(P1.curveID);\n                    parameters[\"priv\"] = P1.priv;\n                    parameters[\"nonce\"] = getBignum();\n\n                    if ( getBool() ) {\n                        parameters[\"cleartext\"] = cryptofuzz::util::DecToHex(getBignum(true), (PRNG() % 64) * 2);\n                    } else {\n                        parameters[\"cleartext\"] = getBuffer(PRNG() % 32);\n                    }\n                    parameters[\"nonceSource\"] = PRNG() % 3;\n                    parameters[\"digestType\"] = getRandomDigest();\n\n                    cryptofuzz::operation::ECGDSA_Sign op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}
{"text_input": "Generate ECRDSA_Sign code for mutator.cpp", "output": "            case    CF_OPERATION(\"ECRDSA_Sign\"):                {\n                    parameters[\"modifier\"] = getBuffer(PRNG() % 1000);\n\n                    const auto P1 = Pool_CurvePrivkey.Get();\n\n                    parameters[\"curveType\"] = hint_ecc_mont(P1.curveID);\n                    parameters[\"priv\"] = P1.priv;\n                    parameters[\"nonce\"] = getBignum();\n\n                    if ( getBool() ) {\n                        parameters[\"cleartext\"] = cryptofuzz::util::DecToHex(getBignum(true), (PRNG() % 64) * 2);\n                    } else {\n                        parameters[\"cleartext\"] = getBuffer(PRNG() % 32);\n                    }\n                    parameters[\"nonceSource\"] = PRNG() % 3;\n                    parameters[\"digestType\"] = getRandomDigest();\n\n                    cryptofuzz::operation::ECRDSA_Sign op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}
{"text_input": "Generate Schnorr_Sign code for mutator.cpp", "output": "            case    CF_OPERATION(\"Schnorr_Sign\"):                {\n                    parameters[\"modifier\"] = getBuffer(PRNG() % 1000);\n\n                    const auto P1 = Pool_CurvePrivkey.Get();\n\n                    parameters[\"curveType\"] = hint_ecc_mont(P1.curveID);\n                    parameters[\"priv\"] = P1.priv;\n                    parameters[\"nonce\"] = getBignum();\n\n                    if ( getBool() ) {\n                        parameters[\"cleartext\"] = cryptofuzz::util::DecToHex(getBignum(true), (PRNG() % 64) * 2);\n                    } else {\n                        parameters[\"cleartext\"] = getBuffer(PRNG() % 32);\n                    }\n                    parameters[\"nonceSource\"] = PRNG() % 3;\n                    parameters[\"digestType\"] = getRandomDigest();\n\n                    cryptofuzz::operation::Schnorr_Sign op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}
{"text_input": "Generate ECCSI_Verify code for mutator.cpp", "output": "            case    CF_OPERATION(\"ECCSI_Verify\"):                {\n                    parameters[\"modifier\"] = getBuffer(PRNG() % 1024);\n\n                    if ( Pool_CurveECCSISignature.Have() == true ) {\n                        const auto P = Pool_CurveECCSISignature.Get();\n#if 0\n                        parameters[\"curveType\"] = hint_ecc_mont(P.curveID);\n\n                        parameters[\"signature\"][\"pub\"][0] = getBool() ? getBignum() : P.pub_x;\n                        parameters[\"signature\"][\"pub\"][1] = getBool() ? getBignum() : P.pub_y;\n\n                        parameters[\"signature\"][\"pvt\"][0] = getBool() ? getBignum() : P.pvt_x;\n                        parameters[\"signature\"][\"pvt\"][1] = getBool() ? getBignum() : P.pvt_y;\n\n                        parameters[\"signature\"][\"signature\"][0] = getBool() ? getBignum() : P.sig_r;\n                        parameters[\"signature\"][\"signature\"][1] = getBool() ? getBignum() : P.sig_s;\n\n                        parameters[\"cleartext\"] = P.cleartext;\n                        parameters[\"id\"] = P.id;\n#endif\n                        parameters[\"curveType\"] = hint_ecc_mont(P.curveID);\n\n                        parameters[\"signature\"][\"pub\"][0] = P.pub_x;\n                        parameters[\"signature\"][\"pub\"][1] = P.pub_y;\n\n                        parameters[\"signature\"][\"pvt\"][0] = P.pvt_x;\n                        parameters[\"signature\"][\"pvt\"][1] = P.pvt_y;\n\n                        parameters[\"signature\"][\"signature\"][0] = P.sig_r;\n                        parameters[\"signature\"][\"signature\"][1] = P.sig_s;\n\n                        parameters[\"cleartext\"] = P.cleartext;\n                        parameters[\"id\"] = P.id;\n                    } else {\n                        parameters[\"curveType\"] = hint_ecc_mont(getRandomCurve());\n\n                        parameters[\"signature\"][\"pub\"][0] = getBignum();\n                        parameters[\"signature\"][\"pub\"][1] = getBignum();\n\n                        parameters[\"signature\"][\"pvt\"][0] = getBignum();\n                        parameters[\"signature\"][\"pvt\"][1] = getBignum();\n\n                        parameters[\"signature\"][\"signature\"][0] = getBignum();\n                        parameters[\"signature\"][\"signature\"][1] = getBignum();\n\n                        parameters[\"cleartext\"] = cryptofuzz::util::DecToHex(getBignum(true), (PRNG() % 64) * 2);\n                        parameters[\"id\"] = cryptofuzz::util::DecToHex(getBignum(true), (PRNG() % 64) * 2);\n                    }\n\n                    parameters[\"digestType\"] = getRandomDigest();\n\n                    cryptofuzz::operation::ECCSI_Verify op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}
{"text_input": "Generate ECDSA_Verify code for mutator.cpp", "output": "            case    CF_OPERATION(\"ECDSA_Verify\"):                {\n                    parameters[\"modifier\"] = getBuffer(PRNG() % 1024);\n\n                    if ( Pool_CurveECDSASignature.Have() == true ) {\n                        const auto P = Pool_CurveECDSASignature.Get();\n                        parameters[\"curveType\"] = hint_ecc_mont(P.curveID);\n\n                        parameters[\"signature\"][\"pub\"][0] = getBool() ? getBignum() : P.pub_x;\n                        parameters[\"signature\"][\"pub\"][1] = getBool() ? getBignum() : P.pub_y;\n\n                        parameters[\"signature\"][\"signature\"][0] = getBool() ? getBignum() : P.sig_r;\n                        auto sigS = getBool() ? getBignum() : P.sig_y;\n\n                        if ( getBool() ) {\n                            /* Test ECDSA signature malleability */\n\n                            const auto order = cryptofuzz::repository::ECC_CurveToOrder(P.curveID);\n                            if ( order != std::nullopt ) {\n                                const auto o = boost::multiprecision::cpp_int(*order);\n                                const auto s = boost::multiprecision::cpp_int(sigS);\n                                if ( o > s ) {\n                                    sigS = boost::lexical_cast<std::string>(o - s);\n                                }\n                            }\n                        }\n\n                        parameters[\"signature\"][\"signature\"][1] = sigS;\n                        parameters[\"cleartext\"] = P.cleartext;\n                    } else {\n                        parameters[\"curveType\"] = hint_ecc_mont(getRandomCurve());\n\n                        parameters[\"signature\"][\"pub\"][0] = getBignum();\n                        parameters[\"signature\"][\"pub\"][1] = getBignum();\n\n                        parameters[\"signature\"][\"signature\"][0] = getBignum();\n                        parameters[\"signature\"][\"signature\"][1] = getBignum();\n\n                        parameters[\"cleartext\"] = cryptofuzz::util::DecToHex(getBignum(true), (PRNG() % 64) * 2);\n                    }\n\n                    parameters[\"digestType\"] = getRandomDigest();\n\n                    cryptofuzz::operation::ECDSA_Verify op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}
{"text_input": "Generate ECGDSA_Verify code for mutator.cpp", "output": "            case    CF_OPERATION(\"ECGDSA_Verify\"):                {\n                    parameters[\"modifier\"] = getBuffer(PRNG() % 1024);\n\n                    if ( Pool_CurveECDSASignature.Have() == true ) {\n                        const auto P = Pool_CurveECDSASignature.Get();\n                        parameters[\"curveType\"] = hint_ecc_mont(P.curveID);\n\n                        parameters[\"signature\"][\"pub\"][0] = getBool() ? getBignum() : P.pub_x;\n                        parameters[\"signature\"][\"pub\"][1] = getBool() ? getBignum() : P.pub_y;\n\n                        parameters[\"signature\"][\"signature\"][0] = getBool() ? getBignum() : P.sig_r;\n                        auto sigS = getBool() ? getBignum() : P.sig_y;\n\n                        if ( getBool() ) {\n                            /* Test ECGDSA signature malleability */\n\n                            const auto order = cryptofuzz::repository::ECC_CurveToOrder(P.curveID);\n                            if ( order != std::nullopt ) {\n                                const auto o = boost::multiprecision::cpp_int(*order);\n                                const auto s = boost::multiprecision::cpp_int(sigS);\n                                if ( o > s ) {\n                                    sigS = boost::lexical_cast<std::string>(o - s);\n                                }\n                            }\n                        }\n\n                        parameters[\"signature\"][\"signature\"][1] = sigS;\n                        parameters[\"cleartext\"] = P.cleartext;\n                    } else {\n                        parameters[\"curveType\"] = hint_ecc_mont(getRandomCurve());\n\n                        parameters[\"signature\"][\"pub\"][0] = getBignum();\n                        parameters[\"signature\"][\"pub\"][1] = getBignum();\n\n                        parameters[\"signature\"][\"signature\"][0] = getBignum();\n                        parameters[\"signature\"][\"signature\"][1] = getBignum();\n\n                        parameters[\"cleartext\"] = cryptofuzz::util::DecToHex(getBignum(true), (PRNG() % 64) * 2);\n                    }\n\n                    parameters[\"digestType\"] = getRandomDigest();\n\n                    cryptofuzz::operation::ECGDSA_Verify op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}
{"text_input": "Generate ECRDSA_Verify code for mutator.cpp", "output": "            case    CF_OPERATION(\"ECRDSA_Verify\"):                {\n                    parameters[\"modifier\"] = getBuffer(PRNG() % 1024);\n\n                    if ( Pool_CurveECDSASignature.Have() == true ) {\n                        const auto P = Pool_CurveECDSASignature.Get();\n                        parameters[\"curveType\"] = hint_ecc_mont(P.curveID);\n\n                        parameters[\"signature\"][\"pub\"][0] = getBool() ? getBignum() : P.pub_x;\n                        parameters[\"signature\"][\"pub\"][1] = getBool() ? getBignum() : P.pub_y;\n\n                        parameters[\"signature\"][\"signature\"][0] = getBool() ? getBignum() : P.sig_r;\n                        auto sigS = getBool() ? getBignum() : P.sig_y;\n\n                        if ( getBool() ) {\n                            /* Test ECRDSA signature malleability */\n\n                            const auto order = cryptofuzz::repository::ECC_CurveToOrder(P.curveID);\n                            if ( order != std::nullopt ) {\n                                const auto o = boost::multiprecision::cpp_int(*order);\n                                const auto s = boost::multiprecision::cpp_int(sigS);\n                                if ( o > s ) {\n                                    sigS = boost::lexical_cast<std::string>(o - s);\n                                }\n                            }\n                        }\n\n                        parameters[\"signature\"][\"signature\"][1] = sigS;\n                        parameters[\"cleartext\"] = P.cleartext;\n                    } else {\n                        parameters[\"curveType\"] = hint_ecc_mont(getRandomCurve());\n\n                        parameters[\"signature\"][\"pub\"][0] = getBignum();\n                        parameters[\"signature\"][\"pub\"][1] = getBignum();\n\n                        parameters[\"signature\"][\"signature\"][0] = getBignum();\n                        parameters[\"signature\"][\"signature\"][1] = getBignum();\n\n                        parameters[\"cleartext\"] = cryptofuzz::util::DecToHex(getBignum(true), (PRNG() % 64) * 2);\n                    }\n\n                    parameters[\"digestType\"] = getRandomDigest();\n\n                    cryptofuzz::operation::ECRDSA_Verify op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}
{"text_input": "Generate Schnorr_Verify code for mutator.cpp", "output": "            case    CF_OPERATION(\"Schnorr_Verify\"):                {\n                    parameters[\"modifier\"] = getBuffer(PRNG() % 1024);\n\n                    if ( Pool_CurveECDSASignature.Have() == true ) {\n                        const auto P = Pool_CurveECDSASignature.Get();\n                        parameters[\"curveType\"] = hint_ecc_mont(P.curveID);\n\n                        parameters[\"signature\"][\"pub\"][0] = getBool() ? getBignum() : P.pub_x;\n                        parameters[\"signature\"][\"pub\"][1] = getBool() ? getBignum() : P.pub_y;\n\n                        parameters[\"signature\"][\"signature\"][0] = getBool() ? getBignum() : P.sig_r;\n                        auto sigS = getBool() ? getBignum() : P.sig_y;\n\n                        if ( getBool() ) {\n                            /* Test Schnorr signature malleability */\n\n                            const auto order = cryptofuzz::repository::ECC_CurveToOrder(P.curveID);\n                            if ( order != std::nullopt ) {\n                                const auto o = boost::multiprecision::cpp_int(*order);\n                                const auto s = boost::multiprecision::cpp_int(sigS);\n                                if ( o > s ) {\n                                    sigS = boost::lexical_cast<std::string>(o - s);\n                                }\n                            }\n                        }\n\n                        parameters[\"signature\"][\"signature\"][1] = sigS;\n                        parameters[\"cleartext\"] = P.cleartext;\n                    } else {\n                        parameters[\"curveType\"] = hint_ecc_mont(getRandomCurve());\n\n                        parameters[\"signature\"][\"pub\"][0] = getBignum();\n                        parameters[\"signature\"][\"pub\"][1] = getBignum();\n\n                        parameters[\"signature\"][\"signature\"][0] = getBignum();\n                        parameters[\"signature\"][\"signature\"][1] = getBignum();\n\n                        parameters[\"cleartext\"] = cryptofuzz::util::DecToHex(getBignum(true), (PRNG() % 64) * 2);\n                    }\n\n                    parameters[\"digestType\"] = getRandomDigest();\n\n                    cryptofuzz::operation::Schnorr_Verify op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}
{"text_input": "Generate ECDSA_Recover code for mutator.cpp", "output": "            case    CF_OPERATION(\"ECDSA_Recover\"):                {\n                    parameters[\"modifier\"] = getBuffer(PRNG() % 1024);\n\n                    if ( getBool() && Pool_CurveECDSASignature.Have() == true ) {\n                        const auto P = Pool_CurveECDSASignature.Get();\n                        parameters[\"curveType\"] = hint_ecc_mont(P.curveID);\n\n                        parameters[\"signature\"][0] = getBool() ? getBignum() : P.sig_r;\n                        parameters[\"signature\"][1] = getBool() ? getBignum() : P.sig_y;\n\n                        if ( getBool() ) {\n                            parameters[\"cleartext\"] = P.cleartext;\n                        } else {\n                            parameters[\"cleartext\"] = cryptofuzz::util::DecToHex(getBignum(true), (PRNG() % 64) * 2);\n                        }\n                    } else if ( getBool() && Pool_CurveECC_Point.Have() == true ) {\n                        const auto P = Pool_CurveECC_Point.Get();\n                        parameters[\"curveType\"] = hint_ecc_mont(P.curveID);\n\n                        parameters[\"signature\"][0] = getBool() ? getBignum() : P.x;\n                        parameters[\"signature\"][1] = getBool() ? getBignum() : P.y;\n\n                        parameters[\"cleartext\"] = cryptofuzz::util::DecToHex(getBignum(true), (PRNG() % 64) * 2);\n                    } else {\n                        parameters[\"curveType\"] = hint_ecc_mont(getRandomCurve());\n\n                        parameters[\"signature\"][0] = getBignum();\n                        parameters[\"signature\"][1] = getBignum();\n\n                        parameters[\"cleartext\"] = cryptofuzz::util::DecToHex(getBignum(true), (PRNG() % 64) * 2);\n                    }\n\n                    parameters[\"id\"] = PRNG() % 4;\n                    parameters[\"digestType\"] = getRandomDigest();\n\n                    cryptofuzz::operation::ECDSA_Recover op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}
{"text_input": "Generate ECC_GenerateKeyPair code for mutator.cpp", "output": "            case    CF_OPERATION(\"ECC_GenerateKeyPair\"):                {\n                    parameters[\"modifier\"] = getBuffer(PRNG() % 128);\n                    parameters[\"curveType\"] = hint_ecc_mont(getRandomCurve());\n\n                    cryptofuzz::operation::ECC_GenerateKeyPair op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}
{"text_input": "Generate ECIES_Encrypt code for mutator.cpp", "output": "            case    CF_OPERATION(\"ECIES_Encrypt\"):"}
{"text_input": "Generate ECIES_Decrypt code for mutator.cpp", "output": "            case    CF_OPERATION(\"ECIES_Decrypt\"):                {\n                    parameters[\"modifier\"] = getBuffer(PRNG() % 128);\n                    if ( operation == CF_OPERATION(\"ECIES_Encrypt\") ) {\n                        parameters[\"cleartext\"] = getBuffer(PRNG() % 1024);\n                    } else {\n                        parameters[\"ciphertext\"] = getBuffer(PRNG() % 1024);\n                    }\n                    //parameters[\"cipherType\"] = getRandomCipher();\n                    parameters[\"cipherType\"] = CF_CIPHER(\"AES_128_CBC\");\n                    parameters[\"iv_enabled\"] = false;\n\n                    parameters[\"priv\"] = getBignum();\n\n                    if ( Pool_CurveKeypair.Have() && getBool() == true ) {\n                        const auto P = Pool_CurveKeypair.Get();\n\n                        parameters[\"curveType\"] = hint_ecc_mont(P.curveID);\n                        parameters[\"pub_x\"] = P.pub_x;\n                        parameters[\"pub_y\"] = P.pub_y;\n\n                        if ( Pool_CurvePrivkey.Have() && getBool() == true ) {\n                            const auto P2 = Pool_CurvePrivkey.Get();\n                            if ( P2.curveID == P.curveID ) {\n                                parameters[\"priv\"] = P2.priv;\n                            }\n                        }\n                    } else {\n                        parameters[\"curveType\"] = hint_ecc_mont(getRandomCurve());\n                        parameters[\"pub_x\"] = getBignum();\n                        parameters[\"pub_y\"] = getBignum();\n                    }\n\n                    if ( operation == CF_OPERATION(\"ECIES_Encrypt\") ) {\n                        cryptofuzz::operation::ECIES_Encrypt op(parameters);\n                        op.Serialize(dsOut2);\n                    } else {\n                        cryptofuzz::operation::ECIES_Decrypt op(parameters);\n                        op.Serialize(dsOut2);\n                    }\n                }\n                break;\n"}
{"text_input": "Generate ECC_Point_Add code for mutator.cpp", "output": "            case    CF_OPERATION(\"ECC_Point_Add\"):                {\n                    parameters[\"modifier\"] = \"\";\n\n                    if ( Pool_CurveECC_Point.Have() == true ) {\n                        const auto P = Pool_CurveECC_Point.Get();\n                        parameters[\"curveType\"] = hint_ecc_mont(P.curveID);\n\n                        parameters[\"a_x\"] = getBool() ? getBignum() : P.x;\n                        parameters[\"a_y\"] = getBool() ? getBignum() : P.y;\n                    } else {\n                        parameters[\"curveType\"] = hint_ecc_mont(getRandomCurve());\n\n                        parameters[\"a_x\"] = getBignum();\n                        parameters[\"a_y\"] = getBignum();\n                    }\n\n                    if ( Pool_CurveECC_Point.Have() == true ) {\n                        const auto P = Pool_CurveECC_Point.Get();\n                        parameters[\"curveType\"] = hint_ecc_mont(P.curveID);\n\n                        parameters[\"b_x\"] = getBool() ? getBignum() : P.x;\n                        parameters[\"b_y\"] = getBool() ? getBignum() : P.y;\n                    } else {\n                        parameters[\"curveType\"] = hint_ecc_mont(getRandomCurve());\n\n                        parameters[\"b_x\"] = getBignum();\n                        parameters[\"b_y\"] = getBignum();\n                    }\n\n                    cryptofuzz::operation::ECC_Point_Add op(parameters);\n                    op.Serialize(dsOut2);\n\n                    generateECCPoint();\n                }\n                break;\n"}
{"text_input": "Generate ECC_Point_Sub code for mutator.cpp", "output": "            case    CF_OPERATION(\"ECC_Point_Sub\"):                {\n                    parameters[\"modifier\"] = \"\";\n\n                    if ( Pool_CurveECC_Point.Have() == true ) {\n                        const auto P = Pool_CurveECC_Point.Get();\n                        parameters[\"curveType\"] = hint_ecc_mont(P.curveID);\n\n                        parameters[\"a_x\"] = getBool() ? getBignum() : P.x;\n                        parameters[\"a_y\"] = getBool() ? getBignum() : P.y;\n                    } else {\n                        parameters[\"curveType\"] = hint_ecc_mont(getRandomCurve());\n\n                        parameters[\"a_x\"] = getBignum();\n                        parameters[\"a_y\"] = getBignum();\n                    }\n\n                    if ( Pool_CurveECC_Point.Have() == true ) {\n                        const auto P = Pool_CurveECC_Point.Get();\n                        parameters[\"curveType\"] = hint_ecc_mont(P.curveID);\n\n                        parameters[\"b_x\"] = getBool() ? getBignum() : P.x;\n                        parameters[\"b_y\"] = getBool() ? getBignum() : P.y;\n                    } else {\n                        parameters[\"curveType\"] = hint_ecc_mont(getRandomCurve());\n\n                        parameters[\"b_x\"] = getBignum();\n                        parameters[\"b_y\"] = getBignum();\n                    }\n\n                    cryptofuzz::operation::ECC_Point_Sub op(parameters);\n                    op.Serialize(dsOut2);\n\n                    generateECCPoint();\n                }\n                break;\n"}
{"text_input": "Generate ECC_Point_Mul code for mutator.cpp", "output": "            case    CF_OPERATION(\"ECC_Point_Mul\"):                {\n                    parameters[\"modifier\"] = \"\";\n\n                    if ( Pool_CurveECC_Point.Have() == true ) {\n                        const auto P = Pool_CurveECC_Point.Get();\n                        parameters[\"curveType\"] = hint_ecc_mont(P.curveID);\n\n                        parameters[\"a_x\"] = getBool() ? getBignum() : P.x;\n                        parameters[\"a_y\"] = getBool() ? getBignum() : P.y;\n                    } else {\n                        parameters[\"curveType\"] = hint_ecc_mont(getRandomCurve());\n\n                        parameters[\"a_x\"] = getBignum();\n                        parameters[\"a_y\"] = getBignum();\n                    }\n\n                    parameters[\"b\"] = getBignum();\n\n                    cryptofuzz::operation::ECC_Point_Mul op(parameters);\n                    op.Serialize(dsOut2);\n\n                    generateECCPoint();\n                }\n                break;\n"}
{"text_input": "Generate ECC_Point_Neg code for mutator.cpp", "output": "            case    CF_OPERATION(\"ECC_Point_Neg\"):                {\n                    parameters[\"modifier\"] = \"\";\n\n                    if ( Pool_CurveECC_Point.Have() == true ) {\n                        const auto P = Pool_CurveECC_Point.Get();\n                        parameters[\"curveType\"] = hint_ecc_mont(P.curveID);\n\n                        parameters[\"a_x\"] = getBool() ? getBignum() : P.x;\n                        parameters[\"a_y\"] = getBool() ? getBignum() : P.y;\n                    } else {\n                        parameters[\"curveType\"] = hint_ecc_mont(getRandomCurve());\n\n                        parameters[\"a_x\"] = getBignum();\n                        parameters[\"a_y\"] = getBignum();\n                    }\n\n                    cryptofuzz::operation::ECC_Point_Neg op(parameters);\n                    op.Serialize(dsOut2);\n\n                    generateECCPoint();\n                }\n                break;\n"}
{"text_input": "Generate ECC_Point_Dbl code for mutator.cpp", "output": "            case    CF_OPERATION(\"ECC_Point_Dbl\"):                {\n                    parameters[\"modifier\"] = \"\";\n\n                    if ( Pool_CurveECC_Point.Have() == true ) {\n                        const auto P = Pool_CurveECC_Point.Get();\n                        parameters[\"curveType\"] = hint_ecc_mont(P.curveID);\n\n                        parameters[\"a_x\"] = getBool() ? getBignum() : P.x;\n                        parameters[\"a_y\"] = getBool() ? getBignum() : P.y;\n                    } else {\n                        parameters[\"curveType\"] = hint_ecc_mont(getRandomCurve());\n\n                        parameters[\"a_x\"] = getBignum();\n                        parameters[\"a_y\"] = getBignum();\n                    }\n\n                    cryptofuzz::operation::ECC_Point_Dbl op(parameters);\n                    op.Serialize(dsOut2);\n\n                    generateECCPoint();\n                }\n                break;\n"}
{"text_input": "Generate ECC_Point_Cmp code for mutator.cpp", "output": "            case    CF_OPERATION(\"ECC_Point_Cmp\"):                {\n                    parameters[\"modifier\"] = \"\";\n\n                    if ( Pool_CurveECC_Point.Have() == true ) {\n                        const auto P = Pool_CurveECC_Point.Get();\n                        parameters[\"curveType\"] = hint_ecc_mont(P.curveID);\n\n                        parameters[\"a_x\"] = getBool() ? getBignum() : P.x;\n                        parameters[\"a_y\"] = getBool() ? getBignum() : P.y;\n                    } else {\n                        parameters[\"curveType\"] = hint_ecc_mont(getRandomCurve());\n\n                        parameters[\"a_x\"] = getBignum();\n                        parameters[\"a_y\"] = getBignum();\n                    }\n\n                    if ( Pool_CurveECC_Point.Have() == true ) {\n                        const auto P = Pool_CurveECC_Point.Get();\n                        parameters[\"curveType\"] = hint_ecc_mont(P.curveID);\n\n                        parameters[\"b_x\"] = getBool() ? getBignum() : P.x;\n                        parameters[\"b_y\"] = getBool() ? getBignum() : P.y;\n                    } else {\n                        parameters[\"curveType\"] = hint_ecc_mont(getRandomCurve());\n\n                        parameters[\"b_x\"] = getBignum();\n                        parameters[\"b_y\"] = getBignum();\n                    }\n\n                    cryptofuzz::operation::ECC_Point_Cmp op(parameters);\n                    op.Serialize(dsOut2);\n\n                    generateECCPoint();\n                }\n                break;\n"}
{"text_input": "Generate KDF_SCRYPT code for mutator.cpp", "output": "            case    CF_OPERATION(\"KDF_SCRYPT\"):                {\n                    size_t numParts = 0;\n\n                    numParts++; /* modifier */\n                    numParts++; /* password */\n                    numParts++; /* salt */\n\n                    const auto lengths = SplitLength(maxSize - 64, numParts);\n\n                    parameters[\"modifier\"] = getBuffer(lengths[0]);\n                    parameters[\"password\"] = getBuffer(lengths[1]);\n                    parameters[\"salt\"] = getBuffer(lengths[2]);\n                    parameters[\"N\"] = PRNG() % 5;\n                    parameters[\"r\"] = PRNG() % 9;\n                    parameters[\"p\"] = PRNG() % 5;\n                    parameters[\"keySize\"] = PRNG() % 1024;\n\n                    cryptofuzz::operation::KDF_SCRYPT op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}
{"text_input": "Generate KDF_HKDF code for mutator.cpp", "output": "            case    CF_OPERATION(\"KDF_HKDF\"):                {\n                    size_t numParts = 0;\n\n                    numParts++; /* modifier */\n                    numParts++; /* password */\n                    numParts++; /* salt */\n                    numParts++; /* info */\n\n                    const auto lengths = SplitLength(maxSize - 64, numParts);\n\n                    parameters[\"modifier\"] = getBuffer(lengths[0]);\n                    parameters[\"password\"] = getBuffer(lengths[1]);\n                    parameters[\"salt\"] = getBuffer(lengths[2]);\n                    parameters[\"info\"] = getBuffer(lengths[3]);\n                    parameters[\"keySize\"] = PRNG() % 17000;\n                    parameters[\"digestType\"] = getRandomDigest();\n\n                    cryptofuzz::operation::KDF_HKDF op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}
{"text_input": "Generate KDF_TLS1_PRF code for mutator.cpp", "output": "            case    CF_OPERATION(\"KDF_TLS1_PRF\"):                {\n                    size_t numParts = 0;\n\n                    numParts++; /* modifier */\n                    numParts++; /* secret */\n                    numParts++; /* seed */\n\n                    const auto lengths = SplitLength(maxSize - 64, numParts);\n\n                    parameters[\"modifier\"] = getBuffer(lengths[0]);\n                    parameters[\"secret\"] = getBuffer(lengths[1]);\n                    parameters[\"seed\"] = getBuffer(lengths[2]);\n                    parameters[\"keySize\"] = PRNG() % 1024;\n                    parameters[\"digestType\"] = getRandomDigest();\n\n                    cryptofuzz::operation::KDF_TLS1_PRF op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}
{"text_input": "Generate KDF_PBKDF code for mutator.cpp", "output": "            case    CF_OPERATION(\"KDF_PBKDF\"):                {\n                    size_t numParts = 0;\n\n                    numParts++; /* modifier */\n                    numParts++; /* password */\n                    numParts++; /* salt */\n\n                    const auto lengths = SplitLength(maxSize - 64, numParts);\n\n                    parameters[\"modifier\"] = getBuffer(lengths[0]);\n                    parameters[\"password\"] = getBuffer(lengths[1]);\n                    parameters[\"salt\"] = getBuffer(lengths[2]);\n                    parameters[\"iterations\"] = PRNG() % 5;\n                    parameters[\"keySize\"] = PRNG() % 1024;\n                    parameters[\"digestType\"] = getRandomDigest();\n\n                    cryptofuzz::operation::KDF_PBKDF op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}
{"text_input": "Generate KDF_PBKDF1 code for mutator.cpp", "output": "            case    CF_OPERATION(\"KDF_PBKDF1\"):                {\n                    size_t numParts = 0;\n\n                    numParts++; /* modifier */\n                    numParts++; /* password */\n                    numParts++; /* salt */\n\n                    const auto lengths = SplitLength(maxSize - 64, numParts);\n\n                    parameters[\"modifier\"] = getBuffer(lengths[0]);\n                    parameters[\"password\"] = getBuffer(lengths[1]);\n                    parameters[\"salt\"] = getBuffer(lengths[2]);\n                    parameters[\"iterations\"] = PRNG() % 5;\n                    parameters[\"keySize\"] = PRNG() % 1024;\n                    parameters[\"digestType\"] = getRandomDigest();\n\n                    cryptofuzz::operation::KDF_PBKDF op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}
{"text_input": "Generate KDF_PBKDF2 code for mutator.cpp", "output": "            case    CF_OPERATION(\"KDF_PBKDF2\"):                {\n                    size_t numParts = 0;\n\n                    numParts++; /* modifier */\n                    numParts++; /* password */\n                    numParts++; /* salt */\n\n                    const auto lengths = SplitLength(maxSize - 64, numParts);\n\n                    parameters[\"modifier\"] = getBuffer(lengths[0]);\n                    parameters[\"password\"] = getBuffer(lengths[1]);\n                    parameters[\"salt\"] = getBuffer(lengths[2]);\n                    parameters[\"iterations\"] = PRNG() % 5;\n                    parameters[\"keySize\"] = PRNG() % 1024;\n                    parameters[\"digestType\"] = getRandomDigest();\n\n                    cryptofuzz::operation::KDF_PBKDF2 op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}
{"text_input": "Generate KDF_ARGON2 code for mutator.cpp", "output": "            case    CF_OPERATION(\"KDF_ARGON2\"):                {\n                    size_t numParts = 0;\n\n                    numParts++; /* modifier */\n                    numParts++; /* password */\n                    numParts++; /* salt */\n\n                    const auto lengths = SplitLength(maxSize - 64, numParts);\n\n                    parameters[\"modifier\"] = getBuffer(lengths[0]);\n                    parameters[\"password\"] = getBuffer(lengths[1]);\n                    parameters[\"salt\"] = getBuffer(lengths[2]);\n                    parameters[\"type\"] = PRNG() % 3;\n                    parameters[\"threads\"] = PRNG() % 256;\n                    parameters[\"memory\"] = PRNG() % (64*1024);\n                    parameters[\"iterations\"] = PRNG() % 3;\n                    parameters[\"keySize\"] = PRNG() % 1024;\n\n                    cryptofuzz::operation::KDF_ARGON2 op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}
{"text_input": "Generate KDF_SSH code for mutator.cpp", "output": "            case    CF_OPERATION(\"KDF_SSH\"):                {\n                    size_t numParts = 0;\n\n                    numParts++; /* modifier */\n                    numParts++; /* key */\n                    numParts++; /* xcghash */\n                    numParts++; /* session_id */\n\n                    const auto lengths = SplitLength(maxSize - 64, numParts);\n\n                    parameters[\"modifier\"] = getBuffer(lengths[0]);\n                    parameters[\"key\"] = getBuffer(lengths[1]);\n                    parameters[\"xcghash\"] = getBuffer(lengths[2]);\n                    parameters[\"session_id\"] = getBuffer(lengths[3]);\n                    parameters[\"type\"] = getBuffer(1);\n                    parameters[\"keySize\"] = PRNG() % 1024;\n                    parameters[\"digestType\"] = getRandomDigest();\n\n                    cryptofuzz::operation::KDF_SSH op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}
{"text_input": "Generate KDF_X963 code for mutator.cpp", "output": "            case    CF_OPERATION(\"KDF_X963\"):                {\n                    size_t numParts = 0;\n\n                    numParts++; /* modifier */\n                    numParts++; /* secret */\n                    numParts++; /* info */\n\n                    const auto lengths = SplitLength(maxSize - 64, numParts);\n\n                    parameters[\"modifier\"] = getBuffer(lengths[0]);\n                    parameters[\"secret\"] = getBuffer(lengths[1]);\n                    parameters[\"info\"] = getBuffer(lengths[2]);\n                    parameters[\"keySize\"] = PRNG() % 1024;\n                    parameters[\"digestType\"] = getRandomDigest();\n\n                    cryptofuzz::operation::KDF_X963 op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}
{"text_input": "Generate KDF_SP_800_108 code for mutator.cpp", "output": "            case    CF_OPERATION(\"KDF_SP_800_108\"):                {\n                    size_t numParts = 0;\n\n                    numParts++; /* modifier */\n                    numParts++; /* secret */\n                    numParts++; /* salt */\n                    numParts++; /* label */\n\n                    const auto lengths = SplitLength(maxSize - 64, numParts);\n\n                    if ( getBool() == true ) {\n                        /* MAC = HMAC */\n                        parameters[\"mech\"][\"mode\"] = true;\n                        parameters[\"mech\"][\"type\"] = getRandomDigest();\n                    } else {\n                        /* MAC = CMAC */\n                        parameters[\"mech\"][\"mode\"] = false;\n                        parameters[\"mech\"][\"type\"] = getRandomCipher();\n                    }\n\n                    parameters[\"modifier\"] = getBuffer(lengths[0]);\n                    parameters[\"secret\"] = getBuffer(lengths[1]);\n                    parameters[\"salt\"] = getBuffer(lengths[2]);\n                    parameters[\"label\"] = getBuffer(lengths[3]);\n                    parameters[\"mode\"] = PRNG() % 3;\n                    parameters[\"keySize\"] = PRNG() % 17000;\n\n                    cryptofuzz::operation::KDF_SP_800_108 op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}
{"text_input": "Generate KDF_SRTP code for mutator.cpp", "output": "            case    CF_OPERATION(\"KDF_SRTP\"):                {\n                    parameters[\"modifier\"] = \"\";\n                    parameters[\"key\"] = getBuffer(PRNG() % 64);\n                    parameters[\"salt\"] = getBuffer(PRNG() % 20);\n                    parameters[\"kdr\"] = PRNG() % 256;\n                    parameters[\"index\"] = PRNG();\n                    parameters[\"key1Size\"] = PRNG() % (1024 * 1024);\n                    parameters[\"key2Size\"] = PRNG() % (1024 * 1024);\n                    parameters[\"key3Size\"] = PRNG() % (1024 * 1024);\n\n                    cryptofuzz::operation::KDF_SRTP op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}
{"text_input": "Generate KDF_SRTCP code for mutator.cpp", "output": "            case    CF_OPERATION(\"KDF_SRTCP\"):                {\n                    parameters[\"modifier\"] = \"\";\n                    parameters[\"key\"] = getBuffer(PRNG() % 64);\n                    parameters[\"salt\"] = getBuffer(PRNG() % 20);\n                    parameters[\"kdr\"] = PRNG() % 256;\n                    parameters[\"index\"] = PRNG();\n                    parameters[\"key1Size\"] = PRNG() % (1024 * 1024);\n                    parameters[\"key2Size\"] = PRNG() % (1024 * 1024);\n                    parameters[\"key3Size\"] = PRNG() % (1024 * 1024);\n\n                    cryptofuzz::operation::KDF_SRTCP op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}
{"text_input": "Generate DH_GenerateKeyPair code for mutator.cpp", "output": "            case    CF_OPERATION(\"DH_GenerateKeyPair\"):                {\n                    parameters[\"modifier\"] = getBuffer(PRNG() % 1000);\n                    parameters[\"prime\"] = getBignum();\n                    parameters[\"base\"] = getBignum();\n\n                    cryptofuzz::operation::DH_GenerateKeyPair op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}
{"text_input": "Generate DH_Derive code for mutator.cpp", "output": "            case    CF_OPERATION(\"DH_Derive\"):                {\n                    parameters[\"modifier\"] = getBuffer(PRNG() % 1000);\n                    parameters[\"prime\"] = getBignum();\n                    parameters[\"base\"] = getBignum();\n                    if ( Pool_DH_PublicKey.Have() && getBool() == true ) {\n                        parameters[\"pub\"] = Pool_DH_PublicKey.Get();\n                    } else {\n                        parameters[\"pub\"] = getBignum();\n                    }\n\n                    if ( Pool_DH_PrivateKey.Have() && getBool() == true ) {\n                        parameters[\"priv\"] = Pool_DH_PrivateKey.Get();\n                    } else {\n                        parameters[\"priv\"] = getBignum();\n                    }\n\n                    cryptofuzz::operation::DH_Derive op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}
{"text_input": "Generate BLS_PrivateToPublic code for mutator.cpp", "output": "            case    CF_OPERATION(\"BLS_PrivateToPublic\"):                {\n                    parameters[\"modifier\"] = getBuffer(PRNG() % 1000);\n                    parameters[\"curveType\"] = hint_ecc_mont(getRandomCurve());\n\n                    parameters[\"priv\"] = getBignum();\n\n                    cryptofuzz::operation::BLS_PrivateToPublic op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}
{"text_input": "Generate BLS_PrivateToPublic_G2 code for mutator.cpp", "output": "            case    CF_OPERATION(\"BLS_PrivateToPublic_G2\"):                {\n                    parameters[\"modifier\"] = getBuffer(PRNG() % 1000);\n                    parameters[\"curveType\"] = hint_ecc_mont(getRandomCurve());\n\n                    parameters[\"priv\"] = getBignum();\n\n                    cryptofuzz::operation::BLS_PrivateToPublic_G2 op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}
{"text_input": "Generate BLS_Sign code for mutator.cpp", "output": "            case    CF_OPERATION(\"BLS_Sign\"):                {\n                    parameters[\"modifier\"] = getBuffer(PRNG() % 1000);\n                    parameters[\"curveType\"] = hint_ecc_mont(getRandomCurve());\n                    const auto hashOrPoint = getBool();\n                    //const auto hashOrPoint = false;\n                    parameters[\"hashOrPoint\"] = hashOrPoint;\n                    if ( hashOrPoint == true ) {\n                        //parameters[\"cleartext\"] = getBuffer(PRNG() % 32);\n                        parameters[\"cleartext\"] = cryptofuzz::util::DecToHex(getBignum(true), (PRNG() % 64) * 2);\n                        parameters[\"point_v\"] = \"\";\n                        parameters[\"point_w\"] = \"\";\n                        parameters[\"point_x\"] = \"\";\n                        parameters[\"point_y\"] = \"\";\n                    } else {\n                        if ( getBool() && Pool_CurveBLSG2.Have() == true ) {\n                            const auto P = Pool_CurveBLSG2.Get();\n                            parameters[\"point_v\"] = GET_OR_BIGNUM(P.g2_v);\n                            parameters[\"point_w\"] = GET_OR_BIGNUM(P.g2_w);\n                            parameters[\"point_x\"] = GET_OR_BIGNUM(P.g2_x);\n                            parameters[\"point_y\"] = GET_OR_BIGNUM(P.g2_y);\n                        } else {\n                            parameters[\"point_v\"] = getBignum();\n                            parameters[\"point_w\"] = getBignum();\n                            parameters[\"point_x\"] = getBignum();\n                            parameters[\"point_y\"] = getBignum();\n                        }\n\n                        parameters[\"cleartext\"] = \"\";\n                    }\n                    parameters[\"dest\"] = getBool() ? getBuffer(PRNG() % 512) : get_BLS_predefined_DST();\n                    parameters[\"aug\"] = \"\";\n                    parameters[\"priv\"] = getBignum();\n\n                    cryptofuzz::operation::BLS_Sign op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}
{"text_input": "Generate BLS_Verify code for mutator.cpp", "output": "            case    CF_OPERATION(\"BLS_Verify\"):                {\n                    parameters[\"modifier\"] = getBuffer(PRNG() % 1000);\n\n                    if ( Pool_CurveBLSSignature.Have() == true ) {\n                        const auto P = Pool_CurveBLSSignature.Get();\n\n                        parameters[\"curveType\"] = hint_ecc_mont(P.curveID);\n                        parameters[\"hashOrPoint\"] = P.hashOrPoint;\n                        parameters[\"point_v\"] = GET_OR_BIGNUM(P.point_v);\n                        parameters[\"point_w\"] = GET_OR_BIGNUM(P.point_w);\n                        parameters[\"point_x\"] = GET_OR_BIGNUM(P.point_x);\n                        parameters[\"point_y\"] = GET_OR_BIGNUM(P.point_y);\n                        parameters[\"cleartext\"] = P.cleartext;\n                        parameters[\"dest\"] = P.dest;\n                        parameters[\"aug\"] = P.aug;\n                        parameters[\"pub_x\"] = GET_OR_BIGNUM(P.pub_x);\n                        parameters[\"pub_y\"] = GET_OR_BIGNUM(P.pub_y);\n                        parameters[\"sig_v\"] = GET_OR_BIGNUM(P.sig_v);\n                        parameters[\"sig_w\"] = GET_OR_BIGNUM(P.sig_w);\n                        parameters[\"sig_x\"] = GET_OR_BIGNUM(P.sig_x);\n                        parameters[\"sig_y\"] = GET_OR_BIGNUM(P.sig_y);\n                    } else {\n                        parameters[\"curveType\"] = hint_ecc_mont(getRandomCurve());\n                        const auto hashOrPoint = getBool();\n                        parameters[\"hashOrPoint\"] = hashOrPoint;\n                        if ( hashOrPoint == true ) {\n                            parameters[\"cleartext\"] = getBuffer(PRNG() % 32);\n                            parameters[\"point_v\"] = \"\";\n                            parameters[\"point_w\"] = \"\";\n                            parameters[\"point_x\"] = \"\";\n                            parameters[\"point_y\"] = \"\";\n                        } else {\n                            parameters[\"point_v\"] = getBignum();\n                            parameters[\"point_w\"] = getBignum();\n                            parameters[\"point_x\"] = getBignum();\n                            parameters[\"point_y\"] = getBignum();\n                            parameters[\"cleartext\"] = \"\";\n                        }\n                        parameters[\"dest\"] = getBool() ? getBuffer(PRNG() % 512) : get_BLS_predefined_DST();\n                        parameters[\"pub_x\"] = getBignum();\n                        parameters[\"pub_y\"] = getBignum();\n                        parameters[\"sig_v\"] = getBignum();\n                        parameters[\"sig_w\"] = getBignum();\n                        parameters[\"sig_x\"] = getBignum();\n                        parameters[\"sig_y\"] = getBignum();\n                    }\n\n                    cryptofuzz::operation::BLS_Verify op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}
{"text_input": "Generate BLS_BatchSign code for mutator.cpp", "output": "            case    CF_OPERATION(\"BLS_BatchSign\"):                {\n                    parameters[\"modifier\"] = \"\";\n\n                    //const size_t num = PRNG() % 100;\n                    //const size_t num = (PRNG() % 50) + 30;\n                    const size_t num = (PRNG() % 8) + 1;\n\n                    parameters[\"bf\"] = nlohmann::json::array();\n\n                    for (size_t i = 0; i < num; i++) {\n                        const auto P = Pool_CurveBLSG1.Get();\n\n                        nlohmann::json p;\n\n                        p[\"priv\"] = getBignum();\n                        p[\"g1_x\"] = P.g1_x;\n                        p[\"g1_y\"] = P.g1_y;\n\n                        parameters[\"bf\"].push_back(p);\n                    }\n\n                    cryptofuzz::operation::BLS_BatchSign op(parameters);\n                    op.Serialize(dsOut2);\n\n                    generateECCPoint();\n                }\n                break;\n"}
{"text_input": "Generate BLS_BatchVerify code for mutator.cpp", "output": "            case    CF_OPERATION(\"BLS_BatchVerify\"):                {\n                    parameters[\"modifier\"] = \"\";\n                    parameters[\"dest\"] = get_BLS_predefined_DST();\n\n                    std::vector<\n                        std::pair<\n                            std::array<std::string, 2>,\n                            std::array<std::string, 4>\n                        >\n                    > points;\n\n                    if ( Pool_BLS_BatchSignature.Have() == true ) {\n                        const auto sig = Pool_BLS_BatchSignature.Get();\n\n                        for (const auto& mp : sig.msgpub) {\n                            std::array<std::string, 2> g1;\n                            std::array<std::string, 4> g2;\n\n                            switch ( PRNG() % 3 ) {\n                                case    0:\n                                    {\n                                        const auto P = Pool_CurveBLSG1.Get();\n                                        g1 = {P.g1_x, P.g1_y};\n                                    }\n                                    break;\n                                case    1:\n                                    g1 = {mp.first.g1_x, mp.first.g1_y};\n                                    break;\n                                case    2:\n                                    g1 = {getBignum(), getBignum()};\n                                    break;\n                            }\n\n                            if ( (PRNG()%3) == 0 ) {\n                                const auto P2 = Pool_CurveBLSG2.Get();\n                                g2 = {P2.g2_v, P2.g2_w, P2.g2_x, P2.g2_y};\n                            } else {\n                                g2 = {mp.second.g2_v, mp.second.g2_w, mp.second.g2_x, mp.second.g2_y};\n                            }\n\n                            points.push_back({g1, g2});\n                        }\n\n                        parameters[\"bf\"] = nlohmann::json::array();\n\n                        std::shuffle(std::begin(points), std::end(points), rng);\n\n                        for (const auto& p : points) {\n                            nlohmann::json cur;\n                            cur[\"g1_x\"] = p.first[0];\n                            cur[\"g1_y\"] = p.first[1];\n\n                            cur[\"g2_v\"] = p.second[0];\n                            cur[\"g2_w\"] = p.second[1];\n                            cur[\"g2_x\"] = p.second[2];\n                            cur[\"g2_y\"] = p.second[3];\n                            parameters[\"bf\"].push_back(cur);\n                        }\n\n                        cryptofuzz::operation::BLS_BatchVerify op(parameters);\n                        op.Serialize(dsOut2);\n                    } else {\n                        goto end;\n                    }\n                }\n                break;\n"}
{"text_input": "Generate BLS_IsG1OnCurve code for mutator.cpp", "output": "            case    CF_OPERATION(\"BLS_IsG1OnCurve\"):                {\n                    parameters[\"modifier\"] = getBuffer(PRNG() % 1000);\n                    parameters[\"curveType\"] = hint_ecc_mont(getRandomCurve());\n\n                    if ( getBool() && Pool_CurveBLSG1.Have() == true ) {\n                        const auto P = Pool_CurveBLSG1.Get();\n                        parameters[\"g1_x\"] = GET_OR_BIGNUM(P.g1_x);\n                        parameters[\"g1_y\"] = GET_OR_BIGNUM(P.g1_y);\n                    } else {\n                        parameters[\"g1_x\"] = getBignum();\n                        parameters[\"g1_y\"] = getBignum();\n                    }\n\n                    cryptofuzz::operation::BLS_IsG1OnCurve op(parameters);\n                    op.Serialize(dsOut2);\n\n                    generateECCPoint();\n                }\n                break;\n"}
{"text_input": "Generate BLS_IsG2OnCurve code for mutator.cpp", "output": "            case    CF_OPERATION(\"BLS_IsG2OnCurve\"):                {\n                    parameters[\"modifier\"] = getBuffer(PRNG() % 1000);\n                    parameters[\"curveType\"] = hint_ecc_mont(getRandomCurve());\n\n                    if ( getBool() && Pool_CurveBLSG2.Have() == true ) {\n                        const auto P = Pool_CurveBLSG2.Get();\n                        parameters[\"g2_v\"] = GET_OR_BIGNUM(P.g2_v);\n                        parameters[\"g2_w\"] = GET_OR_BIGNUM(P.g2_w);\n                        parameters[\"g2_x\"] = GET_OR_BIGNUM(P.g2_x);\n                        parameters[\"g2_y\"] = GET_OR_BIGNUM(P.g2_y);\n                    } else {\n                        parameters[\"g2_v\"] = getBignum();\n                        parameters[\"g2_w\"] = getBignum();\n                        parameters[\"g2_x\"] = getBignum();\n                        parameters[\"g2_y\"] = getBignum();\n                    }\n\n                    cryptofuzz::operation::BLS_IsG2OnCurve op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}
{"text_input": "Generate BLS_GenerateKeyPair code for mutator.cpp", "output": "            case    CF_OPERATION(\"BLS_GenerateKeyPair\"):                {\n                    parameters[\"modifier\"] = getBuffer(PRNG() % 1000);\n                    parameters[\"curveType\"] = hint_ecc_mont(getRandomCurve());\n                    parameters[\"ikm\"] = getBuffer(PRNG() % 512);\n                    parameters[\"info\"] = getBuffer(PRNG() % 512);\n\n                    cryptofuzz::operation::BLS_GenerateKeyPair op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}
{"text_input": "Generate BLS_Decompress_G1 code for mutator.cpp", "output": "            case    CF_OPERATION(\"BLS_Decompress_G1\"):                {\n                    parameters[\"modifier\"] = getBuffer(PRNG() % 1000);\n                    parameters[\"curveType\"] = hint_ecc_mont(getRandomCurve());\n                    parameters[\"compressed\"] = getBignum();\n\n                    cryptofuzz::operation::BLS_Decompress_G1 op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}
{"text_input": "Generate BLS_Compress_G1 code for mutator.cpp", "output": "            case    CF_OPERATION(\"BLS_Compress_G1\"):                {\n                    parameters[\"modifier\"] = getBuffer(PRNG() % 1000);\n                    parameters[\"curveType\"] = hint_ecc_mont(getRandomCurve());\n\n                    if ( getBool() && Pool_CurveBLSG1.Have() == true ) {\n                        const auto P = Pool_CurveBLSG1.Get();\n                        parameters[\"g1_x\"] = GET_OR_BIGNUM(P.g1_x);\n                        parameters[\"g1_y\"] = GET_OR_BIGNUM(P.g1_y);\n                    } else {\n                        parameters[\"g1_x\"] = getBignum();\n                        parameters[\"g1_y\"] = getBignum();\n                    }\n\n                    cryptofuzz::operation::BLS_Compress_G1 op(parameters);\n                    op.Serialize(dsOut2);\n\n                    generateECCPoint();\n                }\n                break;\n"}
{"text_input": "Generate BLS_Decompress_G2 code for mutator.cpp", "output": "            case    CF_OPERATION(\"BLS_Decompress_G2\"):                {\n                    parameters[\"modifier\"] = getBuffer(PRNG() % 1000);\n                    parameters[\"curveType\"] = hint_ecc_mont(getRandomCurve());\n                    parameters[\"g1_x\"] = getBignum();\n                    parameters[\"g1_y\"] = getBignum();\n\n                    cryptofuzz::operation::BLS_Decompress_G2 op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}
{"text_input": "Generate BLS_Compress_G2 code for mutator.cpp", "output": "            case    CF_OPERATION(\"BLS_Compress_G2\"):                {\n                    parameters[\"modifier\"] = getBuffer(PRNG() % 1000);\n                    parameters[\"curveType\"] = hint_ecc_mont(getRandomCurve());\n\n                    if ( getBool() && Pool_CurveBLSG2.Have() == true ) {\n                        const auto P = Pool_CurveBLSG2.Get();\n                        parameters[\"g2_v\"] = GET_OR_BIGNUM(P.g2_v);\n                        parameters[\"g2_w\"] = GET_OR_BIGNUM(P.g2_w);\n                        parameters[\"g2_x\"] = GET_OR_BIGNUM(P.g2_x);\n                        parameters[\"g2_y\"] = GET_OR_BIGNUM(P.g2_y);\n                    } else {\n                        parameters[\"g2_v\"] = getBignum();\n                        parameters[\"g2_w\"] = getBignum();\n                        parameters[\"g2_x\"] = getBignum();\n                        parameters[\"g2_y\"] = getBignum();\n                    }\n\n                    cryptofuzz::operation::BLS_Compress_G2 op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}
{"text_input": "Generate BLS_HashToG1 code for mutator.cpp", "output": "            case    CF_OPERATION(\"BLS_HashToG1\"):                {\n                    parameters[\"modifier\"] = getBuffer(PRNG() % 1000);\n                    parameters[\"curveType\"] = hint_ecc_mont(getRandomCurve());\n                    parameters[\"cleartext\"] = getBuffer(PRNG() % 1024);\n                    parameters[\"dest\"] = getBool() ? getBuffer(PRNG() % 512) : get_BLS_predefined_DST();\n\n                    parameters[\"aug\"] = getBuffer(PRNG() % 1024);\n\n                    cryptofuzz::operation::BLS_HashToG1 op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}
{"text_input": "Generate BLS_HashToG2 code for mutator.cpp", "output": "            case    CF_OPERATION(\"BLS_HashToG2\"):                {\n                    parameters[\"modifier\"] = getBuffer(PRNG() % 1000);\n                    parameters[\"curveType\"] = hint_ecc_mont(getRandomCurve());\n                    parameters[\"cleartext\"] = getBuffer(PRNG() % 1024);\n                    parameters[\"dest\"] = getBool() ? getBuffer(PRNG() % 512) : get_BLS_predefined_DST();\n                    parameters[\"aug\"] = getBuffer(PRNG() % 1024);\n\n                    cryptofuzz::operation::BLS_HashToG2 op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}
{"text_input": "Generate BLS_MapToG1 code for mutator.cpp", "output": "            case    CF_OPERATION(\"BLS_MapToG1\"):                {\n                    parameters[\"modifier\"] = \"\";\n                    parameters[\"curveType\"] = hint_ecc_mont(getRandomCurve());\n                    parameters[\"u\"] = getBignum();\n                    parameters[\"v\"] = getBignum();\n\n                    cryptofuzz::operation::BLS_MapToG1 op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}
{"text_input": "Generate BLS_MapToG2 code for mutator.cpp", "output": "            case    CF_OPERATION(\"BLS_MapToG2\"):                {\n                    parameters[\"modifier\"] = \"\";\n                    parameters[\"curveType\"] = hint_ecc_mont(getRandomCurve());\n                    parameters[\"u\"][0] = getBignum();\n                    parameters[\"u\"][1] = getBignum();\n                    parameters[\"v\"][0] = getBignum();\n                    parameters[\"v\"][1] = getBignum();\n\n                    cryptofuzz::operation::BLS_MapToG2 op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}
{"text_input": "Generate BLS_Pairing code for mutator.cpp", "output": "            case    CF_OPERATION(\"BLS_Pairing\"):                {\n                    parameters[\"modifier\"] = \"\";\n                    parameters[\"curveType\"] = hint_ecc_mont(getRandomCurve());\n\n                    if ( getBool() && Pool_CurveBLSG1.Have() == true ) {\n                        const auto P = Pool_CurveBLSG1.Get();\n                        parameters[\"g1_x\"] = GET_OR_BIGNUM(P.g1_x);\n                        parameters[\"g1_y\"] = GET_OR_BIGNUM(P.g1_y);\n                    } else {\n                        parameters[\"g1_x\"] = getBignum();\n                        parameters[\"g1_y\"] = getBignum();\n                    }\n\n                    if ( getBool() && Pool_CurveBLSG2.Have() == true ) {\n                        const auto P = Pool_CurveBLSG2.Get();\n                        parameters[\"g2_v\"] = GET_OR_BIGNUM(P.g2_v);\n                        parameters[\"g2_w\"] = GET_OR_BIGNUM(P.g2_w);\n                        parameters[\"g2_x\"] = GET_OR_BIGNUM(P.g2_x);\n                        parameters[\"g2_y\"] = GET_OR_BIGNUM(P.g2_y);\n                    } else {\n                        parameters[\"g2_v\"] = getBignum();\n                        parameters[\"g2_w\"] = getBignum();\n                        parameters[\"g2_x\"] = getBignum();\n                        parameters[\"g2_y\"] = getBignum();\n                    }\n\n                    cryptofuzz::operation::BLS_Pairing op(parameters);\n                    op.Serialize(dsOut2);\n\n                    generateECCPoint();\n                }\n                break;\n"}
{"text_input": "Generate BLS_MillerLoop code for mutator.cpp", "output": "            case    CF_OPERATION(\"BLS_MillerLoop\"):                {\n                    parameters[\"modifier\"] = \"\";\n                    parameters[\"curveType\"] = hint_ecc_mont(getRandomCurve());\n\n                    if ( getBool() && Pool_CurveBLSG1.Have() == true ) {\n                        const auto P = Pool_CurveBLSG1.Get();\n                        parameters[\"g1_x\"] = GET_OR_BIGNUM(P.g1_x);\n                        parameters[\"g1_y\"] = GET_OR_BIGNUM(P.g1_y);\n                    } else {\n                        parameters[\"g1_x\"] = getBignum();\n                        parameters[\"g1_y\"] = getBignum();\n                    }\n\n                    if ( getBool() && Pool_CurveBLSG2.Have() == true ) {\n                        const auto P = Pool_CurveBLSG2.Get();\n                        parameters[\"g2_v\"] = GET_OR_BIGNUM(P.g2_v);\n                        parameters[\"g2_w\"] = GET_OR_BIGNUM(P.g2_w);\n                        parameters[\"g2_x\"] = GET_OR_BIGNUM(P.g2_x);\n                        parameters[\"g2_y\"] = GET_OR_BIGNUM(P.g2_y);\n                    } else {\n                        parameters[\"g2_v\"] = getBignum();\n                        parameters[\"g2_w\"] = getBignum();\n                        parameters[\"g2_x\"] = getBignum();\n                        parameters[\"g2_y\"] = getBignum();\n                    }\n\n                    cryptofuzz::operation::BLS_MillerLoop op(parameters);\n                    op.Serialize(dsOut2);\n\n                    generateECCPoint();\n                }\n                break;\n"}
{"text_input": "Generate BLS_FinalExp code for mutator.cpp", "output": "            case    CF_OPERATION(\"BLS_FinalExp\"):                {\n                    parameters[\"modifier\"] = \"\";\n                    parameters[\"curveType\"] = hint_ecc_mont(getRandomCurve());\n\n                    if ( Pool_Fp12.Have() && getBool() == true ) {\n                        const auto Fp12 = Pool_Fp12.Get();\n\n                        parameters[\"fp12\"][0] = Fp12.bn1;\n                        parameters[\"fp12\"][1] = Fp12.bn2;\n                        parameters[\"fp12\"][2] = Fp12.bn3;\n                        parameters[\"fp12\"][3] = Fp12.bn4;\n                        parameters[\"fp12\"][4] = Fp12.bn5;\n                        parameters[\"fp12\"][5] = Fp12.bn6;\n                        parameters[\"fp12\"][6] = Fp12.bn7;\n                        parameters[\"fp12\"][7] = Fp12.bn8;\n                        parameters[\"fp12\"][8] = Fp12.bn9;\n                        parameters[\"fp12\"][9] = Fp12.bn10;\n                        parameters[\"fp12\"][10] = Fp12.bn11;\n                        parameters[\"fp12\"][11] = Fp12.bn12;\n                    } else {\n                        parameters[\"fp12\"][0] = getBignum();\n                        parameters[\"fp12\"][1] = getBignum();\n                        parameters[\"fp12\"][2] = getBignum();\n                        parameters[\"fp12\"][3] = getBignum();\n                        parameters[\"fp12\"][4] = getBignum();\n                        parameters[\"fp12\"][5] = getBignum();\n                        parameters[\"fp12\"][6] = getBignum();\n                        parameters[\"fp12\"][7] = getBignum();\n                        parameters[\"fp12\"][8] = getBignum();\n                        parameters[\"fp12\"][9] = getBignum();\n                        parameters[\"fp12\"][10] = getBignum();\n                        parameters[\"fp12\"][11] = getBignum();\n                    }\n\n                    cryptofuzz::operation::BLS_FinalExp op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}
{"text_input": "Generate BLS_G1_Add code for mutator.cpp", "output": "            case    CF_OPERATION(\"BLS_G1_Add\"):                {\n                    parameters[\"modifier\"] = getBuffer(PRNG() % 1000);\n                    parameters[\"curveType\"] = hint_ecc_mont(getRandomCurve());\n\n                    if ( getBool() && Pool_CurveBLSG1.Have() == true ) {\n                        const auto P = Pool_CurveBLSG1.Get();\n                        parameters[\"a_x\"] = GET_OR_BIGNUM(P.g1_x);\n                        parameters[\"a_y\"] = GET_OR_BIGNUM(P.g1_y);\n                    } else {\n                        parameters[\"a_x\"] = getBignum();\n                        parameters[\"a_y\"] = getBignum();\n                    }\n\n                    if ( getBool() && Pool_CurveBLSG1.Have() == true ) {\n                        const auto P = Pool_CurveBLSG1.Get();\n                        parameters[\"b_x\"] = GET_OR_BIGNUM(P.g1_x);\n                        parameters[\"b_y\"] = GET_OR_BIGNUM(P.g1_y);\n                    } else {\n                        parameters[\"b_x\"] = getBignum();\n                        parameters[\"b_y\"] = getBignum();\n                    }\n\n                    cryptofuzz::operation::BLS_G1_Add op(parameters);\n                    op.Serialize(dsOut2);\n\n                    generateECCPoint();\n                }\n                break;\n"}
{"text_input": "Generate BLS_G1_Mul code for mutator.cpp", "output": "            case    CF_OPERATION(\"BLS_G1_Mul\"):                {\n                    parameters[\"modifier\"] = getBuffer(PRNG() % 1000);\n                    parameters[\"curveType\"] = hint_ecc_mont(getRandomCurve());\n\n                    if ( getBool() && Pool_CurveBLSG1.Have() == true ) {\n                        const auto P = Pool_CurveBLSG1.Get();\n                        parameters[\"a_x\"] = GET_OR_BIGNUM(P.g1_x);\n                        parameters[\"a_y\"] = GET_OR_BIGNUM(P.g1_y);\n                    } else {\n                        parameters[\"a_x\"] = getBignum();\n                        parameters[\"a_y\"] = getBignum();\n                    }\n\n                    parameters[\"b\"] = getBignum();\n\n                    cryptofuzz::operation::BLS_G1_Mul op(parameters);\n                    op.Serialize(dsOut2);\n\n                    generateECCPoint();\n                }\n                break;\n"}
{"text_input": "Generate BLS_G1_IsEq code for mutator.cpp", "output": "            case    CF_OPERATION(\"BLS_G1_IsEq\"):                {\n                    parameters[\"modifier\"] = getBuffer(PRNG() % 1000);\n                    parameters[\"curveType\"] = hint_ecc_mont(getRandomCurve());\n\n                    if ( getBool() && Pool_CurveBLSG1.Have() == true ) {\n                        const auto P = Pool_CurveBLSG1.Get();\n                        parameters[\"a_x\"] = GET_OR_BIGNUM(P.g1_x);\n                        parameters[\"a_y\"] = GET_OR_BIGNUM(P.g1_y);\n                    } else {\n                        parameters[\"a_x\"] = getBignum();\n                        parameters[\"a_y\"] = getBignum();\n                    }\n\n                    if ( getBool() && Pool_CurveBLSG1.Have() == true ) {\n                        const auto P = Pool_CurveBLSG1.Get();\n                        parameters[\"b_x\"] = GET_OR_BIGNUM(P.g1_x);\n                        parameters[\"b_y\"] = GET_OR_BIGNUM(P.g1_y);\n                    } else {\n                        parameters[\"b_x\"] = getBignum();\n                        parameters[\"b_y\"] = getBignum();\n                    }\n\n                    cryptofuzz::operation::BLS_G1_IsEq op(parameters);\n                    op.Serialize(dsOut2);\n\n                    generateECCPoint();\n                }\n                break;\n"}
{"text_input": "Generate BLS_G1_Neg code for mutator.cpp", "output": "            case    CF_OPERATION(\"BLS_G1_Neg\"):                {\n                    parameters[\"modifier\"] = getBuffer(PRNG() % 1000);\n                    parameters[\"curveType\"] = hint_ecc_mont(getRandomCurve());\n\n                    if ( getBool() && Pool_CurveBLSG1.Have() == true ) {\n                        const auto P = Pool_CurveBLSG1.Get();\n                        parameters[\"a_x\"] = GET_OR_BIGNUM(P.g1_x);\n                        parameters[\"a_y\"] = GET_OR_BIGNUM(P.g1_y);\n                    } else {\n                        parameters[\"a_x\"] = getBignum();\n                        parameters[\"a_y\"] = getBignum();\n                    }\n\n                    cryptofuzz::operation::BLS_G1_Neg op(parameters);\n                    op.Serialize(dsOut2);\n\n                    generateECCPoint();\n                }\n                break;\n"}
{"text_input": "Generate BLS_G2_Add code for mutator.cpp", "output": "            case    CF_OPERATION(\"BLS_G2_Add\"):                {\n                    parameters[\"modifier\"] = getBuffer(PRNG() % 1000);\n                    parameters[\"curveType\"] = hint_ecc_mont(getRandomCurve());\n\n                    if ( getBool() && Pool_CurveBLSG2.Have() == true ) {\n                        const auto P = Pool_CurveBLSG2.Get();\n                        parameters[\"a_v\"] = GET_OR_BIGNUM(P.g2_v);\n                        parameters[\"a_w\"] = GET_OR_BIGNUM(P.g2_w);\n                        parameters[\"a_x\"] = GET_OR_BIGNUM(P.g2_x);\n                        parameters[\"a_y\"] = GET_OR_BIGNUM(P.g2_y);\n                    } else {\n                        parameters[\"a_v\"] = getBignum();\n                        parameters[\"a_w\"] = getBignum();\n                        parameters[\"a_x\"] = getBignum();\n                        parameters[\"a_y\"] = getBignum();\n                    }\n\n                    if ( getBool() && Pool_CurveBLSG2.Have() == true ) {\n                        const auto P = Pool_CurveBLSG2.Get();\n                        parameters[\"b_v\"] = GET_OR_BIGNUM(P.g2_v);\n                        parameters[\"b_w\"] = GET_OR_BIGNUM(P.g2_w);\n                        parameters[\"b_x\"] = GET_OR_BIGNUM(P.g2_x);\n                        parameters[\"b_y\"] = GET_OR_BIGNUM(P.g2_y);\n                    } else {\n                        parameters[\"b_v\"] = getBignum();\n                        parameters[\"b_w\"] = getBignum();\n                        parameters[\"b_x\"] = getBignum();\n                        parameters[\"b_y\"] = getBignum();\n                    }\n\n                    cryptofuzz::operation::BLS_G2_Add op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}
{"text_input": "Generate BLS_G2_Mul code for mutator.cpp", "output": "            case    CF_OPERATION(\"BLS_G2_Mul\"):                {\n                    parameters[\"modifier\"] = getBuffer(PRNG() % 1000);\n                    parameters[\"curveType\"] = hint_ecc_mont(getRandomCurve());\n\n                    if ( getBool() && Pool_CurveBLSG2.Have() == true ) {\n                        const auto P = Pool_CurveBLSG2.Get();\n                        parameters[\"a_v\"] = GET_OR_BIGNUM(P.g2_v);\n                        parameters[\"a_w\"] = GET_OR_BIGNUM(P.g2_w);\n                        parameters[\"a_x\"] = GET_OR_BIGNUM(P.g2_x);\n                        parameters[\"a_y\"] = GET_OR_BIGNUM(P.g2_y);\n                    } else {\n                        parameters[\"a_v\"] = getBignum();\n                        parameters[\"a_w\"] = getBignum();\n                        parameters[\"a_x\"] = getBignum();\n                        parameters[\"a_y\"] = getBignum();\n                    }\n\n                    parameters[\"b\"] = getBignum();\n\n                    cryptofuzz::operation::BLS_G2_Mul op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}
{"text_input": "Generate BLS_G2_IsEq code for mutator.cpp", "output": "            case    CF_OPERATION(\"BLS_G2_IsEq\"):                {\n                    parameters[\"modifier\"] = getBuffer(PRNG() % 1000);\n                    parameters[\"curveType\"] = hint_ecc_mont(getRandomCurve());\n\n                    if ( getBool() && Pool_CurveBLSG2.Have() == true ) {\n                        const auto P = Pool_CurveBLSG2.Get();\n                        parameters[\"a_v\"] = GET_OR_BIGNUM(P.g2_v);\n                        parameters[\"a_w\"] = GET_OR_BIGNUM(P.g2_w);\n                        parameters[\"a_x\"] = GET_OR_BIGNUM(P.g2_x);\n                        parameters[\"a_y\"] = GET_OR_BIGNUM(P.g2_y);\n                    } else {\n                        parameters[\"a_v\"] = getBignum();\n                        parameters[\"a_w\"] = getBignum();\n                        parameters[\"a_x\"] = getBignum();\n                        parameters[\"a_y\"] = getBignum();\n                    }\n\n                    if ( getBool() && Pool_CurveBLSG2.Have() == true ) {\n                        const auto P = Pool_CurveBLSG2.Get();\n                        parameters[\"b_v\"] = GET_OR_BIGNUM(P.g2_v);\n                        parameters[\"b_w\"] = GET_OR_BIGNUM(P.g2_w);\n                        parameters[\"b_x\"] = GET_OR_BIGNUM(P.g2_x);\n                        parameters[\"b_y\"] = GET_OR_BIGNUM(P.g2_y);\n                    } else {\n                        parameters[\"b_v\"] = getBignum();\n                        parameters[\"b_w\"] = getBignum();\n                        parameters[\"b_x\"] = getBignum();\n                        parameters[\"b_y\"] = getBignum();\n                    }\n\n                    cryptofuzz::operation::BLS_G2_IsEq op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}
{"text_input": "Generate BLS_G2_Neg code for mutator.cpp", "output": "            case    CF_OPERATION(\"BLS_G2_Neg\"):                {\n                    parameters[\"modifier\"] = getBuffer(PRNG() % 1000);\n                    parameters[\"curveType\"] = hint_ecc_mont(getRandomCurve());\n\n                    if ( getBool() && Pool_CurveBLSG2.Have() == true ) {\n                        const auto P = Pool_CurveBLSG2.Get();\n                        parameters[\"a_v\"] = GET_OR_BIGNUM(P.g2_v);\n                        parameters[\"a_w\"] = GET_OR_BIGNUM(P.g2_w);\n                        parameters[\"a_x\"] = GET_OR_BIGNUM(P.g2_x);\n                        parameters[\"a_y\"] = GET_OR_BIGNUM(P.g2_y);\n                    } else {\n                        parameters[\"a_v\"] = getBignum();\n                        parameters[\"a_w\"] = getBignum();\n                        parameters[\"a_x\"] = getBignum();\n                        parameters[\"a_y\"] = getBignum();\n                    }\n\n                    cryptofuzz::operation::BLS_G2_Neg op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}
{"text_input": "Generate BLS_G1_MultiExp code for mutator.cpp", "output": "            case    CF_OPERATION(\"BLS_G1_MultiExp\"):                {\n                    parameters[\"modifier\"] = \"\";\n                    parameters[\"curveType\"] = hint_ecc_mont(getRandomCurve());\n\n                    const size_t num = (PRNG() % 256) + 2;\n                    parameters[\"points_scalars\"] = nlohmann::json::array();\n\n                    for (size_t i = 0; i < num; i++) {\n                        nlohmann::json ps;\n\n                        if ( Pool_CurveBLSG1.Have() == true ) {\n                            const auto P = Pool_CurveBLSG1.Get();\n                            ps[\"x\"] = P.g1_x;\n                            ps[\"y\"] = P.g1_y;\n                        } else {\n                            ps[\"x\"] = getBignum();\n                            ps[\"y\"] = getBignum();\n                        }\n                        ps[\"scalar\"] = getBignum();\n                        parameters[\"points_scalars\"].push_back(ps);\n                    }\n\n                    cryptofuzz::operation::BLS_G1_MultiExp op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}
{"text_input": "Generate SR25519_Verify code for mutator.cpp", "output": "            case    CF_OPERATION(\"SR25519_Verify\"):                {\n                    parameters[\"modifier\"] = getBuffer(PRNG() % 1024);\n\n                    parameters[\"signature\"][\"pub\"] = getBignum();\n\n                    parameters[\"signature\"][\"signature\"][0] = getBignum();\n                    parameters[\"signature\"][\"signature\"][1] = getBignum();\n\n                    parameters[\"cleartext\"] = cryptofuzz::util::DecToHex(getBignum(true), (PRNG() % 64) * 2);\n\n                    cryptofuzz::operation::SR25519_Verify op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}
