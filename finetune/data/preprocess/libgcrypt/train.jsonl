{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate Digest code for module.cpp"}, {"role": "assistant", "content": "std::optional<component::Digest> libgcrypt::OpDigest(operation::Digest& op) {\n\n    Datasource ds(op.modifier.GetPtr(), op.modifier.GetSize());\n    std::optional<component::Digest> ret = std::nullopt;\n    util::Multipart parts;\n\n    libgcrypt_detail::DigestHandle h(ds);\n    std::optional<int> digestType = std::nullopt;\n\n    /* Initialize */\n    {\n        CF_CHECK_NE(digestType = libgcrypt_detail::DigestIDToID(op.digestType.Get()), std::nullopt);\n\n        CF_CHECK_TRUE(h.Open(*digestType));\n\n        parts = util::ToParts(ds, op.cleartext);\n    }\n\n    /* Process */\n    for (const auto& part : parts) {\n        CF_CHECK_TRUE(h.Write(part.first, part.second));\n    }\n\n    /* Finalize */\n    {\n        /* noret */ h.Final();\n\n        switch ( op.digestType.Get() ) {\n            case    CF_DIGEST(\"SHAKE128\"):\n                {\n                    /* Same output size as OpenSSL with SHAKE128 by default */\n                    uint8_t out[16];\n                    CF_CHECK_EQ(gcry_md_extract(h.Get(), *digestType, out, sizeof(out)), GPG_ERR_NO_ERROR);\n                    ret = component::Digest(out, sizeof(out));\n                }\n                break;\n            case    CF_DIGEST(\"SHAKE256\"):\n                {\n                    /* Same output size as OpenSSL with SHAKE256 by default */\n                    uint8_t out[32];\n                    CF_CHECK_EQ(gcry_md_extract(h.Get(), *digestType, out, sizeof(out)), GPG_ERR_NO_ERROR);\n                    ret = component::Digest(out, sizeof(out));\n                }\n                break;\n            default:\n                {\n                    auto out = gcry_md_read(h.Get(), *digestType);\n                    CF_CHECK_NE(out, nullptr);\n                    ret = component::Digest(out, gcry_md_get_algo_dlen(*digestType));\n                }\n                break;\n        }\n\n        /* noret */ h.WriteRandom();\n    }\n\nend:\n    return ret;\n}\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate HMAC code for module.cpp"}, {"role": "assistant", "content": "std::optional<component::MAC> libgcrypt::OpHMAC(operation::HMAC& op) {\n    int macType = -1;\n\n    static const std::map<uint64_t, int> LUT = {\n        { CF_DIGEST(\"BLAKE2B160\"), GCRY_MAC_HMAC_BLAKE2B_160 },\n        { CF_DIGEST(\"BLAKE2B256\"), GCRY_MAC_HMAC_BLAKE2B_256 },\n        { CF_DIGEST(\"BLAKE2B384\"), GCRY_MAC_HMAC_BLAKE2B_384 },\n        { CF_DIGEST(\"BLAKE2B512\"), GCRY_MAC_HMAC_BLAKE2B_512 },\n        { CF_DIGEST(\"BLAKE2S128\"), GCRY_MAC_HMAC_BLAKE2S_128 },\n        { CF_DIGEST(\"BLAKE2S160\"), GCRY_MAC_HMAC_BLAKE2S_160 },\n        { CF_DIGEST(\"BLAKE2S224\"), GCRY_MAC_HMAC_BLAKE2S_224 },\n        { CF_DIGEST(\"BLAKE2S256\"), GCRY_MAC_HMAC_BLAKE2S_256 },\n        { CF_DIGEST(\"GOST-R-34.11-94\"), GCRY_MAC_HMAC_GOSTR3411_CP },\n        { CF_DIGEST(\"MD4\"), GCRY_MAC_HMAC_MD4 },\n        { CF_DIGEST(\"MD5\"), GCRY_MAC_HMAC_MD5 },\n        { CF_DIGEST(\"RIPEMD160\"), GCRY_MAC_HMAC_RMD160 },\n        { CF_DIGEST(\"SHA1\"), GCRY_MAC_HMAC_SHA1 },\n        { CF_DIGEST(\"SHA224\"), GCRY_MAC_HMAC_SHA224 },\n        { CF_DIGEST(\"SHA256\"), GCRY_MAC_HMAC_SHA256 },\n        { CF_DIGEST(\"SHA3-224\"), GCRY_MAC_HMAC_SHA3_224 },\n        { CF_DIGEST(\"SHA3-256\"), GCRY_MAC_HMAC_SHA3_256 },\n        { CF_DIGEST(\"SHA3-384\"), GCRY_MAC_HMAC_SHA3_384 },\n        { CF_DIGEST(\"SHA3-512\"), GCRY_MAC_HMAC_SHA3_512 },\n        { CF_DIGEST(\"SHA384\"), GCRY_MAC_HMAC_SHA384 },\n        { CF_DIGEST(\"SHA512\"), GCRY_MAC_HMAC_SHA512 },\n        { CF_DIGEST(\"SHA512-224\"), GCRY_MAC_HMAC_SHA512_224 },\n        { CF_DIGEST(\"SHA512-256\"), GCRY_MAC_HMAC_SHA512_256 },\n        { CF_DIGEST(\"SM3\"), GCRY_MAC_HMAC_SM3 },\n        { CF_DIGEST(\"STREEBOG-256\"), GCRY_MAC_HMAC_STRIBOG256 },\n        { CF_DIGEST(\"STREEBOG-512\"), GCRY_MAC_HMAC_STRIBOG512 },\n        { CF_DIGEST(\"TIGER\"), GCRY_MAC_HMAC_TIGER1 },\n        { CF_DIGEST(\"WHIRLPOOL\"), GCRY_MAC_HMAC_WHIRLPOOL },\n    };\n\n    CF_CHECK_NE(LUT.find(op.digestType.Get()), LUT.end());\n    macType = LUT.at(op.digestType.Get());\n\n    {\n        Datasource ds(op.modifier.GetPtr(), op.modifier.GetSize());\n\n        return libgcrypt_detail::MAC(ds, macType, op.cleartext, op.cipher);\n    }\n\nend:\n    return std::nullopt;\n}\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate CMAC code for module.cpp"}, {"role": "assistant", "content": "std::optional<component::MAC> libgcrypt::OpCMAC(operation::CMAC& op) {\n    int macType = -1;\n\n    static const std::map<uint64_t, int> LUT = {\n        { CF_CIPHER(\"AES_128_CBC\"), GCRY_MAC_CMAC_AES },\n        { CF_CIPHER(\"AES_192_CBC\"), GCRY_MAC_CMAC_AES },\n        { CF_CIPHER(\"AES_256_CBC\"), GCRY_MAC_CMAC_AES },\n        { CF_CIPHER(\"ARIA_128_CBC\"), GCRY_MAC_CMAC_ARIA },\n        { CF_CIPHER(\"ARIA_192_CBC\"), GCRY_MAC_CMAC_ARIA },\n        { CF_CIPHER(\"ARIA_256_CBC\"), GCRY_MAC_CMAC_ARIA },\n        { CF_CIPHER(\"BLOWFISH_CBC\"), GCRY_MAC_CMAC_BLOWFISH },\n        { CF_CIPHER(\"CAMELLIA_128_CBC\"), GCRY_MAC_CMAC_CAMELLIA },\n        { CF_CIPHER(\"CAMELLIA_192_CBC\"), GCRY_MAC_CMAC_CAMELLIA },\n        { CF_CIPHER(\"CAMELLIA_256_CBC\"), GCRY_MAC_CMAC_CAMELLIA },\n        { CF_CIPHER(\"CAST5_CBC\"), GCRY_MAC_CMAC_CAST5 },\n        { CF_CIPHER(\"GOST-28147-89\"), GCRY_MAC_CMAC_GOST28147 },\n        { CF_CIPHER(\"GOST-28147-89_CBC\"), GCRY_MAC_CMAC_GOST28147 },\n        { CF_CIPHER(\"IDEA_CBC\"), GCRY_MAC_CMAC_IDEA },\n        { CF_CIPHER(\"RC2_40_CBC\"), GCRY_MAC_CMAC_RFC2268 },\n        { CF_CIPHER(\"RC2_64_CBC\"), GCRY_MAC_CMAC_RFC2268 },\n        { CF_CIPHER(\"RC2_CBC\"), GCRY_MAC_CMAC_RFC2268 },\n        { CF_CIPHER(\"SEED_CBC\"), GCRY_MAC_CMAC_SEED },\n        { CF_CIPHER(\"SERPENT\"), GCRY_MAC_CMAC_SERPENT },\n        { CF_CIPHER(\"SERPENT_CBC\"), GCRY_MAC_CMAC_SERPENT },\n        { CF_CIPHER(\"SM4_CBC\"), GCRY_MAC_CMAC_SM4 },\n        { CF_CIPHER(\"TWOFISH\"), GCRY_MAC_CMAC_TWOFISH },\n        { CF_CIPHER(\"TWOFISH_CBC\"), GCRY_MAC_CMAC_TWOFISH },\n    };\n\n    CF_CHECK_NE(LUT.find(op.cipher.cipherType.Get()), LUT.end());\n    macType = LUT.at(op.cipher.cipherType.Get());\n\n    {\n        Datasource ds(op.modifier.GetPtr(), op.modifier.GetSize());\n\n        return libgcrypt_detail::MAC(ds, macType, op.cleartext, op.cipher);\n    }\n\nend:\n    return std::nullopt;\n}\n\nnamespace libgcrypt_detail {\n    static const std::map<uint64_t, std::pair<int, int>> SymmetricCipherLUT = {\n        { CF_CIPHER(\"AES_128_CBC\"), {GCRY_CIPHER_AES128, GCRY_CIPHER_MODE_CBC} },\n        { CF_CIPHER(\"AES_128_CCM\"), {GCRY_CIPHER_AES128, GCRY_CIPHER_MODE_CCM} },\n        { CF_CIPHER(\"AES_128_CFB\"), {GCRY_CIPHER_AES128, GCRY_CIPHER_MODE_CFB} },\n        { CF_CIPHER(\"AES_128_CTR\"), {GCRY_CIPHER_AES128, GCRY_CIPHER_MODE_CTR} },\n        { CF_CIPHER(\"AES_128_ECB\"), {GCRY_CIPHER_AES128, GCRY_CIPHER_MODE_ECB} },\n        { CF_CIPHER(\"AES_128_GCM\"), {GCRY_CIPHER_AES128, GCRY_CIPHER_MODE_GCM} },\n        { CF_CIPHER(\"AES_128_OFB\"), {GCRY_CIPHER_AES128, GCRY_CIPHER_MODE_OFB} },\n        { CF_CIPHER(\"AES_128_XTS\"), {GCRY_CIPHER_AES128, GCRY_CIPHER_MODE_XTS} },\n        { CF_CIPHER(\"AES_192_CBC\"), {GCRY_CIPHER_AES192, GCRY_CIPHER_MODE_CBC} },\n        { CF_CIPHER(\"AES_192_CCM\"), {GCRY_CIPHER_AES192, GCRY_CIPHER_MODE_CCM} },\n        { CF_CIPHER(\"AES_192_CFB\"), {GCRY_CIPHER_AES192, GCRY_CIPHER_MODE_CFB} },\n        { CF_CIPHER(\"AES_192_CTR\"), {GCRY_CIPHER_AES192, GCRY_CIPHER_MODE_CTR} },\n        { CF_CIPHER(\"AES_192_ECB\"), {GCRY_CIPHER_AES192, GCRY_CIPHER_MODE_ECB} },\n        { CF_CIPHER(\"AES_192_GCM\"), {GCRY_CIPHER_AES192, GCRY_CIPHER_MODE_GCM} },\n        { CF_CIPHER(\"AES_192_OFB\"), {GCRY_CIPHER_AES192, GCRY_CIPHER_MODE_OFB} },\n        { CF_CIPHER(\"AES_256_CBC\"), {GCRY_CIPHER_AES256, GCRY_CIPHER_MODE_CBC} },\n        { CF_CIPHER(\"AES_256_CCM\"), {GCRY_CIPHER_AES256, GCRY_CIPHER_MODE_CCM} },\n        { CF_CIPHER(\"AES_256_CFB\"), {GCRY_CIPHER_AES256, GCRY_CIPHER_MODE_CFB} },\n        { CF_CIPHER(\"AES_256_CTR\"), {GCRY_CIPHER_AES256, GCRY_CIPHER_MODE_CTR} },\n        { CF_CIPHER(\"AES_256_ECB\"), {GCRY_CIPHER_AES256, GCRY_CIPHER_MODE_ECB} },\n        { CF_CIPHER(\"AES_256_GCM\"), {GCRY_CIPHER_AES256, GCRY_CIPHER_MODE_GCM} },\n        { CF_CIPHER(\"AES_256_OFB\"), {GCRY_CIPHER_AES256, GCRY_CIPHER_MODE_OFB} },\n        { CF_CIPHER(\"AES_256_XTS\"), {GCRY_CIPHER_AES128, GCRY_CIPHER_MODE_XTS} },\n        { CF_CIPHER(\"ARIA_128_CBC\"), {GCRY_CIPHER_ARIA128, GCRY_CIPHER_MODE_CBC} },\n        { CF_CIPHER(\"ARIA_128_CCM\"), {GCRY_CIPHER_ARIA128, GCRY_CIPHER_MODE_CCM} },\n        { CF_CIPHER(\"ARIA_128_CFB\"), {GCRY_CIPHER_ARIA128, GCRY_CIPHER_MODE_CFB} },\n        { CF_CIPHER(\"ARIA_128_CTR\"), {GCRY_CIPHER_ARIA128, GCRY_CIPHER_MODE_CTR} },\n        { CF_CIPHER(\"ARIA_128_ECB\"), {GCRY_CIPHER_ARIA128, GCRY_CIPHER_MODE_ECB} },\n        { CF_CIPHER(\"ARIA_128_GCM\"), {GCRY_CIPHER_ARIA128, GCRY_CIPHER_MODE_GCM} },\n        { CF_CIPHER(\"ARIA_128_OFB\"), {GCRY_CIPHER_ARIA128, GCRY_CIPHER_MODE_OFB} },\n        { CF_CIPHER(\"ARIA_192_CBC\"), {GCRY_CIPHER_ARIA192, GCRY_CIPHER_MODE_CBC} },\n        { CF_CIPHER(\"ARIA_192_CCM\"), {GCRY_CIPHER_ARIA192, GCRY_CIPHER_MODE_CCM} },\n        { CF_CIPHER(\"ARIA_192_CFB\"), {GCRY_CIPHER_ARIA192, GCRY_CIPHER_MODE_CFB} },\n        { CF_CIPHER(\"ARIA_192_CTR\"), {GCRY_CIPHER_ARIA192, GCRY_CIPHER_MODE_CTR} },\n        { CF_CIPHER(\"ARIA_192_ECB\"), {GCRY_CIPHER_ARIA192, GCRY_CIPHER_MODE_ECB} },\n        { CF_CIPHER(\"ARIA_192_GCM\"), {GCRY_CIPHER_ARIA192, GCRY_CIPHER_MODE_GCM} },\n        { CF_CIPHER(\"ARIA_192_OFB\"), {GCRY_CIPHER_ARIA192, GCRY_CIPHER_MODE_OFB} },\n        { CF_CIPHER(\"ARIA_256_CBC\"), {GCRY_CIPHER_ARIA256, GCRY_CIPHER_MODE_CBC} },\n        { CF_CIPHER(\"ARIA_256_CCM\"), {GCRY_CIPHER_ARIA256, GCRY_CIPHER_MODE_CCM} },\n        { CF_CIPHER(\"ARIA_256_CFB\"), {GCRY_CIPHER_ARIA256, GCRY_CIPHER_MODE_CFB} },\n        { CF_CIPHER(\"ARIA_256_CTR\"), {GCRY_CIPHER_ARIA256, GCRY_CIPHER_MODE_CTR} },\n        { CF_CIPHER(\"ARIA_256_ECB\"), {GCRY_CIPHER_ARIA256, GCRY_CIPHER_MODE_ECB} },\n        { CF_CIPHER(\"ARIA_256_GCM\"), {GCRY_CIPHER_ARIA256, GCRY_CIPHER_MODE_GCM} },\n        { CF_CIPHER(\"ARIA_256_OFB\"), {GCRY_CIPHER_ARIA256, GCRY_CIPHER_MODE_OFB} },\n        { CF_CIPHER(\"BF_CBC\"), {GCRY_CIPHER_BLOWFISH, GCRY_CIPHER_MODE_CBC} },\n        { CF_CIPHER(\"BF_CFB\"), {GCRY_CIPHER_BLOWFISH, GCRY_CIPHER_MODE_CFB} },\n        { CF_CIPHER(\"BF_ECB\"), {GCRY_CIPHER_BLOWFISH, GCRY_CIPHER_MODE_ECB} },\n        { CF_CIPHER(\"BF_OFB\"), {GCRY_CIPHER_BLOWFISH, GCRY_CIPHER_MODE_OFB} },\n        { CF_CIPHER(\"CAMELLIA_128_CBC\"), {GCRY_CIPHER_CAMELLIA128, GCRY_CIPHER_MODE_CBC} },\n        { CF_CIPHER(\"CAMELLIA_128_CFB\"), {GCRY_CIPHER_CAMELLIA128, GCRY_CIPHER_MODE_CFB} },\n        { CF_CIPHER(\"CAMELLIA_128_CTR\"), {GCRY_CIPHER_CAMELLIA128, GCRY_CIPHER_MODE_CTR} },\n        { CF_CIPHER(\"CAMELLIA_128_ECB\"), {GCRY_CIPHER_CAMELLIA128, GCRY_CIPHER_MODE_ECB} },\n        { CF_CIPHER(\"CAMELLIA_128_OFB\"), {GCRY_CIPHER_CAMELLIA128, GCRY_CIPHER_MODE_OFB} },\n        { CF_CIPHER(\"CAMELLIA_192_CBC\"), {GCRY_CIPHER_CAMELLIA192, GCRY_CIPHER_MODE_CBC} },\n        { CF_CIPHER(\"CAMELLIA_192_CFB\"), {GCRY_CIPHER_CAMELLIA192, GCRY_CIPHER_MODE_CFB} },\n        { CF_CIPHER(\"CAMELLIA_192_CTR\"), {GCRY_CIPHER_CAMELLIA192, GCRY_CIPHER_MODE_CTR} },\n        { CF_CIPHER(\"CAMELLIA_192_ECB\"), {GCRY_CIPHER_CAMELLIA192, GCRY_CIPHER_MODE_ECB} },\n        { CF_CIPHER(\"CAMELLIA_192_OFB\"), {GCRY_CIPHER_CAMELLIA192, GCRY_CIPHER_MODE_OFB} },\n        { CF_CIPHER(\"CAMELLIA_256_CBC\"), {GCRY_CIPHER_CAMELLIA256, GCRY_CIPHER_MODE_CBC} },\n        { CF_CIPHER(\"CAMELLIA_256_CFB\"), {GCRY_CIPHER_CAMELLIA256, GCRY_CIPHER_MODE_CFB} },\n        { CF_CIPHER(\"CAMELLIA_256_CTR\"), {GCRY_CIPHER_CAMELLIA256, GCRY_CIPHER_MODE_CTR} },\n        { CF_CIPHER(\"CAMELLIA_256_ECB\"), {GCRY_CIPHER_CAMELLIA256, GCRY_CIPHER_MODE_ECB} },\n        { CF_CIPHER(\"CAMELLIA_256_OFB\"), {GCRY_CIPHER_CAMELLIA256, GCRY_CIPHER_MODE_OFB} },\n        { CF_CIPHER(\"CAST5_CBC\"), {GCRY_CIPHER_CAST5, GCRY_CIPHER_MODE_CBC} },\n        { CF_CIPHER(\"CAST5_CFB\"), {GCRY_CIPHER_CAST5, GCRY_CIPHER_MODE_CFB} },\n        { CF_CIPHER(\"CAST5_ECB\"), {GCRY_CIPHER_CAST5, GCRY_CIPHER_MODE_ECB} },\n        { CF_CIPHER(\"CAST5_OFB\"), {GCRY_CIPHER_CAST5, GCRY_CIPHER_MODE_OFB} },\n        { CF_CIPHER(\"CHACHA20\"), {GCRY_CIPHER_CHACHA20, GCRY_CIPHER_MODE_STREAM} },\n        { CF_CIPHER(\"DES_CBC\"), {GCRY_CIPHER_DES, GCRY_CIPHER_MODE_CBC} },\n        { CF_CIPHER(\"DES_CFB\"), {GCRY_CIPHER_DES, GCRY_CIPHER_MODE_CFB} },\n        { CF_CIPHER(\"DES_ECB\"), {GCRY_CIPHER_DES, GCRY_CIPHER_MODE_ECB} },\n        { CF_CIPHER(\"DES_EDE3_CFB\"), {GCRY_CIPHER_3DES, GCRY_CIPHER_MODE_CFB} },\n        { CF_CIPHER(\"DES_EDE3_OFB\"), {GCRY_CIPHER_3DES, GCRY_CIPHER_MODE_OFB} },\n        { CF_CIPHER(\"DES_OFB\"), {GCRY_CIPHER_DES, GCRY_CIPHER_MODE_OFB} },\n        { CF_CIPHER(\"IDEA_CBC\"), {GCRY_CIPHER_IDEA, GCRY_CIPHER_MODE_CBC} },\n        { CF_CIPHER(\"IDEA_CFB\"), {GCRY_CIPHER_IDEA, GCRY_CIPHER_MODE_CFB} },\n        { CF_CIPHER(\"IDEA_ECB\"), {GCRY_CIPHER_IDEA, GCRY_CIPHER_MODE_ECB} },\n        { CF_CIPHER(\"IDEA_OFB\"), {GCRY_CIPHER_IDEA, GCRY_CIPHER_MODE_OFB} },\n        { CF_CIPHER(\"RC2_CFB\"), {GCRY_CIPHER_RFC2268_128, GCRY_CIPHER_MODE_CFB} },\n        { CF_CIPHER(\"RC2_ECB\"), {GCRY_CIPHER_RFC2268_128, GCRY_CIPHER_MODE_ECB} },\n        { CF_CIPHER(\"RC2_OFB\"), {GCRY_CIPHER_RFC2268_128, GCRY_CIPHER_MODE_OFB} },\n        { CF_CIPHER(\"SEED_CFB\"), {GCRY_CIPHER_SEED, GCRY_CIPHER_MODE_CFB} },\n        { CF_CIPHER(\"SEED_ECB\"), {GCRY_CIPHER_SEED, GCRY_CIPHER_MODE_ECB} },\n        { CF_CIPHER(\"SEED_OFB\"), {GCRY_CIPHER_SEED, GCRY_CIPHER_MODE_OFB} },\n        { CF_CIPHER(\"SM4_CFB\"), {GCRY_CIPHER_SM4, GCRY_CIPHER_MODE_CFB} },\n        { CF_CIPHER(\"SM4_ECB\"), {GCRY_CIPHER_SM4, GCRY_CIPHER_MODE_ECB} },\n        { CF_CIPHER(\"SM4_OFB\"), {GCRY_CIPHER_SM4, GCRY_CIPHER_MODE_OFB} },\n    };\n\n    std::optional<size_t> Blocksize(const uint64_t cipher) {\n        std::optional<size_t> ret = std::nullopt;\n\n        switch ( cipher ) {\n            case    CF_CIPHER(\"AES_128_CBC\"):\n            case    CF_CIPHER(\"AES_192_CBC\"):\n            case    CF_CIPHER(\"AES_256_CBC\"):\n            case    CF_CIPHER(\"CAMELLIA_128_CBC\"):\n            case    CF_CIPHER(\"CAMELLIA_192_CBC\"):\n            case    CF_CIPHER(\"CAMELLIA_256_CBC\"):\n                ret = 16;\n                break;\n            case    CF_CIPHER(\"BF_CBC\"):\n            case    CF_CIPHER(\"CAST5_CBC\"):\n            case    CF_CIPHER(\"DES_CBC\"):\n            case    CF_CIPHER(\"IDEA_CBC\"):\n                ret = 8;\n                break;\n        }\n\n        return ret;\n    }\n\n    class Crypt {\n        private:\n\n        Datasource ds;\n        uint8_t* out = nullptr;\n        bool hOpen = false;\n        gcry_cipher_hd_t h;\n        util::Multipart parts;\n        size_t outputBufferSize;\n\n        bool initialize(const component::SymmetricCipher& cipher, const uint8_t* input, const size_t inputSize) {\n            bool ret = false;\n            {\n                CF_CHECK_NE(outputBufferSize, 0);\n                CF_CHECK_NE(SymmetricCipherLUT.find(cipher.cipherType.Get()), SymmetricCipherLUT.end());\n\n                /* CFB is broken */\n                //CF_CHECK_EQ(repository::IsCFB(cipher.cipherType.Get()), false);\n\n                const auto cipherModePair = SymmetricCipherLUT.at(cipher.cipherType.Get());\n\n                CF_CHECK_EQ(gcry_cipher_get_algo_keylen(cipherModePair.first), cipher.key.GetSize());\n                if ( cipher.cipherType.Get() == CF_CIPHER(\"CHACHA20\") ) {\n                    CF_CHECK_EQ(12, cipher.iv.GetSize());\n                } else {\n                    CF_CHECK_EQ(gcry_cipher_get_algo_blklen(cipherModePair.first), cipher.iv.GetSize());\n                }\n\n                bool useSecMem = false;\n                try {\n                    useSecMem = ds.Get<bool>();\n                } catch ( fuzzing::datasource::Datasource::OutOfData ) { }\n\n                CF_CHECK_EQ(gcry_cipher_open(&h, cipherModePair.first, cipherModePair.second, useSecMem ? GCRY_CIPHER_SECURE : 0), GPG_ERR_NO_ERROR);\n                hOpen = true;\n\n                CF_CHECK_EQ(gcry_cipher_setkey(h, cipher.key.GetPtr(&ds), cipher.key.GetSize()), GPG_ERR_NO_ERROR);\n                if ( cipher.cipherType.Get() == CF_CIPHER(\"CHACHA20\") ) {\n                    CF_CHECK_EQ(gcry_cipher_setiv(h, cipher.iv.GetPtr(&ds), cipher.iv.GetSize()), GPG_ERR_NO_ERROR);\n                } else if ( repository::IsCTR(cipher.cipherType.Get()) ) {\n                    CF_CHECK_EQ(gcry_cipher_setctr(h, cipher.iv.GetPtr(&ds), cipher.iv.GetSize()), GPG_ERR_NO_ERROR);\n                } else {\n                    CF_CHECK_EQ(gcry_cipher_setiv(h, cipher.iv.GetPtr(&ds), cipher.iv.GetSize()), GPG_ERR_NO_ERROR);\n                }\n\n                switch ( cipherModePair.second ) {\n                    case GCRY_CIPHER_MODE_STREAM:\n                    //case GCRY_CIPHER_MODE_OFB:\n                    case GCRY_CIPHER_MODE_CTR:\n                    case GCRY_CIPHER_MODE_CFB:\n                    case GCRY_CIPHER_MODE_CCM:\n                    case GCRY_CIPHER_MODE_GCM:\n                    case GCRY_CIPHER_MODE_EAX:\n                    case GCRY_CIPHER_MODE_POLY1305:\n                        parts = util::CipherInputTransform(ds, cipher.cipherType, out, outputBufferSize, input, inputSize);\n                        break;\n                    default:\n                        parts = { {input, inputSize} };\n                }\n            }\n\n            ret = true;\n        end:\n            return ret;\n        }\n\n        template <bool Encrypt>\n        std::optional<size_t> process(void) {\n            std::optional<size_t> ret = std::nullopt;\n            size_t outIdx = 0;\n            size_t partNum = 0;\n\n            for (const auto& part : parts) {\n                if ( part.second == 0 ) {\n                    continue;\n                }\n                CF_CHECK_GTE(outputBufferSize - outIdx, part.second);\n\n                partNum++;\n                if ( partNum == parts.size() ) {\n                    CF_CHECK_EQ(gcry_cipher_final(h), GPG_ERR_NO_ERROR);\n                }\n\n                if ( Encrypt == true ) {\n                    CF_CHECK_EQ(gcry_cipher_encrypt(h, out + outIdx, outputBufferSize - outIdx, part.first, part.second), GPG_ERR_NO_ERROR);\n                } else {\n                    CF_CHECK_EQ(gcry_cipher_decrypt(h, out + outIdx, outputBufferSize - outIdx, part.first, part.second), GPG_ERR_NO_ERROR);\n                }\n                outIdx += part.second;\n            }\n\n            ret = outIdx;\n\n        end:\n            return ret;\n        }\n\n        public:\n\n        Crypt(operation::SymmetricEncrypt& op) :\n            ds(op.modifier.GetPtr(), op.modifier.GetSize()),\n            out(util::malloc(op.ciphertextSize)),\n            outputBufferSize(op.ciphertextSize)\n        { }\n\n        Crypt(operation::SymmetricDecrypt& op) :\n            ds(op.modifier.GetPtr(), op.modifier.GetSize()),\n            out(util::malloc(op.cleartextSize)),\n            outputBufferSize(op.cleartextSize)\n        { }\n\n        ~Crypt() {\n            if ( hOpen == true ) {\n                gcry_cipher_close(h);\n            }\n            if ( out != nullptr ) {\n                util::free(out);\n            }\n        }\n\n        std::optional<component::Ciphertext> Encrypt(operation::SymmetricEncrypt& op) {\n            std::optional<component::Ciphertext> ret = std::nullopt;\n\n            {\n                /* AEAD currently not supported */\n                CF_CHECK_EQ(op.tagSize, std::nullopt);\n                CF_CHECK_EQ(op.aad, std::nullopt);\n\n                std::vector<uint8_t> cleartext = op.cleartext.Get();\n                if ( repository::IsCBC(op.cipher.cipherType.Get()) ) {\n                    auto blockSize = Blocksize(op.cipher.cipherType.Get());\n                    CF_CHECK_NE(blockSize, std::nullopt);\n\n                    cleartext = util::Pkcs7Pad(op.cleartext.Get(), *blockSize);\n                }\n                CF_CHECK_EQ(initialize(op.cipher, cleartext.data(), cleartext.size()), true);\n                std::optional<size_t> outputSize = process<true>();\n                CF_CHECK_NE(outputSize, std::nullopt);\n\n                ret = component::Ciphertext(Buffer(out, *outputSize));\n            }\n        end:\n            return ret;\n        }\n\n        std::optional<component::Cleartext> Decrypt(operation::SymmetricDecrypt& op) {\n            std::optional<component::Cleartext> ret = std::nullopt;\n\n            {\n                /* AEAD currently not supported */\n                CF_CHECK_EQ(op.tag, std::nullopt);\n                CF_CHECK_EQ(op.aad, std::nullopt);\n\n                CF_CHECK_EQ(initialize(op.cipher, op.ciphertext.GetPtr(&ds), op.ciphertext.GetSize()), true);\n                std::optional<size_t> outputSize = process<false>();\n                CF_CHECK_NE(outputSize, std::nullopt);\n\n                if ( repository::IsCBC(op.cipher.cipherType.Get()) ) {\n                    auto blockSize = Blocksize(op.cipher.cipherType.Get());\n                    CF_CHECK_NE(blockSize, std::nullopt);\n\n                    const auto unpaddedCleartext = util::Pkcs7Unpad( std::vector<uint8_t>(out, out + *outputSize), *blockSize);\n                    CF_CHECK_NE(unpaddedCleartext, std::nullopt);\n\n                    ret = component::Cleartext(Buffer(*unpaddedCleartext));\n                } else {\n                    ret = component::Cleartext(out, *outputSize);\n                }\n            }\n        end:\n            return ret;\n        }\n\n    };\n} /* namespace libgcrypt_detail */\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate SymmetricEncrypt code for module.cpp"}, {"role": "assistant", "content": "std::optional<component::Ciphertext> libgcrypt::OpSymmetricEncrypt(operation::SymmetricEncrypt& op) {\n    libgcrypt_detail::Crypt crypt(op);\n    return crypt.Encrypt(op);\n}\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate SymmetricDecrypt code for module.cpp"}, {"role": "assistant", "content": "std::optional<component::Cleartext> libgcrypt::OpSymmetricDecrypt(operation::SymmetricDecrypt& op) {\n    libgcrypt_detail::Crypt crypt(op);\n    return crypt.Decrypt(op);\n}\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_HKDF code for module.cpp"}, {"role": "assistant", "content": "std::optional<component::Key> libgcrypt::OpKDF_HKDF(operation::KDF_HKDF& op) {\n    std::optional<component::Key> ret = std::nullopt;\n    Datasource ds(op.modifier.GetPtr(), op.modifier.GetSize());\n\n    gcry_kdf_hd_t hd = {0};\n    unsigned long param[1];\n    const size_t outSize = op.keySize;\n    uint8_t* out = util::malloc(outSize);\n    int macType = -1;\n    bool initialized = false;\n\n    static const std::map<uint64_t, int> LUT = {\n        { CF_DIGEST(\"BLAKE2B160\"), GCRY_MAC_HMAC_BLAKE2B_160 },\n        { CF_DIGEST(\"BLAKE2B256\"), GCRY_MAC_HMAC_BLAKE2B_256 },\n        { CF_DIGEST(\"BLAKE2B384\"), GCRY_MAC_HMAC_BLAKE2B_384 },\n        { CF_DIGEST(\"BLAKE2B512\"), GCRY_MAC_HMAC_BLAKE2B_512 },\n        { CF_DIGEST(\"BLAKE2S128\"), GCRY_MAC_HMAC_BLAKE2S_128 },\n        { CF_DIGEST(\"BLAKE2S160\"), GCRY_MAC_HMAC_BLAKE2S_160 },\n        { CF_DIGEST(\"BLAKE2S224\"), GCRY_MAC_HMAC_BLAKE2S_224 },\n        { CF_DIGEST(\"BLAKE2S256\"), GCRY_MAC_HMAC_BLAKE2S_256 },\n        { CF_DIGEST(\"GOST-R-34.11-94\"), GCRY_MAC_HMAC_GOSTR3411_CP },\n        { CF_DIGEST(\"MD4\"), GCRY_MAC_HMAC_MD4 },\n        { CF_DIGEST(\"MD5\"), GCRY_MAC_HMAC_MD5 },\n        { CF_DIGEST(\"RIPEMD160\"), GCRY_MAC_HMAC_RMD160 },\n        { CF_DIGEST(\"SHA1\"), GCRY_MAC_HMAC_SHA1 },\n        { CF_DIGEST(\"SHA224\"), GCRY_MAC_HMAC_SHA224 },\n        { CF_DIGEST(\"SHA256\"), GCRY_MAC_HMAC_SHA256 },\n        { CF_DIGEST(\"SHA3-224\"), GCRY_MAC_HMAC_SHA3_224 },\n        { CF_DIGEST(\"SHA3-256\"), GCRY_MAC_HMAC_SHA3_256 },\n        { CF_DIGEST(\"SHA3-384\"), GCRY_MAC_HMAC_SHA3_384 },\n        { CF_DIGEST(\"SHA3-512\"), GCRY_MAC_HMAC_SHA3_512 },\n        { CF_DIGEST(\"SHA384\"), GCRY_MAC_HMAC_SHA384 },\n        { CF_DIGEST(\"SHA512\"), GCRY_MAC_HMAC_SHA512 },\n        { CF_DIGEST(\"SHA512-224\"), GCRY_MAC_HMAC_SHA512_224 },\n        { CF_DIGEST(\"SHA512-256\"), GCRY_MAC_HMAC_SHA512_256 },\n        { CF_DIGEST(\"SM3\"), GCRY_MAC_HMAC_SM3 },\n        { CF_DIGEST(\"STREEBOG-256\"), GCRY_MAC_HMAC_STRIBOG256 },\n        { CF_DIGEST(\"STREEBOG-512\"), GCRY_MAC_HMAC_STRIBOG512 },\n        { CF_DIGEST(\"TIGER\"), GCRY_MAC_HMAC_TIGER1 },\n        { CF_DIGEST(\"WHIRLPOOL\"), GCRY_MAC_HMAC_WHIRLPOOL },\n    };\n\n    CF_CHECK_NE(LUT.find(op.digestType.Get()), LUT.end());\n    macType = LUT.at(op.digestType.Get());\n\n    param[0] = outSize;\n\n    CF_CHECK_EQ(gcry_kdf_open(\n                &hd,\n                GCRY_KDF_HKDF,\n                macType,\n                param,\n                1,\n                op.password.GetPtr(&ds),\n                op.password.GetSize(),\n                nullptr, 0,\n                op.salt.GetPtr(&ds),\n                op.salt.GetSize(),\n                op.info.GetPtr(&ds),\n                op.info.GetSize()), GPG_ERR_NO_ERROR);\n    initialized = true;\n\n    CF_CHECK_EQ(gcry_kdf_compute(hd, nullptr), GPG_ERR_NO_ERROR);\n    CF_CHECK_EQ(gcry_kdf_final(hd, outSize, out), GPG_ERR_NO_ERROR);\n\n    ret = component::Key(out, outSize);\n\nend:\n    util::free(out);\n\n    if ( initialized == true ) {\n        gcry_kdf_close(hd);\n    }\n\n    return ret;\n}\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_SCRYPT code for module.cpp"}, {"role": "assistant", "content": "std::optional<component::Key> libgcrypt::OpKDF_SCRYPT(operation::KDF_SCRYPT& op) {\n    std::optional<component::Key> ret = std::nullopt;\n    Datasource ds(op.modifier.GetPtr(), op.modifier.GetSize());\n\n    const size_t outSize = op.keySize;\n    uint8_t* out = util::malloc(outSize);\n\n    /* Block size fixed at 8 */\n    CF_CHECK_EQ(op.r, 8);\n\n    CF_CHECK_EQ(gcry_kdf_derive(\n                op.password.GetPtr(&ds),\n                op.password.GetSize(),\n                GCRY_KDF_SCRYPT,\n                op.N,\n                op.salt.GetPtr(&ds),\n                op.salt.GetSize(),\n                op.p,\n                outSize,\n                out), GPG_ERR_NO_ERROR);\n\n    ret = component::Key(out, outSize);\n\nend:\n    util::free(out);\n\n    return ret;\n}\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_PBKDF2 code for module.cpp"}, {"role": "assistant", "content": "std::optional<component::Key> libgcrypt::OpKDF_PBKDF2(operation::KDF_PBKDF2& op) {\n    std::optional<component::Key> ret = std::nullopt;\n\n    if ( op.digestType.Is(CF_DIGEST(\"SHAKE128\")) ) {\n        return ret;\n    }\n    if ( op.digestType.Is(CF_DIGEST(\"SHAKE256\")) ) {\n        return ret;\n    }\n\n    Datasource ds(op.modifier.GetPtr(), op.modifier.GetSize());\n\n\n    const size_t outSize = op.keySize;\n    uint8_t* out = util::malloc(outSize);\n\n    std::optional<int> digestType = std::nullopt;\n    CF_CHECK_NE(digestType = libgcrypt_detail::DigestIDToID(op.digestType.Get()), std::nullopt);\n    CF_CHECK_EQ(gcry_kdf_derive(\n                op.password.GetPtr(&ds),\n                op.password.GetSize(),\n                GCRY_KDF_PBKDF2,\n                *digestType,\n                op.salt.GetPtr(&ds),\n                op.salt.GetSize(),\n                op.iterations,\n                outSize,\n                out), GPG_ERR_NO_ERROR);\n\n    ret = component::Key(out, outSize);\n\nend:\n    util::free(out);\n\n    return ret;\n}\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_ARGON2 code for module.cpp"}, {"role": "assistant", "content": "std::optional<component::Key> libgcrypt::OpKDF_ARGON2(operation::KDF_ARGON2& op) {\n    std::optional<component::Key> ret = std::nullopt;\n    Datasource ds(op.modifier.GetPtr(), op.modifier.GetSize());\n\n    bool initialized = false;\n    const size_t outSize = op.keySize;\n    uint8_t* out = nullptr;\n\n    gcry_kdf_hd_t hd;\n    int subalgo;\n    unsigned long params[4];\n\n    switch ( op.type ) {\n        case    0:\n            subalgo = GCRY_KDF_ARGON2D;\n            break;\n        case    1:\n            subalgo = GCRY_KDF_ARGON2I;\n            break;\n        case    2:\n            subalgo = GCRY_KDF_ARGON2ID;\n            break;\n        default:\n            return std::nullopt;\n    }\n\n    params[0] = outSize;\n    params[1] = op.iterations;\n    params[2] = op.memory;\n    params[3] = op.threads;\n\n    out = util::malloc(outSize);\n\n    CF_CHECK_EQ(gcry_kdf_open(&hd, GCRY_KDF_ARGON2, subalgo, params, 4,\n                op.password.GetPtr(&ds), op.password.GetSize(),\n                op.salt.GetPtr(&ds), op.salt.GetSize(),\n                nullptr, 0,\n                nullptr, 0), GPG_ERR_NO_ERROR);\n    initialized = true;\n\n    CF_CHECK_EQ(gcry_kdf_compute(hd, nullptr), GPG_ERR_NO_ERROR);\n    CF_CHECK_EQ(gcry_kdf_final(hd, outSize, out), GPG_ERR_NO_ERROR);\n\n    ret = component::Key(out, outSize);\n\nend:\n    util::free(out);\n    if ( initialized ) {\n        CF_NORET(gcry_kdf_close(hd));\n    }\n\n    return ret;\n}\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_X963 code for module.cpp"}, {"role": "assistant", "content": "std::optional<component::Key> libgcrypt::OpKDF_X963(operation::KDF_X963& op) {\n    std::optional<component::Key> ret = std::nullopt;\n    Datasource ds(op.modifier.GetPtr(), op.modifier.GetSize());\n\n    gcry_kdf_hd_t hd = {0};\n    unsigned long param[1];\n    const size_t outSize = op.keySize;\n    uint8_t* out = util::malloc(outSize);\n    bool initialized = false;\n\n    std::optional<int> digestType = std::nullopt;\n    CF_CHECK_FALSE(op.digestType.Is(CF_DIGEST(\"SHAKE128\")));\n    CF_CHECK_FALSE(op.digestType.Is(CF_DIGEST(\"SHAKE256\")));\n    CF_CHECK_NE(digestType = libgcrypt_detail::DigestIDToID(op.digestType.Get()), std::nullopt);\n\n    param[0] = outSize;\n\n    CF_CHECK_EQ(gcry_kdf_open(\n                &hd,\n                GCRY_KDF_X963_KDF,\n                *digestType,\n                param,\n                1,\n                op.secret.GetPtr(&ds),\n                op.secret.GetSize(),\n                nullptr, 0,\n                nullptr, 0,\n                op.info.GetPtr(&ds),\n                op.info.GetSize()), GPG_ERR_NO_ERROR);\n    initialized = true;\n\n    CF_CHECK_EQ(gcry_kdf_compute(hd, nullptr), GPG_ERR_NO_ERROR);\n    CF_CHECK_EQ(gcry_kdf_final(hd, outSize, out), GPG_ERR_NO_ERROR);\n\n    ret = component::Key(out, outSize);\n\nend:\n    util::free(out);\n\n    if ( initialized == true ) {\n        gcry_kdf_close(hd);\n    }\n\n    return ret;\n}\n\nnamespace libgcrypt_detail {\n    std::optional<std::string> toCurveString(const component::CurveType& curveType) {\n        static const std::map<uint64_t, std::string> LUT = {\n            { CF_ECC_CURVE(\"gost_256A\"), \"GOST2012-256-tc26-A\" },\n            { CF_ECC_CURVE(\"gost_512A\"), \"GOST2012-512-tc26-A\" },\n            { CF_ECC_CURVE(\"brainpool160r1\"), \"brainpoolP160r1\" },\n            { CF_ECC_CURVE(\"brainpool192r1\"), \"brainpoolP192r1\" },\n            { CF_ECC_CURVE(\"brainpool224r1\"), \"brainpoolP224r1\" },\n            { CF_ECC_CURVE(\"brainpool256r1\"), \"brainpoolP256r1\" },\n            { CF_ECC_CURVE(\"brainpool320r1\"), \"brainpoolP320r1\" },\n            { CF_ECC_CURVE(\"brainpool384r1\"), \"brainpoolP384r1\" },\n            { CF_ECC_CURVE(\"brainpool512r1\"), \"brainpoolP512r1\" },\n            { CF_ECC_CURVE(\"secp192r1\"), \"NIST P-192\" },\n            { CF_ECC_CURVE(\"secp224r1\"), \"NIST P-224\" },\n            { CF_ECC_CURVE(\"secp256r1\"), \"NIST P-256\" },\n            { CF_ECC_CURVE(\"secp384r1\"), \"NIST P-384\" },\n            { CF_ECC_CURVE(\"secp521r1\"), \"NIST P-521\" },\n            { CF_ECC_CURVE(\"secp256k1\"), \"secp256k1\" },\n            { CF_ECC_CURVE(\"sm2p256v1\"), \"sm2p256v1\" },\n        };\n\n        if ( LUT.find(curveType.Get()) == LUT.end() ) {\n            return std::nullopt;\n        }\n\n        return LUT.at(curveType.Get());\n    }\n\n    static gcry_mpi_point_t SetPoint(\n            Datasource& ds,\n            gcry_ctx_t ctx,\n            const component::ECC_Point& point,\n            const component::CurveType& curveType,\n            const bool curveCheck = true) {\n        gcry_mpi_point_t P;\n        CF_ASSERT( (P = gcry_mpi_point_new(0)) != nullptr, \"Cannot create point\");\n\n        libgcrypt_bignum::Bignum x, y, z;\n\n        bool projective = false;\n        try {\n            projective = ds.Get<bool>();\n        } catch ( fuzzing::datasource::Datasource::OutOfData ) { }\n\n        if ( projective == true ) {\n            const auto proj = util::ToRandomProjective(\n                    ds,\n                    point.first.ToTrimmedString(),\n                    point.second.ToTrimmedString(),\n                    curveType.Get(),\n                    true,\n                    true);\n            CF_CHECK_EQ(x.Set(proj[0]), true);\n            CF_CHECK_EQ(y.Set(proj[1]), true);\n            CF_CHECK_EQ(z.Set(proj[2]), true);\n        } else {\n            CF_CHECK_EQ(x.Set(point.first.ToString(ds)), true);\n            CF_CHECK_EQ(y.Set(point.second.ToString(ds)), true);\n            CF_CHECK_EQ(z.Set(\"1\"), true);\n        }\n\n        gcry_mpi_point_set(P, x.GetPtr(), y.GetPtr(), z.GetPtr());\n\n        if ( curveCheck == true ) {\n            CF_CHECK_EQ(gcry_mpi_ec_curve_point(P, ctx), 1);\n        }\n\n        return P;\nend:\n        gcry_mpi_point_release(P);\n        return nullptr;\n    }\n\n    static void FreePoint(gcry_mpi_point_t P) {\n        gcry_mpi_point_release(P);\n    }\n\n    static std::optional<component::ECC_Point> GetPoint(\n            gcry_ctx_t ctx,\n            gcry_mpi_point_t P) {\n        std::optional<component::ECC_PublicKey> ret = std::nullopt;\n\n        libgcrypt_bignum::Bignum x, y;\n        std::optional<std::string> x_str, y_str;\n\n        CF_CHECK_EQ(x.Set(\"0\"), true);\n        CF_CHECK_EQ(y.Set(\"0\"), true);\n\n        CF_CHECK_EQ(gcry_mpi_ec_get_affine(x.GetPtr(), y.GetPtr(), P, ctx), 0);\n\n        CF_CHECK_NE(x_str = x.ToString(), std::nullopt);\n        CF_CHECK_NE(y_str = y.ToString(), std::nullopt);\n\n        ret = { *x_str, *y_str };\nend:\n        return ret;\n    }\n\n\n    std::optional<component::ECC_PublicKey> ECC_PrivateToPublic(\n            Datasource& ds,\n            const component::CurveType curveType,\n            const component::ECC_PrivateKey _priv) {\n        std::optional<component::ECC_PublicKey> ret = std::nullopt;\n\n        std::optional<std::string> curveStr = std::nullopt;\n\n        gcry_ctx_t ctx = nullptr;\n        gcry_mpi_point_t Q = nullptr;\n        gcry_mpi_point_t G = nullptr;\n\n        libgcrypt_bignum::Bignum priv;\n        libgcrypt_bignum::Bignum x;\n        libgcrypt_bignum::Bignum y;\n        CF_CHECK_EQ(priv.Set(_priv.ToString(ds)), true);\n        CF_CHECK_EQ(x.Set(\"0\"), true);\n        CF_CHECK_EQ(y.Set(\"0\"), true);\n\n        /* Initialize */\n        {\n            CF_CHECK_NE(curveStr = libgcrypt_detail::toCurveString(curveType), std::nullopt);\n            CF_CHECK_EQ(gcry_mpi_ec_new(&ctx, nullptr, curveStr->c_str()), 0);\n        }\n\n        /* Process */\n        {\n            CF_CHECK_NE(G = gcry_mpi_ec_get_point(\"g\", ctx, 1), nullptr);\n            CF_CHECK_NE(Q = gcry_mpi_point_new(0), nullptr);\n            /* noret */ gcry_mpi_ec_mul(Q, priv.GetPtr(), G, ctx);\n        }\n\n        /* Finalize */\n        {\n            CF_CHECK_EQ(gcry_mpi_ec_get_affine(x.GetPtr(), y.GetPtr(), Q, ctx), 0);\n\n            std::optional<std::string> x_str;\n            std::optional<std::string> y_str;\n\n            CF_CHECK_NE(x_str = x.ToString(), std::nullopt);\n            CF_CHECK_NE(y_str = y.ToString(), std::nullopt);\n\n            ret = { *x_str, *y_str };\n        }\n\nend:\n        gcry_ctx_release(ctx);\n        gcry_mpi_point_release(Q);\n        gcry_mpi_point_release(G);\n\n        return ret;\n    }\n} /* namespace libgcrypt_detail */\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_PrivateToPublic code for module.cpp"}, {"role": "assistant", "content": "std::optional<component::ECC_PublicKey> libgcrypt::OpECC_PrivateToPublic(operation::ECC_PrivateToPublic& op) {\n    Datasource ds(op.modifier.GetPtr(), op.modifier.GetSize());\n\n    return libgcrypt_detail::ECC_PrivateToPublic(ds, op.curveType, op.priv);\n}\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECDSA_Sign code for module.cpp"}, {"role": "assistant", "content": "std::optional<component::ECDSA_Signature> libgcrypt::OpECDSA_Sign(operation::ECDSA_Sign& op) {\n    std::optional<component::ECDSA_Signature> ret = std::nullopt;\n    Datasource ds(op.modifier.GetPtr(), op.modifier.GetSize());\n\n    std::optional<component::ECC_PublicKey> pub = std::nullopt;\n    std::optional<std::string> curveStr = std::nullopt;\n    gcry_sexp_t sig_sexp, data_sexp, priv_sexp;\n    bool data_sexp_set = false;\n    bool priv_sexp_set = false;\n    bool sig_sexp_set = false;\n    std::string R, S;\n\n    static const char data_sexp_tpl_rfc6979[] =\n        \"(data (flags rfc6979)\\n\"\n        \" (hash sha256 %b))\";\n    static const char data_sexp_tpl_random[] =\n        \"(data (flags raw)\\n\"\n        \" (hash sha256 %b))\";\n    static const char priv_sexp_tpl[] =\n        \"(private-key\\n\"\n        \" (ecdsa\\n\"\n        \"  (curve %s)\\n\"\n        \"  (d %M)\"\n        \"))\";\n\n    CF_CHECK_NE(curveStr = libgcrypt_detail::toCurveString(op.curveType), std::nullopt);\n    CF_CHECK_TRUE(op.digestType.Is(CF_DIGEST(\"NULL\")));\n\n    CF_CHECK_NE(pub = libgcrypt_detail::ECC_PrivateToPublic(ds, op.curveType, op.priv), std::nullopt);\n\n    if ( op.UseRFC6979Nonce() ) {\n        CF_CHECK_EQ(gcry_sexp_build(&data_sexp, nullptr, data_sexp_tpl_rfc6979, op.cleartext.GetSize(), op.cleartext.GetPtr()), GPG_ERR_NO_ERROR);\n    } else if ( op.UseRandomNonce() ) {\n        CF_CHECK_EQ(gcry_sexp_build(&data_sexp, nullptr, data_sexp_tpl_random, op.cleartext.GetSize(), op.cleartext.GetPtr()), GPG_ERR_NO_ERROR);\n    } else {\n        goto end;\n    }\n\n    data_sexp_set = true;\n\n    {\n        libgcrypt_bignum::Bignum priv;\n        CF_CHECK_EQ(priv.Set(op.priv.ToString(ds)), true);\n        CF_CHECK_EQ(gcry_sexp_build(&priv_sexp, nullptr, priv_sexp_tpl, curveStr->c_str(), priv.GetPtr()), GPG_ERR_NO_ERROR);\n        priv_sexp_set = true;\n    }\n\n    CF_CHECK_EQ(gcry_pk_sign(&sig_sexp, data_sexp, priv_sexp), GPG_ERR_NO_ERROR);\n    sig_sexp_set = true;\n\n    {\n        gcry_sexp_t r = gcry_sexp_find_token(sig_sexp, \"r\", 0);\n        size_t datalen;\n        const void* data = gcry_sexp_nth_data(r, 1, &datalen);\n        CF_ASSERT(data != nullptr, \"Signature s-expression does not contain R\");\n        R = util::BinToDec((const uint8_t*)data, datalen);\n        gcry_sexp_release(r);\n    }\n    {\n        gcry_sexp_t s = gcry_sexp_find_token(sig_sexp, \"s\", 0);\n        size_t datalen;\n        const void* data = gcry_sexp_nth_data(s, 1, &datalen);\n        CF_ASSERT(data != nullptr, \"Signature s-expression does not contain S\");\n        auto s_bn = component::Bignum(util::BinToDec((const uint8_t*)data, datalen));\n        CF_NORET(util::AdjustECDSASignature(op.curveType.Get(), s_bn));\n        S = s_bn.ToTrimmedString();\n        gcry_sexp_release(s);\n    }\n\n    ret = component::ECDSA_Signature({R, S}, *pub);\n\nend:\n    if ( data_sexp_set ) {\n        gcry_sexp_release(data_sexp);\n    }\n    if ( priv_sexp_set ) {\n        gcry_sexp_release(priv_sexp);\n    }\n    if ( sig_sexp_set ) {\n        gcry_sexp_release(sig_sexp);\n    }\n    return ret;\n}\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECDSA_Verify code for module.cpp"}, {"role": "assistant", "content": "std::optional<bool> libgcrypt::OpECDSA_Verify(operation::ECDSA_Verify& op) {\n    std::optional<bool> ret = std::nullopt;\n    Datasource ds(op.modifier.GetPtr(), op.modifier.GetSize());\n\n    std::optional<std::string> curveStr = std::nullopt;\n    gcry_sexp_t sig_sexp, data_sexp, pub_sexp;\n    bool sig_sexp_set = false;\n    bool data_sexp_set = false;\n    bool pub_sexp_set = false;\n\n    CF_CHECK_NE(curveStr = libgcrypt_detail::toCurveString(op.curveType), std::nullopt);\n\n    {\n        const auto numBits = cryptofuzz::repository::ECC_CurveToBits(op.curveType.Get());\n        CF_CHECK_NE(numBits, std::nullopt);\n        const size_t numBytes = (*numBits + 7) / 8;\n\n        CF_CHECK_EQ(op.cleartext.GetSize(), numBytes);\n    }\n\n    CF_CHECK_TRUE(op.digestType.Is(CF_DIGEST(\"NULL\")));\n\n    /* Set signature */\n    {\n        libgcrypt_bignum::Bignum r, s;\n        CF_CHECK_EQ(r.Set(op.signature.signature.first.ToString(ds)), true);\n        CF_CHECK_EQ(s.Set(op.signature.signature.second.ToString(ds)), true);\n        CF_CHECK_EQ(gcry_sexp_build(&sig_sexp, nullptr, \"(sig-val (ecdsa (r %M) (s %M)))\", r.GetPtr(), s.GetPtr()), GPG_ERR_NO_ERROR)\n    }\n    sig_sexp_set = true;\n\n    /* Set data */\n    if ( op.cleartext.GetSize() > 32 ) {\n        CF_CHECK_EQ(gcry_sexp_build(&data_sexp, nullptr, \"(data (flags raw ) (value %b))\", 32, op.cleartext.GetPtr() + op.cleartext.GetSize() - 32), GPG_ERR_NO_ERROR);\n    } else {\n        CF_CHECK_EQ(gcry_sexp_build(&data_sexp, nullptr, \"(data (flags raw ) (value %b))\", op.cleartext.GetSize(), op.cleartext.GetPtr()), GPG_ERR_NO_ERROR);\n    }\n    data_sexp_set = true;\n\n    /* Set pubkey */\n\n    {\n        std::optional<std::vector<uint8_t>> pub_x, pub_y;\n        CF_CHECK_NE(pub_x = util::DecToBin(op.signature.pub.first.ToTrimmedString(), 32), std::nullopt);\n        CF_CHECK_NE(pub_y = util::DecToBin(op.signature.pub.second.ToTrimmedString(), 32), std::nullopt);\n\n        std::vector<uint8_t> pub;\n\n        pub.push_back(0x04);\n        pub.insert(std::end(pub), std::begin(*pub_x), std::end(*pub_x));\n        pub.insert(std::end(pub), std::begin(*pub_y), std::end(*pub_y));\n\n        {\n            std::string sexp_string;\n            sexp_string += \"(public-key (ecdsa (curve \\\"\";\n            sexp_string += *curveStr;\n            sexp_string += \"\\\") (q %b)))\";\n\n            CF_CHECK_EQ(gcry_sexp_build(&pub_sexp, NULL, sexp_string.c_str(), pub.size(), pub.data()), GPG_ERR_NO_ERROR);\n            pub_sexp_set = true;\n        }\n    }\n\n    ret = gcry_pk_verify(sig_sexp, data_sexp, pub_sexp) == GPG_ERR_NO_ERROR;\n\nend:\n    if ( sig_sexp_set ) {\n        gcry_sexp_release(sig_sexp);\n    }\n    if ( data_sexp_set ) {\n        gcry_sexp_release(data_sexp);\n    }\n    if ( pub_sexp_set ) {\n        gcry_sexp_release(pub_sexp);\n    }\n    return ret;\n}\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate Digest code for libgcrypt_module.h"}, {"role": "assistant", "content": "        std::optional<component::Digest> OpDigest(operation::Digest& op) override;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate HMAC code for libgcrypt_module.h"}, {"role": "assistant", "content": "        std::optional<component::MAC> OpHMAC(operation::HMAC& op) override;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate CMAC code for libgcrypt_module.h"}, {"role": "assistant", "content": "        std::optional<component::MAC> OpCMAC(operation::CMAC& op) override;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate SymmetricEncrypt code for libgcrypt_module.h"}, {"role": "assistant", "content": "        std::optional<component::Ciphertext> OpSymmetricEncrypt(operation::SymmetricEncrypt& op) override;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate SymmetricDecrypt code for libgcrypt_module.h"}, {"role": "assistant", "content": "        std::optional<component::Cleartext> OpSymmetricDecrypt(operation::SymmetricDecrypt& op) override;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_HKDF code for libgcrypt_module.h"}, {"role": "assistant", "content": "        std::optional<component::Key> OpKDF_HKDF(operation::KDF_HKDF& op) override;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_SCRYPT code for libgcrypt_module.h"}, {"role": "assistant", "content": "        std::optional<component::Key> OpKDF_SCRYPT(operation::KDF_SCRYPT& op) override;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_PBKDF2 code for libgcrypt_module.h"}, {"role": "assistant", "content": "        std::optional<component::Key> OpKDF_PBKDF2(operation::KDF_PBKDF2& op) override;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_ARGON2 code for libgcrypt_module.h"}, {"role": "assistant", "content": "        std::optional<component::Key> OpKDF_ARGON2(operation::KDF_ARGON2& op) override;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_X963 code for libgcrypt_module.h"}, {"role": "assistant", "content": "        std::optional<component::Key> OpKDF_X963(operation::KDF_X963& op) override;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_PrivateToPublic code for libgcrypt_module.h"}, {"role": "assistant", "content": "        std::optional<component::ECC_PublicKey> OpECC_PrivateToPublic(operation::ECC_PrivateToPublic& op) override;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECDSA_Sign code for libgcrypt_module.h"}, {"role": "assistant", "content": "        std::optional<component::ECDSA_Signature> OpECDSA_Sign(operation::ECDSA_Sign& op) override;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECDSA_Verify code for libgcrypt_module.h"}, {"role": "assistant", "content": "        std::optional<bool> OpECDSA_Verify(operation::ECDSA_Verify& op) override;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_Aggregate_G1 code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"BLS_Aggregate_G1\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_Aggregate_G2 code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"BLS_Aggregate_G2\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_BatchSign code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"BLS_BatchSign\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_BatchVerify code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"BLS_BatchVerify\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_Compress_G1 code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"BLS_Compress_G1\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_Compress_G2 code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"BLS_Compress_G2\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_Decompress_G1 code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"BLS_Decompress_G1\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_Decompress_G2 code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"BLS_Decompress_G2\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_FinalExp code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"BLS_FinalExp\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_G1_Add code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"BLS_G1_Add\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_G1_IsEq code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"BLS_G1_IsEq\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_G1_Mul code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"BLS_G1_Mul\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_G1_MultiExp code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"BLS_G1_MultiExp\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_G1_Neg code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"BLS_G1_Neg\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_G2_Add code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"BLS_G2_Add\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_G2_IsEq code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"BLS_G2_IsEq\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_G2_Mul code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"BLS_G2_Mul\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_G2_Neg code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"BLS_G2_Neg\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_GenerateKeyPair code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"BLS_GenerateKeyPair\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_HashToG1 code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"BLS_HashToG1\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_HashToG2 code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"BLS_HashToG2\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_IsG1OnCurve code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"BLS_IsG1OnCurve\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_IsG2OnCurve code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"BLS_IsG2OnCurve\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_MapToG1 code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"BLS_MapToG1\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_MapToG2 code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"BLS_MapToG2\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_MillerLoop code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"BLS_MillerLoop\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_Pairing code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"BLS_Pairing\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_PrivateToPublic code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"BLS_PrivateToPublic\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_PrivateToPublic_G2 code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"BLS_PrivateToPublic_G2\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_Sign code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"BLS_Sign\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_Verify code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"BLS_Verify\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"BignumCalc\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Fp12 code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"BignumCalc_Fp12\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Fp2 code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"BignumCalc_Fp2\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_2Exp128 code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"BignumCalc_Mod_2Exp128\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_2Exp256 code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"BignumCalc_Mod_2Exp256\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_2Exp512 code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"BignumCalc_Mod_2Exp512\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_2Exp64 code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"BignumCalc_Mod_2Exp64\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_BLS12_377_P code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"BignumCalc_Mod_BLS12_377_P\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_BLS12_377_R code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"BignumCalc_Mod_BLS12_377_R\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_BLS12_381_P code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"BignumCalc_Mod_BLS12_381_P\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_BLS12_381_R code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"BignumCalc_Mod_BLS12_381_R\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_BN128_P code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"BignumCalc_Mod_BN128_P\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_BN128_R code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"BignumCalc_Mod_BN128_R\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_ED25519 code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"BignumCalc_Mod_ED25519\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_Edwards_P code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"BignumCalc_Mod_Edwards_P\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_Edwards_R code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"BignumCalc_Mod_Edwards_R\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_Goldilocks code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"BignumCalc_Mod_Goldilocks\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_MNT4_P code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"BignumCalc_Mod_MNT4_P\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_MNT4_R code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"BignumCalc_Mod_MNT4_R\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_MNT6_P code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"BignumCalc_Mod_MNT6_P\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_MNT6_R code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"BignumCalc_Mod_MNT6_R\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_SECP256K1 code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"BignumCalc_Mod_SECP256K1\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_SECP256K1_P code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"BignumCalc_Mod_SECP256K1_P\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_Vesta_P code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"BignumCalc_Mod_Vesta_P\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_Vesta_R code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"BignumCalc_Mod_Vesta_R\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate CMAC code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"CMAC\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate DH_Derive code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"DH_Derive\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate DH_GenerateKeyPair code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"DH_GenerateKeyPair\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate DSA_GenerateKeyPair code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"DSA_GenerateKeyPair\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate DSA_GenerateParameters code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"DSA_GenerateParameters\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate DSA_PrivateToPublic code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"DSA_PrivateToPublic\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate DSA_Sign code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"DSA_Sign\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate DSA_Verify code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"DSA_Verify\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate Digest code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"Digest\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECCSI_Sign code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"ECCSI_Sign\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECCSI_Verify code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"ECCSI_Verify\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_GenerateKeyPair code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"ECC_GenerateKeyPair\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_Point_Add code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"ECC_Point_Add\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_Point_Cmp code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"ECC_Point_Cmp\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_Point_Dbl code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"ECC_Point_Dbl\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_Point_Mul code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"ECC_Point_Mul\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_Point_Neg code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"ECC_Point_Neg\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_Point_Sub code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"ECC_Point_Sub\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_PrivateToPublic code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"ECC_PrivateToPublic\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_ValidatePubkey code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"ECC_ValidatePubkey\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECDH_Derive code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"ECDH_Derive\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECDSA_Recover code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"ECDSA_Recover\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECDSA_Sign code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"ECDSA_Sign\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECDSA_Verify code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"ECDSA_Verify\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECGDSA_Sign code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"ECGDSA_Sign\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECGDSA_Verify code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"ECGDSA_Verify\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECIES_Decrypt code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"ECIES_Decrypt\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECIES_Encrypt code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"ECIES_Encrypt\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECRDSA_Sign code for gen_repository.py"}, {"role": "assistant", "content": "operations.Add( Operation(\"ECRDSA_Sign\") )"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate Digest code for tests.h"}, {"role": "assistant", "content": "void test(const operation::Digest& op, const std::optional<component::Digest>& result);"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate HMAC code for tests.h"}, {"role": "assistant", "content": "void test(const operation::HMAC& op, const std::optional<component::MAC>& result);"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate UMAC code for tests.h"}, {"role": "assistant", "content": "void test(const operation::UMAC& op, const std::optional<component::MAC>& result);"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate SymmetricEncrypt code for tests.h"}, {"role": "assistant", "content": "void test(const operation::SymmetricEncrypt& op, const std::optional<component::Ciphertext>& result);"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate SymmetricDecrypt code for tests.h"}, {"role": "assistant", "content": "void test(const operation::SymmetricDecrypt& op, const std::optional<component::Cleartext>& result);"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate CMAC code for tests.h"}, {"role": "assistant", "content": "void test(const operation::CMAC& op, const std::optional<component::MAC>& result);"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_SCRYPT code for tests.h"}, {"role": "assistant", "content": "void test(const operation::KDF_SCRYPT& op, const std::optional<component::Key>& result);"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_HKDF code for tests.h"}, {"role": "assistant", "content": "void test(const operation::KDF_HKDF& op, const std::optional<component::Key>& result);"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_TLS1_PRF code for tests.h"}, {"role": "assistant", "content": "void test(const operation::KDF_TLS1_PRF& op, const std::optional<component::Key>& result);"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_PBKDF code for tests.h"}, {"role": "assistant", "content": "void test(const operation::KDF_PBKDF& op, const std::optional<component::Key>& result);"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_PBKDF1 code for tests.h"}, {"role": "assistant", "content": "void test(const operation::KDF_PBKDF1& op, const std::optional<component::Key>& result);"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_PBKDF2 code for tests.h"}, {"role": "assistant", "content": "void test(const operation::KDF_PBKDF2& op, const std::optional<component::Key>& result);"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_ARGON2 code for tests.h"}, {"role": "assistant", "content": "void test(const operation::KDF_ARGON2& op, const std::optional<component::Key>& result);"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_SSH code for tests.h"}, {"role": "assistant", "content": "void test(const operation::KDF_SSH& op, const std::optional<component::Key>& result);"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_X963 code for tests.h"}, {"role": "assistant", "content": "void test(const operation::KDF_X963& op, const std::optional<component::Key>& result);"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_BCRYPT code for tests.h"}, {"role": "assistant", "content": "void test(const operation::KDF_BCRYPT& op, const std::optional<component::Key>& result);"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_SP_800_108 code for tests.h"}, {"role": "assistant", "content": "void test(const operation::KDF_SP_800_108& op, const std::optional<component::Key>& result);"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_SRTP code for tests.h"}, {"role": "assistant", "content": "void test(const operation::KDF_SRTP& op, const std::optional<component::Key3>& result);"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_SRTCP code for tests.h"}, {"role": "assistant", "content": "void test(const operation::KDF_SRTCP& op, const std::optional<component::Key3>& result);"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_PrivateToPublic code for tests.h"}, {"role": "assistant", "content": "void test(const operation::ECC_PrivateToPublic& op, const std::optional<component::ECC_PublicKey>& result);"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_ValidatePubkey code for tests.h"}, {"role": "assistant", "content": "void test(const operation::ECC_ValidatePubkey& op, const std::optional<bool>& result);"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_GenerateKeyPair code for tests.h"}, {"role": "assistant", "content": "void test(const operation::ECC_GenerateKeyPair& op, const std::optional<component::ECC_KeyPair>& result);"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECCSI_Sign code for tests.h"}, {"role": "assistant", "content": "void test(const operation::ECCSI_Sign& op, const std::optional<component::ECCSI_Signature>& result);"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECDSA_Sign code for tests.h"}, {"role": "assistant", "content": "void test(const operation::ECDSA_Sign& op, const std::optional<component::ECDSA_Signature>& result);"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECGDSA_Sign code for tests.h"}, {"role": "assistant", "content": "void test(const operation::ECGDSA_Sign& op, const std::optional<component::ECGDSA_Signature>& result);"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECRDSA_Sign code for tests.h"}, {"role": "assistant", "content": "void test(const operation::ECRDSA_Sign& op, const std::optional<component::ECRDSA_Signature>& result);"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate Schnorr_Sign code for tests.h"}, {"role": "assistant", "content": "void test(const operation::Schnorr_Sign& op, const std::optional<component::Schnorr_Signature>& result);"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECCSI_Verify code for tests.h"}, {"role": "assistant", "content": "void test(const operation::ECCSI_Verify& op, const std::optional<bool>& result);"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECDSA_Verify code for tests.h"}, {"role": "assistant", "content": "void test(const operation::ECDSA_Verify& op, const std::optional<bool>& result);"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECGDSA_Verify code for tests.h"}, {"role": "assistant", "content": "void test(const operation::ECGDSA_Verify& op, const std::optional<bool>& result);"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECRDSA_Verify code for tests.h"}, {"role": "assistant", "content": "void test(const operation::ECRDSA_Verify& op, const std::optional<bool>& result);"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate Schnorr_Verify code for tests.h"}, {"role": "assistant", "content": "void test(const operation::Schnorr_Verify& op, const std::optional<bool>& result);"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECDSA_Recover code for tests.h"}, {"role": "assistant", "content": "void test(const operation::ECDSA_Recover& op, const std::optional<component::ECC_PublicKey>& result);"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate DSA_Verify code for tests.h"}, {"role": "assistant", "content": "void test(const operation::DSA_Verify& op, const std::optional<bool>& result);"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate DSA_Sign code for tests.h"}, {"role": "assistant", "content": "void test(const operation::DSA_Sign& op, const std::optional<component::DSA_Signature>& result);"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate DSA_GenerateParameters code for tests.h"}, {"role": "assistant", "content": "void test(const operation::DSA_GenerateParameters& op, const std::optional<component::DSA_Parameters>& result);"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate DSA_PrivateToPublic code for tests.h"}, {"role": "assistant", "content": "void test(const operation::DSA_PrivateToPublic& op, const std::optional<component::Bignum>& result);"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate DSA_GenerateKeyPair code for tests.h"}, {"role": "assistant", "content": "void test(const operation::DSA_GenerateKeyPair& op, const std::optional<component::DSA_KeyPair>& result);"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECDH_Derive code for tests.h"}, {"role": "assistant", "content": "void test(const operation::ECDH_Derive& op, const std::optional<component::Secret>& result);"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECIES_Encrypt code for tests.h"}, {"role": "assistant", "content": "void test(const operation::ECIES_Encrypt& op, const std::optional<component::Ciphertext>& result);"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECIES_Decrypt code for tests.h"}, {"role": "assistant", "content": "void test(const operation::ECIES_Decrypt& op, const std::optional<component::Cleartext>& result);"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_Point_Add code for tests.h"}, {"role": "assistant", "content": "void test(const operation::ECC_Point_Add& op, const std::optional<component::ECC_Point>& result);"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_Point_Sub code for tests.h"}, {"role": "assistant", "content": "void test(const operation::ECC_Point_Sub& op, const std::optional<component::ECC_Point>& result);"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_Point_Mul code for tests.h"}, {"role": "assistant", "content": "void test(const operation::ECC_Point_Mul& op, const std::optional<component::ECC_Point>& result);"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_Point_Neg code for tests.h"}, {"role": "assistant", "content": "void test(const operation::ECC_Point_Neg& op, const std::optional<component::ECC_Point>& result);"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_Point_Dbl code for tests.h"}, {"role": "assistant", "content": "void test(const operation::ECC_Point_Dbl& op, const std::optional<component::ECC_Point>& result);"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_Point_Cmp code for tests.h"}, {"role": "assistant", "content": "void test(const operation::ECC_Point_Cmp& op, const std::optional<bool>& result);"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate DH_GenerateKeyPair code for tests.h"}, {"role": "assistant", "content": "void test(const operation::DH_GenerateKeyPair& op, const std::optional<component::DH_KeyPair>& result);"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate DH_Derive code for tests.h"}, {"role": "assistant", "content": "void test(const operation::DH_Derive& op, const std::optional<component::Bignum>& result);"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc code for tests.h"}, {"role": "assistant", "content": "void test(const operation::BignumCalc& op, const std::optional<component::Bignum>& result);"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Fp2 code for tests.h"}, {"role": "assistant", "content": "void test(const operation::BignumCalc_Fp2& op, const std::optional<component::Fp2>& result);"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Fp12 code for tests.h"}, {"role": "assistant", "content": "void test(const operation::BignumCalc_Fp12& op, const std::optional<component::Fp12>& result);"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_PrivateToPublic code for tests.h"}, {"role": "assistant", "content": "void test(const operation::BLS_PrivateToPublic& op, const std::optional<component::BLS_PublicKey>& result);"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_PrivateToPublic_G2 code for tests.h"}, {"role": "assistant", "content": "void test(const operation::BLS_PrivateToPublic_G2& op, const std::optional<component::G2>& result);"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_Sign code for tests.h"}, {"role": "assistant", "content": "void test(const operation::BLS_Sign& op, const std::optional<component::BLS_Signature>& result);"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_Verify code for tests.h"}, {"role": "assistant", "content": "void test(const operation::BLS_Verify& op, const std::optional<bool>& result);"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_BatchSign code for tests.h"}, {"role": "assistant", "content": "void test(const operation::BLS_BatchSign& op, const std::optional<component::BLS_BatchSignature>& result);"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_BatchVerify code for tests.h"}, {"role": "assistant", "content": "void test(const operation::BLS_BatchVerify& op, const std::optional<bool>& result);"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_Aggregate_G1 code for tests.h"}, {"role": "assistant", "content": "void test(const operation::BLS_Aggregate_G1& op, const std::optional<component::G1>& result);"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_Aggregate_G2 code for tests.h"}, {"role": "assistant", "content": "void test(const operation::BLS_Aggregate_G2& op, const std::optional<component::G2>& result);"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_Pairing code for tests.h"}, {"role": "assistant", "content": "void test(const operation::BLS_Pairing& op, const std::optional<component::Fp12>& result);"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_MillerLoop code for tests.h"}, {"role": "assistant", "content": "void test(const operation::BLS_MillerLoop& op, const std::optional<component::Fp12>& result);"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_FinalExp code for tests.h"}, {"role": "assistant", "content": "void test(const operation::BLS_FinalExp& op, const std::optional<component::Fp12>& result);"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_HashToG1 code for tests.h"}, {"role": "assistant", "content": "void test(const operation::BLS_HashToG1& op, const std::optional<component::G1>& result);"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_HashToG2 code for tests.h"}, {"role": "assistant", "content": "void test(const operation::BLS_HashToG2& op, const std::optional<component::G2>& result);"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_MapToG1 code for tests.h"}, {"role": "assistant", "content": "void test(const operation::BLS_MapToG1& op, const std::optional<component::G1>& result);"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_MapToG2 code for tests.h"}, {"role": "assistant", "content": "void test(const operation::BLS_MapToG2& op, const std::optional<component::G2>& result);"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_IsG1OnCurve code for tests.h"}, {"role": "assistant", "content": "void test(const operation::BLS_IsG1OnCurve& op, const std::optional<bool>& result);"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate Digest code for tests.cpp"}, {"role": "assistant", "content": "void test(const operation::Digest& op, const std::optional<component::Digest>& result) {\n    if ( result == std::nullopt ) {\n        return;\n    }\n\n    {\n        const auto expectedSize = repository::DigestSize(op.digestType.Get());\n\n        if ( expectedSize != std::nullopt ) {\n            if ( result->GetSize() != *expectedSize ) {\n                printf(\"Expected vs actual digest size: %zu / %zu\\n\", *expectedSize, result->GetSize());\n                abort();\n            }\n        }\n    }\n\n#if 0\n    if ( op.digestType.Is(CF_DIGEST(\"SHA1\")) ) {\n        /* https://words.filippo.io/dispatches/seeds-bounty/ */\n\n        static const std::vector< std::vector<uint8_t> > hashes{\n            /* NIST P-192 */\n            {\n                0x30, 0x45, 0xAE, 0x6F, 0xC8, 0x42, 0x2F, 0x64, 0xED, 0x57,\n                    0x95, 0x28, 0xD3, 0x81, 0x20, 0xEA, 0xE1, 0x21, 0x96, 0xD5,\n            },\n            /* NIST P-224 */\n            {\n                0xBD, 0x71, 0x34, 0x47, 0x99, 0xD5, 0xC7, 0xFC, 0xDC, 0x45,\n                0xB5, 0x9F, 0xA3, 0xB9, 0xAB, 0x8F, 0x6A, 0x94, 0x8B, 0xC5,\n            },\n            /* NIST P-256 */\n            {\n                0xC4, 0x9D, 0x36, 0x08, 0x86, 0xE7, 0x04, 0x93, 0x6A, 0x66,\n                0x78, 0xE1, 0x13, 0x9D, 0x26, 0xB7, 0x81, 0x9F, 0x7E, 0x90,\n            },\n            /* NIST P-384 */\n            {\n                0xA3, 0x35, 0x92, 0x6A, 0xA3, 0x19, 0xA2, 0x7A, 0x1D, 0x00,\n                0x89, 0x6A, 0x67, 0x73, 0xA4, 0x82, 0x7A, 0xCD, 0xAC, 0x73,\n            },\n            /* NIST P-521 */\n            {\n                0xD0, 0x9E, 0x88, 0x00, 0x29, 0x1C, 0xB8, 0x53, 0x96, 0xCC,\n                0x67, 0x17, 0x39, 0x32, 0x84, 0xAA, 0xA0, 0xDA, 0x64, 0xBA,\n            },\n            /* ANSI prime192v2 */\n            {\n                0x31, 0xA9, 0x2E, 0xE2, 0x02, 0x9F, 0xD1, 0x0D, 0x90, 0x1B,\n                0x11, 0x3E, 0x99, 0x07, 0x10, 0xF0, 0xD2, 0x1A, 0xC6, 0xB6,\n            },\n            /* ANSI prime192v3 */\n            {\n                0xC4, 0x69, 0x68, 0x44, 0x35, 0xDE, 0xB3, 0x78, 0xC4, 0xB6,\n                0x5C, 0xA9, 0x59, 0x1E, 0x2A, 0x57, 0x63, 0x05, 0x9A, 0x2E,\n            },\n            /* ANSI prime239v1 */\n            {\n                0xE4, 0x3B, 0xB4, 0x60, 0xF0, 0xB8, 0x0C, 0xC0, 0xC0, 0xB0,\n                0x75, 0x79, 0x8E, 0x94, 0x80, 0x60, 0xF8, 0x32, 0x1B, 0x7D,\n            },\n            /* ANSI prime239v2 */\n            {\n                0xE8, 0xB4, 0x01, 0x16, 0x04, 0x09, 0x53, 0x03, 0xCA, 0x3B,\n                0x80, 0x99, 0x98, 0x2B, 0xE0, 0x9F, 0xCB, 0x9A, 0xE6, 0x16,\n            },\n            /* ANSI prime239v3 */\n            {\n                0x7D, 0x73, 0x74, 0x16, 0x8F, 0xFE, 0x34, 0x71, 0xB6, 0x0A,\n                0x85, 0x76, 0x86, 0xA1, 0x94, 0x75, 0xD3, 0xBF, 0xA2, 0xFF,\n            },\n            /* NIST B-163 */\n            {\n                0x85, 0xE2, 0x5B, 0xFE, 0x5C, 0x86, 0x22, 0x6C, 0xDB, 0x12,\n                0x01, 0x6F, 0x75, 0x53, 0xF9, 0xD0, 0xE6, 0x93, 0xA2, 0x68,\n            },\n            /* NIST B-233 */\n            {\n                0x74, 0xD5, 0x9F, 0xF0, 0x7F, 0x6B, 0x41, 0x3D, 0x0E, 0xA1,\n                0x4B, 0x34, 0x4B, 0x20, 0xA2, 0xDB, 0x04, 0x9B, 0x50, 0xC3,\n            },\n            /* NIST B-283 */\n            {\n                0x77, 0xE2, 0xB0, 0x73, 0x70, 0xEB, 0x0F, 0x83, 0x2A, 0x6D,\n                0xD5, 0xB6, 0x2D, 0xFC, 0x88, 0xCD, 0x06, 0xBB, 0x84, 0xBE,\n            },\n            /* NIST B-409 */\n            {\n                0x40, 0x99, 0xB5, 0xA4, 0x57, 0xF9, 0xD6, 0x9F, 0x79, 0x21,\n                0x3D, 0x09, 0x4C, 0x4B, 0xCD, 0x4D, 0x42, 0x62, 0x21, 0x0B,\n            },\n            /* NIST B-571 */\n            {\n                0x2A, 0xA0, 0x58, 0xF7, 0x3A, 0x0E, 0x33, 0xAB, 0x48, 0x6B,\n                0x0F, 0x61, 0x04, 0x10, 0xC5, 0x3A, 0x7F, 0x13, 0x23, 0x10,\n            },\n        };\n\n        for (const auto& hash : hashes) {\n            if ( result->Get() == hash ) abort();\n        }\n    }\n#endif\n\n    checkZeroResult(result);\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate HMAC code for tests.cpp"}, {"role": "assistant", "content": "void test(const operation::HMAC& op, const std::optional<component::MAC>& result) {\n    if ( result == std::nullopt ) {\n        return;\n    }\n\n    {\n        const auto expectedSize = repository::DigestSize(op.digestType.Get());\n\n        if ( expectedSize != std::nullopt ) {\n            if ( result->GetSize() != *expectedSize ) {\n                printf(\"Expected vs actual digest size: %zu / %zu\\n\", *expectedSize, result->GetSize());\n                abort();\n            }\n        }\n    }\n\n    checkZeroResult(result);\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate UMAC code for tests.cpp"}, {"role": "assistant", "content": "void test(const operation::UMAC& op, const std::optional<component::MAC>& result) {\n    if ( result == std::nullopt ) {\n        return;\n    }\n\n    if (\n            ( op.type == 0 && result->GetSize() > (32/8) ) ||\n            ( op.type == 1 && result->GetSize() > (64/8) ) ||\n            ( op.type == 2 && result->GetSize() > (96/8) ) ||\n            ( op.type == 3 && result->GetSize() > (128/8) )\n    ) {\n        printf(\"UMAC: Overlong result: %zu\\n\", result->GetSize());\n        abort();\n    }\n}\n\n    using fuzzing::datasource::ID;\n\n    if ( op.cipher.cipherType.Get() != CF_CIPHER(\"XCHACHA20_POLY1305\") ) {\n        return;\n    }\n\n    if ( result == std::nullopt ) {\n        return;\n    }\n\n    if ( op.cipher.iv.GetSize() != 24 ) {\n        printf(\"XChaCha20-Poly1305 succeeded with an IV of %zu bytes large, but only IVs of 24 bytes are valid\\n\", op.cipher.iv.GetSize());\n        abort();\n    }\n}\n\n    bool fail = false;\n\n    if ( result == std::nullopt ) {\n        return;\n    }\n\n    switch ( op.cipher.cipherType.Get() ) {\n        case CF_CIPHER(\"AES_128_GCM\"):\n        case CF_CIPHER(\"AES_192_GCM\"):\n        case CF_CIPHER(\"AES_256_GCM\"):\n            break;\n        default:\n            return;\n    }\n\n    if ( op.cipher.iv.GetSize() == 0 ) {\n        printf(\"AES GCM: Invalid IV size\\n\");\n        fail = true;\n    }\n\n    if ( fail == true ) {\n        printf(\"AES GCM tests based on Wycheproof: https://github.com/google/wycheproof/blob/4672ff74d68766e7785c2cac4c597effccef2c5c/testvectors/aes_gcm_test.json#L13\\n\");\n        abort();\n    }\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate SymmetricEncrypt code for tests.cpp"}, {"role": "assistant", "content": "void test(const operation::SymmetricEncrypt& op, const std::optional<component::Ciphertext>& result) {\n    test_ChaCha20_Poly1305_IV(op, result);\n    test_XChaCha20_Poly1305_IV(op, result);\n    test_AES_CCM_Wycheproof(op, result);\n    test_AES_GCM_Wycheproof(op, result);\n}\n\n\nstatic void test_ChaCha20_Poly1305_IV(const operation::SymmetricEncrypt& op, const std::optional<component::Ciphertext>& result) {\n    using fuzzing::datasource::ID;\n\n    /*\n     * OpenSSL CVE-2019-1543\n     * https://www.openssl.org/news/secadv/20190306.txt\n     */\n\n    if ( op.cipher.cipherType.Get() != CF_CIPHER(\"CHACHA20_POLY1305\") ) {\n        return;\n    }\n\n    if ( result == std::nullopt ) {\n        return;\n    }\n\n    if ( op.cipher.iv.GetSize() > 12 ) {\n        abort();\n    }\n}\n\n\n\nstatic void test_AES_CCM_Wycheproof(const operation::SymmetricEncrypt& op, const std::optional<component::Ciphertext>& result) {\n    bool fail = false;\n\n    if ( result == std::nullopt ) {\n        return;\n    }\n\n    switch ( op.cipher.cipherType.Get() ) {\n        case CF_CIPHER(\"AES_128_CCM\"):\n        case CF_CIPHER(\"AES_192_CCM\"):\n        case CF_CIPHER(\"AES_256_CCM\"):\n            break;\n        default:\n            return;\n    }\n\n    if ( op.cipher.iv.GetSize() < 7 || op.cipher.iv.GetSize() > 13 ) {\n        printf(\"AES CCM: Invalid IV size\\n\");\n        fail = true;\n    }\n\n    if ( result->tag != std::nullopt ) {\n        static const std::vector<size_t> validTagSizes = {4, 6, 8, 10, 12, 14, 16};\n\n        if ( std::find(validTagSizes.begin(), validTagSizes.end(), result->tag->GetSize()) == validTagSizes.end() ) {\n            printf(\"AES CCM: Invalid tag size\\n\");\n            fail = true;\n        }\n    }\n\n    if ( fail == true ) {\n        printf(\"AES CCM tests based on Wycheproof: https://github.com/google/wycheproof/blob/4672ff74d68766e7785c2cac4c597effccef2c5c/testvectors/aes_ccm_test.json#L11\\n\");\n        abort();\n    }\n}\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate SymmetricDecrypt code for tests.cpp"}, {"role": "assistant", "content": "void test(const operation::SymmetricDecrypt& op, const std::optional<component::Cleartext>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate CMAC code for tests.cpp"}, {"role": "assistant", "content": "void test(const operation::CMAC& op, const std::optional<component::MAC>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_SCRYPT code for tests.cpp"}, {"role": "assistant", "content": "void test(const operation::KDF_SCRYPT& op, const std::optional<component::Key>& result) {\n    verifyKeySize(op, result);\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_HKDF code for tests.cpp"}, {"role": "assistant", "content": "void test(const operation::KDF_HKDF& op, const std::optional<component::Key>& result) {\n    verifyKeySize(op, result);\n\n    test_HKDF_OutputSize(op, result);\n}\n\n\nstatic void test_HKDF_OutputSize(const operation::KDF_HKDF& op, const std::optional<component::Key>& result) {\n    if ( result == std::nullopt ) {\n        return;\n    }\n\n    const auto expectedSize = repository::DigestSize(op.digestType.Get());\n\n    if ( expectedSize == std::nullopt ) {\n        return;\n    }\n\n    const size_t maxOutputSize = 255 * *expectedSize;\n\n    if ( result->GetSize() > maxOutputSize ) {\n        printf(\"The output size of HKDF (%zu) is more than 255 * the size of the hash digest (%zu)\\n\", result->GetSize(), maxOutputSize);\n        abort();\n    }\n}\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_TLS1_PRF code for tests.cpp"}, {"role": "assistant", "content": "void test(const operation::KDF_TLS1_PRF& op, const std::optional<component::Key>& result) {\n    verifyKeySize(op, result);\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_PBKDF code for tests.cpp"}, {"role": "assistant", "content": "void test(const operation::KDF_PBKDF& op, const std::optional<component::Key>& result) {\n    verifyKeySize(op, result);\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_PBKDF1 code for tests.cpp"}, {"role": "assistant", "content": "void test(const operation::KDF_PBKDF1& op, const std::optional<component::Key>& result) {\n    verifyKeySize(op, result);\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_PBKDF2 code for tests.cpp"}, {"role": "assistant", "content": "void test(const operation::KDF_PBKDF2& op, const std::optional<component::Key>& result) {\n    verifyKeySize(op, result);\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_ARGON2 code for tests.cpp"}, {"role": "assistant", "content": "void test(const operation::KDF_ARGON2& op, const std::optional<component::Key>& result) {\n    verifyKeySize(op, result);\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_SSH code for tests.cpp"}, {"role": "assistant", "content": "void test(const operation::KDF_SSH& op, const std::optional<component::Key>& result) {\n    verifyKeySize(op, result);\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_X963 code for tests.cpp"}, {"role": "assistant", "content": "void test(const operation::KDF_X963& op, const std::optional<component::Key>& result) {\n    verifyKeySize(op, result);\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_BCRYPT code for tests.cpp"}, {"role": "assistant", "content": "void test(const operation::KDF_BCRYPT& op, const std::optional<component::Key>& result) {\n    verifyKeySize(op, result);\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_SP_800_108 code for tests.cpp"}, {"role": "assistant", "content": "void test(const operation::KDF_SP_800_108& op, const std::optional<component::Key>& result) {\n    verifyKeySize(op, result);\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_SRTP code for tests.cpp"}, {"role": "assistant", "content": "void test(const operation::KDF_SRTP& op, const std::optional<component::Key3>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_SRTCP code for tests.cpp"}, {"role": "assistant", "content": "void test(const operation::KDF_SRTCP& op, const std::optional<component::Key3>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_PrivateToPublic code for tests.cpp"}, {"role": "assistant", "content": "void test(const operation::ECC_PrivateToPublic& op, const std::optional<component::ECC_PublicKey>& result) {\n    if ( result != std::nullopt ) {\n        test_ECC_PrivateKey(op.curveType.Get(), op.priv.ToTrimmedString());\n    }\n}\n\n\nstatic void test_ECC_PrivateKey(const uint64_t curveID, const std::string priv) {\n    /* Disabled until all modules comply by default */\n    return;\n\n    /* Private key may be 0 with these curves */\n    if ( IsSpecialCurve(curveID) ) {\n        return;\n    }\n\n    if ( priv == \"0\" ) {\n        std::cout << \"0 is an invalid elliptic curve private key\" << std::endl;\n        ::abort();\n    }\n}\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_ValidatePubkey code for tests.cpp"}, {"role": "assistant", "content": "void test(const operation::ECC_ValidatePubkey& op, const std::optional<bool>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_GenerateKeyPair code for tests.cpp"}, {"role": "assistant", "content": "void test(const operation::ECC_GenerateKeyPair& op, const std::optional<component::ECC_KeyPair>& result) {\n    if ( result != std::nullopt ) {\n        test_ECC_PrivateKey(op.curveType.Get(), result->priv.ToTrimmedString());\n    }\n}\n\n    boost::multiprecision::cpp_int r(R);\n    boost::multiprecision::cpp_int s(S);\n    if ( r < 1 ) {\n        std::cout << \"BIP340 Schnorr signature invalid: R < 1\" << std::endl;\n        ::abort();\n    }\n    if ( s < 1 ) {\n        std::cout << \"BIP340 Schnorr signature invalid: S < 1\" << std::endl;\n        ::abort();\n    }\n\n    const auto prime = cryptofuzz::repository::ECC_CurveToPrime(curveID);\n    if ( prime != std::nullopt ) {\n        const boost::multiprecision::cpp_int p(*prime);\n        CF_ASSERT(r < p, \"BIP340 Schnorr signature R should be less than curve P\");\n    }\n\n    const auto order = cryptofuzz::repository::ECC_CurveToOrder(curveID);\n    if ( order != std::nullopt ) {\n        const boost::multiprecision::cpp_int n(*order);\n        CF_ASSERT(s < n, \"BIP340 Schnorr signature S should be less than curve N\");\n    }\n}\n\n\nstatic void test_ECC_PrivateKey(const uint64_t curveID, const std::string priv) {\n    /* Disabled until all modules comply by default */\n    return;\n\n    /* Private key may be 0 with these curves */\n    if ( IsSpecialCurve(curveID) ) {\n        return;\n    }\n\n    if ( priv == \"0\" ) {\n        std::cout << \"0 is an invalid elliptic curve private key\" << std::endl;\n        ::abort();\n    }\n}\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECCSI_Sign code for tests.cpp"}, {"role": "assistant", "content": "void test(const operation::ECCSI_Sign& op, const std::optional<component::ECCSI_Signature>& result) {\n    (void)op;\n    (void)result;\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECDSA_Sign code for tests.cpp"}, {"role": "assistant", "content": "void test(const operation::ECDSA_Sign& op, const std::optional<component::ECDSA_Signature>& result) {\n    if ( result != std::nullopt ) {\n        test_ECC_PrivateKey(op.curveType.Get(), op.priv.ToTrimmedString());\n\n        if (\n                op.UseSpecifiedNonce() == true &&\n                !IsSpecialCurve(op.curveType.Get()) &&\n                op.nonce.ToTrimmedString() == \"0\"\n           ) {\n            std::cout << \"0 is an invalid ECDSA nonce\" << std::endl;\n            ::abort();\n        }\n\n        test_ECDSA_Signature(op.curveType.Get(),\n                result->signature.first.ToTrimmedString(),\n                result->signature.second.ToTrimmedString());\n    }\n}\n\n\nstatic void test_ECC_PrivateKey(const uint64_t curveID, const std::string priv) {\n    /* Disabled until all modules comply by default */\n    return;\n\n    /* Private key may be 0 with these curves */\n    if ( IsSpecialCurve(curveID) ) {\n        return;\n    }\n\n    if ( priv == \"0\" ) {\n        std::cout << \"0 is an invalid elliptic curve private key\" << std::endl;\n        ::abort();\n    }\n}\n\n\n\nstatic void test_ECDSA_Signature(const uint64_t curveID, const std::string R, const std::string S) {\n    if ( IsSpecialCurve(curveID) ) {\n        return;\n    }\n\n    const boost::multiprecision::cpp_int r(R), s(S);\n\n    if ( r < 1 ) {\n        std::cout << \"ECDSA signature invalid: R < 1\" << std::endl;\n        ::abort();\n    }\n    if ( s < 1 ) {\n        std::cout << \"ECDSA signature invalid: S < 1\" << std::endl;\n        ::abort();\n    }\n\n    const auto O = cryptofuzz::repository::ECC_CurveToOrder(curveID);\n    if ( O == std::nullopt ) {\n        return;\n    }\n\n    const boost::multiprecision::cpp_int o(*O);\n\n    if ( r >= o ) {\n        std::cout << \"ECDSA signature invalid: R >= order\" << std::endl;\n        ::abort();\n    }\n\n    if ( s >= o ) {\n        std::cout << \"ECDSA signature invalid: S >= order\" << std::endl;\n        ::abort();\n    }\n}\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECGDSA_Sign code for tests.cpp"}, {"role": "assistant", "content": "void test(const operation::ECGDSA_Sign& op, const std::optional<component::ECGDSA_Signature>& result) {\n    if ( result != std::nullopt ) {\n        test_ECC_PrivateKey(op.curveType.Get(), op.priv.ToTrimmedString());\n\n        if (\n                op.UseSpecifiedNonce() == true &&\n                !IsSpecialCurve(op.curveType.Get()) &&\n                op.nonce.ToTrimmedString() == \"0\"\n           ) {\n            std::cout << \"0 is an invalid ECGDSA nonce\" << std::endl;\n            ::abort();\n        }\n\n        test_ECDSA_Signature(op.curveType.Get(),\n                result->signature.first.ToTrimmedString(),\n                result->signature.second.ToTrimmedString());\n    }\n}\n\n\nstatic void test_ECC_PrivateKey(const uint64_t curveID, const std::string priv) {\n    /* Disabled until all modules comply by default */\n    return;\n\n    /* Private key may be 0 with these curves */\n    if ( IsSpecialCurve(curveID) ) {\n        return;\n    }\n\n    if ( priv == \"0\" ) {\n        std::cout << \"0 is an invalid elliptic curve private key\" << std::endl;\n        ::abort();\n    }\n}\n\n\n\nstatic void test_ECDSA_Signature(const uint64_t curveID, const std::string R, const std::string S) {\n    if ( IsSpecialCurve(curveID) ) {\n        return;\n    }\n\n    const boost::multiprecision::cpp_int r(R), s(S);\n\n    if ( r < 1 ) {\n        std::cout << \"ECDSA signature invalid: R < 1\" << std::endl;\n        ::abort();\n    }\n    if ( s < 1 ) {\n        std::cout << \"ECDSA signature invalid: S < 1\" << std::endl;\n        ::abort();\n    }\n\n    const auto O = cryptofuzz::repository::ECC_CurveToOrder(curveID);\n    if ( O == std::nullopt ) {\n        return;\n    }\n\n    const boost::multiprecision::cpp_int o(*O);\n\n    if ( r >= o ) {\n        std::cout << \"ECDSA signature invalid: R >= order\" << std::endl;\n        ::abort();\n    }\n\n    if ( s >= o ) {\n        std::cout << \"ECDSA signature invalid: S >= order\" << std::endl;\n        ::abort();\n    }\n}\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECRDSA_Sign code for tests.cpp"}, {"role": "assistant", "content": "void test(const operation::ECRDSA_Sign& op, const std::optional<component::ECRDSA_Signature>& result) {\n    if ( result != std::nullopt ) {\n        test_ECC_PrivateKey(op.curveType.Get(), op.priv.ToTrimmedString());\n\n        if (\n                op.UseSpecifiedNonce() == true &&\n                !IsSpecialCurve(op.curveType.Get()) &&\n                op.nonce.ToTrimmedString() == \"0\"\n           ) {\n            std::cout << \"0 is an invalid ECRDSA nonce\" << std::endl;\n            ::abort();\n        }\n\n        test_ECDSA_Signature(op.curveType.Get(),\n                result->signature.first.ToTrimmedString(),\n                result->signature.second.ToTrimmedString());\n    }\n}\n\n\nstatic void test_ECC_PrivateKey(const uint64_t curveID, const std::string priv) {\n    /* Disabled until all modules comply by default */\n    return;\n\n    /* Private key may be 0 with these curves */\n    if ( IsSpecialCurve(curveID) ) {\n        return;\n    }\n\n    if ( priv == \"0\" ) {\n        std::cout << \"0 is an invalid elliptic curve private key\" << std::endl;\n        ::abort();\n    }\n}\n\n\n\nstatic void test_ECDSA_Signature(const uint64_t curveID, const std::string R, const std::string S) {\n    if ( IsSpecialCurve(curveID) ) {\n        return;\n    }\n\n    const boost::multiprecision::cpp_int r(R), s(S);\n\n    if ( r < 1 ) {\n        std::cout << \"ECDSA signature invalid: R < 1\" << std::endl;\n        ::abort();\n    }\n    if ( s < 1 ) {\n        std::cout << \"ECDSA signature invalid: S < 1\" << std::endl;\n        ::abort();\n    }\n\n    const auto O = cryptofuzz::repository::ECC_CurveToOrder(curveID);\n    if ( O == std::nullopt ) {\n        return;\n    }\n\n    const boost::multiprecision::cpp_int o(*O);\n\n    if ( r >= o ) {\n        std::cout << \"ECDSA signature invalid: R >= order\" << std::endl;\n        ::abort();\n    }\n\n    if ( s >= o ) {\n        std::cout << \"ECDSA signature invalid: S >= order\" << std::endl;\n        ::abort();\n    }\n}\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate Schnorr_Sign code for tests.cpp"}, {"role": "assistant", "content": "void test(const operation::Schnorr_Sign& op, const std::optional<component::Schnorr_Signature>& result) {\n    if ( result != std::nullopt ) {\n        test_ECC_PrivateKey(op.curveType.Get(), op.priv.ToTrimmedString());\n\n        if (\n                op.UseSpecifiedNonce() == true &&\n                !IsSpecialCurve(op.curveType.Get()) &&\n                op.nonce.ToTrimmedString() == \"0\"\n           ) {\n            std::cout << \"0 is an invalid Schnorr nonce\" << std::endl;\n            ::abort();\n        }\n\n        test_BIP340_Schnorr_Signature(op.curveType.Get(),\n                result->signature.first.ToTrimmedString(),\n                result->signature.second.ToTrimmedString());\n    }\n}\n\n\nstatic void test_ECC_PrivateKey(const uint64_t curveID, const std::string priv) {\n    /* Disabled until all modules comply by default */\n    return;\n\n    /* Private key may be 0 with these curves */\n    if ( IsSpecialCurve(curveID) ) {\n        return;\n    }\n\n    if ( priv == \"0\" ) {\n        std::cout << \"0 is an invalid elliptic curve private key\" << std::endl;\n        ::abort();\n    }\n}\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECCSI_Verify code for tests.cpp"}, {"role": "assistant", "content": "void test(const operation::ECCSI_Verify& op, const std::optional<bool>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECDSA_Verify code for tests.cpp"}, {"role": "assistant", "content": "void test(const operation::ECDSA_Verify& op, const std::optional<bool>& result) {\n    if ( result != std::nullopt && *result == true ) {\n        test_ECDSA_Signature(op.curveType.Get(),\n                op.signature.signature.first.ToTrimmedString(),\n                op.signature.signature.second.ToTrimmedString());\n    }\n}\n\n\nstatic void test_ECDSA_Signature(const uint64_t curveID, const std::string R, const std::string S) {\n    if ( IsSpecialCurve(curveID) ) {\n        return;\n    }\n\n    const boost::multiprecision::cpp_int r(R), s(S);\n\n    if ( r < 1 ) {\n        std::cout << \"ECDSA signature invalid: R < 1\" << std::endl;\n        ::abort();\n    }\n    if ( s < 1 ) {\n        std::cout << \"ECDSA signature invalid: S < 1\" << std::endl;\n        ::abort();\n    }\n\n    const auto O = cryptofuzz::repository::ECC_CurveToOrder(curveID);\n    if ( O == std::nullopt ) {\n        return;\n    }\n\n    const boost::multiprecision::cpp_int o(*O);\n\n    if ( r >= o ) {\n        std::cout << \"ECDSA signature invalid: R >= order\" << std::endl;\n        ::abort();\n    }\n\n    if ( s >= o ) {\n        std::cout << \"ECDSA signature invalid: S >= order\" << std::endl;\n        ::abort();\n    }\n}\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECGDSA_Verify code for tests.cpp"}, {"role": "assistant", "content": "void test(const operation::ECGDSA_Verify& op, const std::optional<bool>& result) {\n    if ( result != std::nullopt && *result == true ) {\n        test_ECDSA_Signature(op.curveType.Get(),\n                op.signature.signature.first.ToTrimmedString(),\n                op.signature.signature.second.ToTrimmedString());\n    }\n}\n\n\nstatic void test_ECDSA_Signature(const uint64_t curveID, const std::string R, const std::string S) {\n    if ( IsSpecialCurve(curveID) ) {\n        return;\n    }\n\n    const boost::multiprecision::cpp_int r(R), s(S);\n\n    if ( r < 1 ) {\n        std::cout << \"ECDSA signature invalid: R < 1\" << std::endl;\n        ::abort();\n    }\n    if ( s < 1 ) {\n        std::cout << \"ECDSA signature invalid: S < 1\" << std::endl;\n        ::abort();\n    }\n\n    const auto O = cryptofuzz::repository::ECC_CurveToOrder(curveID);\n    if ( O == std::nullopt ) {\n        return;\n    }\n\n    const boost::multiprecision::cpp_int o(*O);\n\n    if ( r >= o ) {\n        std::cout << \"ECDSA signature invalid: R >= order\" << std::endl;\n        ::abort();\n    }\n\n    if ( s >= o ) {\n        std::cout << \"ECDSA signature invalid: S >= order\" << std::endl;\n        ::abort();\n    }\n}\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECRDSA_Verify code for tests.cpp"}, {"role": "assistant", "content": "void test(const operation::ECRDSA_Verify& op, const std::optional<bool>& result) {\n    if ( result != std::nullopt && *result == true ) {\n        test_ECDSA_Signature(op.curveType.Get(),\n                op.signature.signature.first.ToTrimmedString(),\n                op.signature.signature.second.ToTrimmedString());\n    }\n}\n\n\nstatic void test_ECDSA_Signature(const uint64_t curveID, const std::string R, const std::string S) {\n    if ( IsSpecialCurve(curveID) ) {\n        return;\n    }\n\n    const boost::multiprecision::cpp_int r(R), s(S);\n\n    if ( r < 1 ) {\n        std::cout << \"ECDSA signature invalid: R < 1\" << std::endl;\n        ::abort();\n    }\n    if ( s < 1 ) {\n        std::cout << \"ECDSA signature invalid: S < 1\" << std::endl;\n        ::abort();\n    }\n\n    const auto O = cryptofuzz::repository::ECC_CurveToOrder(curveID);\n    if ( O == std::nullopt ) {\n        return;\n    }\n\n    const boost::multiprecision::cpp_int o(*O);\n\n    if ( r >= o ) {\n        std::cout << \"ECDSA signature invalid: R >= order\" << std::endl;\n        ::abort();\n    }\n\n    if ( s >= o ) {\n        std::cout << \"ECDSA signature invalid: S >= order\" << std::endl;\n        ::abort();\n    }\n}\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate Schnorr_Verify code for tests.cpp"}, {"role": "assistant", "content": "void test(const operation::Schnorr_Verify& op, const std::optional<bool>& result) {\n    if ( result != std::nullopt && *result == true ) {\n        test_BIP340_Schnorr_Signature(op.curveType.Get(),\n                op.signature.signature.first.ToTrimmedString(),\n                op.signature.signature.second.ToTrimmedString());\n    }\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECDSA_Recover code for tests.cpp"}, {"role": "assistant", "content": "void test(const operation::ECDSA_Recover& op, const std::optional<component::ECC_PublicKey>& result) {\n    if ( result != std::nullopt ) {\n        if ( op.id > 3 ) {\n            std::cout << \"Invalid recovery ID\" << std::endl;\n            ::abort();\n        }\n    }\n    if ( result != std::nullopt ) {\n        test_ECDSA_Signature(op.curveType.Get(),\n                op.signature.first.ToTrimmedString(),\n                op.signature.second.ToTrimmedString());\n    }\n}\n\n\nstatic void test_ECDSA_Signature(const uint64_t curveID, const std::string R, const std::string S) {\n    if ( IsSpecialCurve(curveID) ) {\n        return;\n    }\n\n    const boost::multiprecision::cpp_int r(R), s(S);\n\n    if ( r < 1 ) {\n        std::cout << \"ECDSA signature invalid: R < 1\" << std::endl;\n        ::abort();\n    }\n    if ( s < 1 ) {\n        std::cout << \"ECDSA signature invalid: S < 1\" << std::endl;\n        ::abort();\n    }\n\n    const auto O = cryptofuzz::repository::ECC_CurveToOrder(curveID);\n    if ( O == std::nullopt ) {\n        return;\n    }\n\n    const boost::multiprecision::cpp_int o(*O);\n\n    if ( r >= o ) {\n        std::cout << \"ECDSA signature invalid: R >= order\" << std::endl;\n        ::abort();\n    }\n\n    if ( s >= o ) {\n        std::cout << \"ECDSA signature invalid: S >= order\" << std::endl;\n        ::abort();\n    }\n}\n\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate DSA_Verify code for tests.cpp"}, {"role": "assistant", "content": "void test(const operation::DSA_Verify& op, const std::optional<bool>& result) {\n    (void)op;\n\n    if ( result == std::nullopt || *result == false ) {\n        return;\n    }\n\n    if ( !op.signature.first.IsPositive() ) {\n        std::cout << \"DSA signature must be rejected if R is smaller than 1\" << std::endl;\n        ::abort();\n    }\n    if ( !op.signature.second.IsPositive() ) {\n        std::cout << \"DSA signature must be rejected is S is smaller than 1\" << std::endl;\n        ::abort();\n    }\n\n    /* Q > R */\n    if ( op.signature.first.ToTrimmedString().size() > op.parameters.q.ToTrimmedString().size() ) {\n        std::cout << \"DSA signature must be rejected if R is larger than Q\" << std::endl;\n        ::abort();\n    }\n    /* Q > S */\n    if ( op.signature.second.ToTrimmedString().size() > op.parameters.q.ToTrimmedString().size() ) {\n        std::cout << \"DSA signature must be rejected if S is larger than Q\" << std::endl;\n        ::abort();\n    }\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate DSA_Sign code for tests.cpp"}, {"role": "assistant", "content": "void test(const operation::DSA_Sign& op, const std::optional<component::DSA_Signature>& result) {\n    if ( result == std::nullopt ) {\n        return;\n    }\n\n    if ( !result->signature.first.IsPositive() ) {\n        std::cout << \"DSA signature R must be larger than 0\" << std::endl;\n        ::abort();\n    }\n    if ( !result->signature.second.IsPositive() ) {\n        std::cout << \"DSA signature S must be larger than 0\" << std::endl;\n        ::abort();\n    }\n\n    /* Q > R */\n    if ( result->signature.first.ToTrimmedString().size() > op.parameters.q.ToTrimmedString().size() ) {\n        std::cout << \"DSA signature R must be smaller than P\" << std::endl;\n        ::abort();\n    }\n    /* Q > S */\n    if ( result->signature.second.ToTrimmedString().size() > op.parameters.q.ToTrimmedString().size() ) {\n        std::cout << \"DSA signature S must be smaller than Q\" << std::endl;\n        ::abort();\n    }\n\n    /* R > 0 */\n    if ( !result->signature.first.IsPositive() ) {\n        std::cout << \"DSA signature R must be larger than 0\" << std::endl;\n        ::abort();\n    }\n    /* S > 0 */\n    if ( !result->signature.second.IsPositive() ) {\n        std::cout << \"DSA signature R must be larger than 0\" << std::endl;\n        ::abort();\n    }\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate DSA_GenerateParameters code for tests.cpp"}, {"role": "assistant", "content": "void test(const operation::DSA_GenerateParameters& op, const std::optional<component::DSA_Parameters>& result) {\n    (void)op;\n\n    if ( result == std::nullopt ) {\n        return;\n    }\n\n    /* Larger than 0 */\n    if ( !result->p.IsPositive() ) {\n        std::cout << \"DSA P parameter must be larger than 0\" << std::endl;\n        ::abort();\n    }\n    if ( !result->q.IsPositive() ) {\n        std::cout << \"DSA Q parameter must be larger than 0\" << std::endl;\n        ::abort();\n    }\n    if ( !result->g.IsPositive() ) {\n        std::cout << \"DSA G parameter must be larger than 0\" << std::endl;\n        ::abort();\n    }\n\n    /* P > Q */\n    if ( result->q.ToTrimmedString().size() > result->p.ToTrimmedString().size() ) {\n        std::cout << \"DSA Q must be smaller than P\" << std::endl;\n        ::abort();\n    }\n\n    /* P > G */\n    if ( result->q.ToTrimmedString().size() > result->p.ToTrimmedString().size() ) {\n        std::cout << \"DSA G must be smaller than P\" << std::endl;\n        ::abort();\n    }\n\n    /* G != 1 */\n    if ( result->p.ToTrimmedString() == \"1\" ) {\n        std::cout << \"DSA G must not be 1\" << std::endl;\n        ::abort();\n    }\n\n    /* P, Q must be prime */\n    if ( isComposite(result->p.ToTrimmedString()) ) {\n        std::cout << \"DSA P must be prime\" << std::endl;\n        ::abort();\n    }\n\n    if ( isComposite(result->q.ToTrimmedString()) ) {\n        std::cout << \"DSA Q must be prime\" << std::endl;\n        ::abort();\n    }\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate DSA_PrivateToPublic code for tests.cpp"}, {"role": "assistant", "content": "void test(const operation::DSA_PrivateToPublic& op, const std::optional<component::Bignum>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate DSA_GenerateKeyPair code for tests.cpp"}, {"role": "assistant", "content": "void test(const operation::DSA_GenerateKeyPair& op, const std::optional<component::DSA_KeyPair>& result) {\n    if ( result == std::nullopt ) {\n        return;\n    }\n\n    if ( !result->first.IsPositive() ) {\n        std::cout << \"Private key must be larger than 0\" << std::endl;\n        ::abort();\n    }\n\n    /* Q > priv */\n    if ( result->first.ToTrimmedString().size() > op.q.ToTrimmedString().size() ) {\n        std::cout << \"Q must be larger than private key\" << std::endl;\n        ::abort();\n    }\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECDH_Derive code for tests.cpp"}, {"role": "assistant", "content": "void test(const operation::ECDH_Derive& op, const std::optional<component::Secret>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECIES_Encrypt code for tests.cpp"}, {"role": "assistant", "content": "void test(const operation::ECIES_Encrypt& op, const std::optional<component::Ciphertext>& result) {\n    /* TODO check minimum size? */\n    (void)op;\n    (void)result;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECIES_Decrypt code for tests.cpp"}, {"role": "assistant", "content": "void test(const operation::ECIES_Decrypt& op, const std::optional<component::Cleartext>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_Point_Add code for tests.cpp"}, {"role": "assistant", "content": "void test(const operation::ECC_Point_Add& op, const std::optional<component::ECC_Point>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_Point_Sub code for tests.cpp"}, {"role": "assistant", "content": "void test(const operation::ECC_Point_Sub& op, const std::optional<component::ECC_Point>& result) {\n    if ( result == std::nullopt ) {\n        return;\n    }\n\n    if ( !(op.a.first == op.b.first) ) {\n        return;\n    }\n\n    if ( !(op.a.second == op.b.second) ) {\n        return;\n    }\n\n    if ( !result->first.IsZero() || !result->second.IsZero() ) {\n        std::cout << \"Subtracting equal points should result in point at infinity\" << std::endl;\n        ::abort();\n    }\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_Point_Mul code for tests.cpp"}, {"role": "assistant", "content": "void test(const operation::ECC_Point_Mul& op, const std::optional<component::ECC_Point>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_Point_Neg code for tests.cpp"}, {"role": "assistant", "content": "void test(const operation::ECC_Point_Neg& op, const std::optional<component::ECC_Point>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_Point_Dbl code for tests.cpp"}, {"role": "assistant", "content": "void test(const operation::ECC_Point_Dbl& op, const std::optional<component::ECC_Point>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_Point_Cmp code for tests.cpp"}, {"role": "assistant", "content": "void test(const operation::ECC_Point_Cmp& op, const std::optional<bool>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate DH_GenerateKeyPair code for tests.cpp"}, {"role": "assistant", "content": "void test(const operation::DH_GenerateKeyPair& op, const std::optional<component::DH_KeyPair>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate DH_Derive code for tests.cpp"}, {"role": "assistant", "content": "void test(const operation::DH_Derive& op, const std::optional<component::Bignum>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_PrivateToPublic code for tests.cpp"}, {"role": "assistant", "content": "void test(const operation::BLS_PrivateToPublic& op, const std::optional<component::BLS_PublicKey>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_PrivateToPublic_G2 code for tests.cpp"}, {"role": "assistant", "content": "void test(const operation::BLS_PrivateToPublic_G2& op, const std::optional<component::G2>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_Sign code for tests.cpp"}, {"role": "assistant", "content": "void test(const operation::BLS_Sign& op, const std::optional<component::BLS_Signature>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_Verify code for tests.cpp"}, {"role": "assistant", "content": "void test(const operation::BLS_Verify& op, const std::optional<bool>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_BatchSign code for tests.cpp"}, {"role": "assistant", "content": "void test(const operation::BLS_BatchSign& op, const std::optional<component::BLS_BatchSignature>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_BatchVerify code for tests.cpp"}, {"role": "assistant", "content": "void test(const operation::BLS_BatchVerify& op, const std::optional<bool>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_Aggregate_G1 code for tests.cpp"}, {"role": "assistant", "content": "void test(const operation::BLS_Aggregate_G1& op, const std::optional<component::G1>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_Aggregate_G2 code for tests.cpp"}, {"role": "assistant", "content": "void test(const operation::BLS_Aggregate_G2& op, const std::optional<component::G2>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_Pairing code for tests.cpp"}, {"role": "assistant", "content": "void test(const operation::BLS_Pairing& op, const std::optional<component::Fp12>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_MillerLoop code for tests.cpp"}, {"role": "assistant", "content": "void test(const operation::BLS_MillerLoop& op, const std::optional<component::Fp12>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_FinalExp code for tests.cpp"}, {"role": "assistant", "content": "void test(const operation::BLS_FinalExp& op, const std::optional<component::Fp12>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_HashToG1 code for tests.cpp"}, {"role": "assistant", "content": "void test(const operation::BLS_HashToG1& op, const std::optional<component::G1>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_HashToG2 code for tests.cpp"}, {"role": "assistant", "content": "void test(const operation::BLS_HashToG2& op, const std::optional<component::G2>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_MapToG1 code for tests.cpp"}, {"role": "assistant", "content": "void test(const operation::BLS_MapToG1& op, const std::optional<component::G1>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_MapToG2 code for tests.cpp"}, {"role": "assistant", "content": "void test(const operation::BLS_MapToG2& op, const std::optional<component::G2>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_IsG1OnCurve code for tests.cpp"}, {"role": "assistant", "content": "void test(const operation::BLS_IsG1OnCurve& op, const std::optional<bool>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_IsG2OnCurve code for tests.cpp"}, {"role": "assistant", "content": "void test(const operation::BLS_IsG2OnCurve& op, const std::optional<bool>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_GenerateKeyPair code for tests.cpp"}, {"role": "assistant", "content": "void test(const operation::BLS_GenerateKeyPair& op, const std::optional<component::BLS_KeyPair>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_Decompress_G1 code for tests.cpp"}, {"role": "assistant", "content": "void test(const operation::BLS_Decompress_G1& op, const std::optional<component::G1>& result) {\n    (void)op;\n    (void)result;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate Digest code for operations.h"}, {"role": "assistant", "content": "class Digest : public Operation {\n    public:\n        const component::Cleartext cleartext;\n        const component::DigestType digestType;\n\n        Digest(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            cleartext(ds),\n            digestType(ds)\n        { }\n\n        Digest(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            cleartext(json[\"cleartext\"]),\n            digestType(json[\"digestType\"])\n        { }\n\n\n        static size_t MaxOperations(void) { return 20; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        std::string GetAlgorithmString(void) const override {\n            return repository::DigestToString(digestType.Get());\n        }\n        inline bool operator==(const Digest& rhs) const {\n            return\n                (cleartext == rhs.cleartext) &&\n                (digestType == rhs.digestType) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            cleartext.Serialize(ds);\n            digestType.Serialize(ds);\n        }\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate HMAC code for operations.h"}, {"role": "assistant", "content": "class HMAC : public Operation {\n    public:\n        const component::Cleartext cleartext;\n        const component::DigestType digestType;\n        const component::SymmetricCipher cipher;\n\n        HMAC(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            cleartext(ds),\n            digestType(ds),\n            cipher(ds)\n        { }\n        HMAC(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            cleartext(json[\"cleartext\"]),\n            digestType(json[\"digestType\"]),\n            cipher(json[\"cipher\"])\n        { }\n\n        static size_t MaxOperations(void) { return 20; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        std::string GetAlgorithmString(void) const override {\n            return repository::DigestToString(digestType.Get());\n        }\n        inline bool operator==(const HMAC& rhs) const {\n            return\n                (cleartext == rhs.cleartext) &&\n                (digestType == rhs.digestType) &&\n                (cipher == rhs.cipher) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            cleartext.Serialize(ds);\n            digestType.Serialize(ds);\n            cipher.Serialize(ds);\n        }\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate UMAC code for operations.h"}, {"role": "assistant", "content": "class UMAC : public Operation {\n    public:\n        const component::Cleartext cleartext;\n        const component::Cleartext key;\n        const component::Cleartext iv;\n        uint8_t type;\n        const uint64_t outSize;\n\n        UMAC(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            cleartext(ds),\n            key(ds),\n            iv(ds),\n            type(ds.Get<uint64_t>() % 4),\n            outSize(ds.Get<uint64_t>() % 1024)\n        { }\n        UMAC(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            cleartext(json[\"cleartext\"]),\n            key(json[\"key\"]),\n            iv(json[\"iv\"]),\n            type(json[\"type\"].get<uint64_t>()),\n            outSize(json[\"outSize\"].get<uint64_t>())\n        { }\n\n        static size_t MaxOperations(void) { return 20; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const UMAC& rhs) const {\n            return\n                (cleartext == rhs.cleartext) &&\n                (key == rhs.key) &&\n                (iv == rhs.iv) &&\n                (type == rhs.type) &&\n                (outSize == rhs.outSize) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            cleartext.Serialize(ds);\n            key.Serialize(ds);\n            iv.Serialize(ds);\n            ds.Put<>(type);\n            ds.Put<>(outSize);\n        }\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate SymmetricEncrypt code for operations.h"}, {"role": "assistant", "content": "class SymmetricEncrypt : public Operation {\n    public:\n        const component::Cleartext cleartext;\n        const component::SymmetricCipher cipher;\n        const std::optional<component::AAD> aad;\n\n        const uint64_t ciphertextSize;\n        const std::optional<uint64_t> tagSize;\n\n        SymmetricEncrypt(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            cleartext(ds),\n            cipher(ds),\n            aad(ds.Get<bool>() ? std::nullopt : std::make_optional<component::AAD>(ds)),\n            ciphertextSize(ds.Get<uint64_t>() % (10*1024*1024)),\n            tagSize( ds.Get<bool>() ?\n                    std::nullopt :\n                    std::make_optional<uint64_t>(ds.Get<uint64_t>() % (10*1024*1024)) )\n        { }\n        SymmetricEncrypt(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            cleartext(json[\"cleartext\"]),\n            cipher(json[\"cipher\"]),\n            aad(\n                    json[\"aad_enabled\"].get<bool>() ?\n                        std::optional<component::AAD>(json[\"aad\"]) :\n                        std::optional<component::AAD>(std::nullopt)\n            ),\n            ciphertextSize(json[\"ciphertextSize\"].get<uint64_t>()),\n            tagSize(\n                    json[\"tagSize_enabled\"].get<bool>() ?\n                        std::optional<uint64_t>(json[\"tagSize\"].get<uint64_t>()) :\n                        std::optional<uint64_t>(std::nullopt)\n            )\n        { }\n\n        static size_t MaxOperations(void) { return 20; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        std::string GetAlgorithmString(void) const override {\n            return repository::CipherToString(cipher.cipherType.Get());\n        }\n        inline bool operator==(const SymmetricEncrypt& rhs) const {\n            return\n                (cleartext == rhs.cleartext) &&\n                (cipher == rhs.cipher) &&\n                (aad == rhs.aad) &&\n                (ciphertextSize == rhs.ciphertextSize) &&\n                (tagSize == rhs.tagSize) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            cleartext.Serialize(ds);\n            cipher.Serialize(ds);\n            if ( aad == std::nullopt ) {\n                ds.Put<bool>(true);\n            } else {\n                ds.Put<bool>(false);\n                aad->Serialize(ds);\n            }\n            ds.Put<>(ciphertextSize);\n            if ( tagSize == std::nullopt ) {\n                ds.Put<bool>(true);\n            } else {\n                ds.Put<bool>(false);\n                ds.Put<>(*tagSize);\n            }\n        }\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate SymmetricDecrypt code for operations.h"}, {"role": "assistant", "content": "class SymmetricDecrypt : public Operation {\n    public:\n        const Buffer ciphertext;\n        const component::SymmetricCipher cipher;\n        const std::optional<component::Tag> tag;\n        const std::optional<component::AAD> aad;\n\n        const uint64_t cleartextSize;\n\n        SymmetricDecrypt(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            ciphertext(ds),\n            cipher(ds),\n            tag(ds.Get<bool>() ? std::nullopt : std::make_optional<component::Tag>(ds)),\n            aad(ds.Get<bool>() ? std::nullopt : std::make_optional<component::AAD>(ds)),\n            cleartextSize(ds.Get<uint64_t>() % (10*1024*1024))\n        { }\n        SymmetricDecrypt(const SymmetricEncrypt& opSymmetricEncrypt, const component::Ciphertext ciphertext, const uint64_t cleartextSize, std::optional<component::AAD> aad, component::Modifier modifier);\n        SymmetricDecrypt(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            ciphertext(json[\"ciphertext\"]),\n            cipher(json[\"cipher\"]),\n            tag(\n                    json[\"tag_enabled\"].get<bool>() ?\n                        std::optional<component::Tag>(json[\"tag\"]) :\n                        std::optional<component::Tag>(std::nullopt)\n            ),\n            aad(\n                    json[\"aad_enabled\"].get<bool>() ?\n                        std::optional<component::AAD>(json[\"aad\"]) :\n                        std::optional<component::AAD>(std::nullopt)\n            ),\n            cleartextSize(json[\"cleartextSize\"].get<uint64_t>())\n        { }\n\n        static size_t MaxOperations(void) { return 20; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        std::string GetAlgorithmString(void) const override {\n            return repository::CipherToString(cipher.cipherType.Get());\n        }\n        inline bool operator==(const SymmetricDecrypt& rhs) const {\n            return\n                (ciphertext == rhs.ciphertext) &&\n                (cipher == rhs.cipher) &&\n                (tag == rhs.tag) &&\n                (aad == rhs.aad) &&\n                (cleartextSize == rhs.cleartextSize) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            ciphertext.Serialize(ds);\n            cipher.Serialize(ds);\n            if ( tag == std::nullopt ) {\n                ds.Put<bool>(true);\n            } else {\n                ds.Put<bool>(false);\n                tag->Serialize(ds);\n            }\n            if ( aad == std::nullopt ) {\n                ds.Put<bool>(true);\n            } else {\n                ds.Put<bool>(false);\n                aad->Serialize(ds);\n            }\n            ds.Put<>(cleartextSize);\n        }\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_SCRYPT code for operations.h"}, {"role": "assistant", "content": "class KDF_SCRYPT : public Operation {\n    public:\n        const component::Cleartext password;\n        const component::Cleartext salt;\n        const uint64_t N;\n        const uint64_t r;\n        const uint64_t p;\n\n        const uint64_t keySize;\n\n        KDF_SCRYPT(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            password(ds),\n            salt(ds),\n            N(ds.Get<uint64_t>() % 5),\n            r(ds.Get<uint64_t>() % 9),\n            p(ds.Get<uint64_t>() % 5),\n            keySize(ds.Get<uint64_t>() % 1024)\n        { }\n        KDF_SCRYPT(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            password(json[\"password\"]),\n            salt(json[\"salt\"]),\n            N(json[\"N\"].get<uint64_t>()),\n            r(json[\"r\"].get<uint64_t>()),\n            p(json[\"p\"].get<uint64_t>()),\n            keySize(json[\"keySize\"].get<uint64_t>())\n        { }\n\n        static size_t MaxOperations(void) { return 20; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const KDF_SCRYPT& rhs) const {\n            return\n                (password == rhs.password) &&\n                (salt == rhs.salt) &&\n                (N == rhs.N) &&\n                (r == rhs.r) &&\n                (p == rhs.p) &&\n                (keySize == rhs.keySize) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            password.Serialize(ds);\n            salt.Serialize(ds);\n            ds.Put<>(N);\n            ds.Put<>(r);\n            ds.Put<>(p);\n            ds.Put<>(keySize);\n        }\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_HKDF code for operations.h"}, {"role": "assistant", "content": "class KDF_HKDF : public Operation {\n    public:\n        const component::DigestType digestType;\n        const component::Cleartext password;\n        const component::Cleartext salt;\n        const component::Cleartext info;\n\n        const uint64_t keySize;\n\n        KDF_HKDF(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            digestType(ds),\n            password(ds),\n            salt(ds),\n            info(ds),\n            keySize(ds.Get<uint64_t>() % 17000)\n        { }\n        KDF_HKDF(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            digestType(json[\"digestType\"]),\n            password(json[\"password\"]),\n            salt(json[\"salt\"]),\n            info(json[\"info\"]),\n            keySize(json[\"keySize\"].get<uint64_t>())\n        { }\n\n        static size_t MaxOperations(void) { return 20; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const KDF_HKDF& rhs) const {\n            return\n                (digestType == rhs.digestType) &&\n                (password == rhs.password) &&\n                (salt == rhs.salt) &&\n                (info == rhs.info) &&\n                (keySize == rhs.keySize) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            digestType.Serialize(ds);\n            password.Serialize(ds);\n            salt.Serialize(ds);\n            info.Serialize(ds);\n            ds.Put<>(keySize);\n        }\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_TLS1_PRF code for operations.h"}, {"role": "assistant", "content": "class KDF_TLS1_PRF : public Operation {\n    public:\n        const component::DigestType digestType;\n        const component::Cleartext secret;\n        const component::Cleartext seed;\n\n        const uint64_t keySize;\n\n        KDF_TLS1_PRF(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            digestType(ds),\n            secret(ds),\n            seed(ds),\n            keySize(ds.Get<uint64_t>() % 1024)\n        { }\n        KDF_TLS1_PRF(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            digestType(json[\"digestType\"]),\n            secret(json[\"secret\"]),\n            seed(json[\"seed\"]),\n            keySize(json[\"keySize\"].get<uint64_t>())\n        { }\n\n        static size_t MaxOperations(void) { return 20; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const KDF_TLS1_PRF& rhs) const {\n            return\n                (digestType == rhs.digestType) &&\n                (secret == rhs.secret) &&\n                (seed == rhs.seed) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            digestType.Serialize(ds);\n            secret.Serialize(ds);\n            seed.Serialize(ds);\n            ds.Put<>(keySize);\n        }\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_PBKDF code for operations.h"}, {"role": "assistant", "content": "class KDF_PBKDF : public Operation {\n    public:\n        const component::DigestType digestType;\n        const component::Cleartext password;\n        const component::Cleartext salt;\n        const uint64_t iterations;\n\n        const uint64_t keySize;\n\n        KDF_PBKDF(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            digestType(ds),\n            password(ds),\n            salt(ds),\n            iterations(ds.Get<uint64_t>() % 5),\n            keySize(ds.Get<uint64_t>() % 1024)\n        { }\n        KDF_PBKDF(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            digestType(json[\"digestType\"]),\n            password(json[\"password\"]),\n            salt(json[\"salt\"]),\n            iterations(json[\"iterations\"].get<uint64_t>()),\n            keySize(json[\"keySize\"].get<uint64_t>())\n        { }\n\n        static size_t MaxOperations(void) { return 20; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const KDF_PBKDF& rhs) const {\n            return\n                (digestType == rhs.digestType) &&\n                (password == rhs.password) &&\n                (salt == rhs.salt) &&\n                (iterations == rhs.iterations) &&\n                (keySize == rhs.keySize) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            digestType.Serialize(ds);\n            password.Serialize(ds);\n            salt.Serialize(ds);\n            ds.Put<>(iterations);\n            ds.Put<>(keySize);\n        }\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_PBKDF1 code for operations.h"}, {"role": "assistant", "content": "class KDF_PBKDF1 : public Operation {\n    public:\n        const component::DigestType digestType;\n        const component::Cleartext password;\n        const component::Cleartext salt;\n        const uint64_t iterations;\n\n        const uint64_t keySize;\n\n        KDF_PBKDF1(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            digestType(ds),\n            password(ds),\n            salt(ds),\n            iterations(ds.Get<uint64_t>() % 5),\n            keySize(ds.Get<uint64_t>() % 1024)\n        { }\n        KDF_PBKDF1(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            digestType(json[\"digestType\"]),\n            password(json[\"password\"]),\n            salt(json[\"salt\"]),\n            iterations(json[\"iterations\"].get<uint64_t>()),\n            keySize(json[\"keySize\"].get<uint64_t>())\n        { }\n\n        static size_t MaxOperations(void) { return 20; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const KDF_PBKDF1& rhs) const {\n            return\n                (digestType == rhs.digestType) &&\n                (password == rhs.password) &&\n                (salt == rhs.salt) &&\n                (iterations == rhs.iterations) &&\n                (keySize == rhs.keySize) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            digestType.Serialize(ds);\n            password.Serialize(ds);\n            salt.Serialize(ds);\n            ds.Put<>(iterations);\n            ds.Put<>(keySize);\n        }\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_PBKDF2 code for operations.h"}, {"role": "assistant", "content": "class KDF_PBKDF2 : public Operation {\n    public:\n        const component::DigestType digestType;\n        const component::Cleartext password;\n        const component::Cleartext salt;\n        const uint64_t iterations;\n\n        const uint64_t keySize;\n\n        KDF_PBKDF2(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            digestType(ds),\n            password(ds),\n            salt(ds),\n            iterations(ds.Get<uint64_t>() % 5),\n            keySize(ds.Get<uint64_t>() % 1024)\n        { }\n        KDF_PBKDF2(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            digestType(json[\"digestType\"]),\n            password(json[\"password\"]),\n            salt(json[\"salt\"]),\n            iterations(json[\"iterations\"].get<uint64_t>()),\n            keySize(json[\"keySize\"].get<uint64_t>())\n        { }\n\n        static size_t MaxOperations(void) { return 20; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const KDF_PBKDF2& rhs) const {\n            return\n                (digestType == rhs.digestType) &&\n                (password == rhs.password) &&\n                (salt == rhs.salt) &&\n                (iterations == rhs.iterations) &&\n                (keySize == rhs.keySize) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            digestType.Serialize(ds);\n            password.Serialize(ds);\n            salt.Serialize(ds);\n            ds.Put<>(iterations);\n            ds.Put<>(keySize);\n        }\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_ARGON2 code for operations.h"}, {"role": "assistant", "content": "class KDF_ARGON2 : public Operation {\n    public:\n        const component::Cleartext password;\n        const component::Cleartext salt;\n        const uint8_t type;\n        const uint8_t threads;\n        const uint32_t memory;\n        const uint32_t iterations;\n        const uint32_t keySize;\n\n        KDF_ARGON2(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            password(ds),\n            salt(ds),\n            type(ds.Get<uint8_t>()),\n            threads(ds.Get<uint8_t>()),\n            memory(ds.Get<uint32_t>() % (64*1024)),\n            iterations(ds.Get<uint32_t>() % 3),\n            keySize(ds.Get<uint32_t>() % 1024)\n        { }\n        KDF_ARGON2(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            password(json[\"password\"]),\n            salt(json[\"salt\"]),\n            type(json[\"type\"].get<uint8_t>()),\n            threads(json[\"threads\"].get<uint8_t>()),\n            memory(json[\"memory\"].get<uint32_t>()),\n            iterations(json[\"iterations\"].get<uint32_t>()),\n            keySize(json[\"keySize\"].get<uint32_t>())\n        { }\n\n        static size_t MaxOperations(void) { return 3; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const KDF_ARGON2& rhs) const {\n            return\n                (password == rhs.password) &&\n                (salt == rhs.salt) &&\n                (type == rhs.type) &&\n                (threads == rhs.threads) &&\n                (memory == rhs.memory) &&\n                (iterations == rhs.iterations) &&\n                (keySize == rhs.keySize) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            password.Serialize(ds);\n            salt.Serialize(ds);\n            ds.Put<>(type);\n            ds.Put<>(threads);\n            ds.Put<>(memory);\n            ds.Put<>(iterations);\n            ds.Put<>(keySize);\n        }\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_SSH code for operations.h"}, {"role": "assistant", "content": "class KDF_SSH : public Operation {\n    public:\n        const component::DigestType digestType;\n        const component::Cleartext key;\n        const component::Cleartext xcghash;\n        const component::Cleartext session_id;\n        const component::Cleartext type;\n        const uint64_t keySize;\n\n        KDF_SSH(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            digestType(ds),\n            key(ds),\n            xcghash(ds),\n            session_id(ds),\n            type(ds),\n            keySize(ds.Get<uint64_t>() % 1024)\n        { }\n        KDF_SSH(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            digestType(json[\"digestType\"]),\n            key(json[\"key\"]),\n            xcghash(json[\"xcghash\"]),\n            session_id(json[\"session_id\"]),\n            type(json[\"type\"]),\n            keySize(json[\"keySize\"].get<uint64_t>())\n        { }\n\n        static size_t MaxOperations(void) { return 20; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const KDF_SSH& rhs) const {\n            return\n                (digestType == rhs.digestType) &&\n                (key == rhs.key) &&\n                (xcghash == rhs.xcghash) &&\n                (session_id == rhs.session_id) &&\n                (type == rhs.type) &&\n                (keySize == rhs.keySize) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            digestType.Serialize(ds);\n            key.Serialize(ds);\n            xcghash.Serialize(ds);\n            session_id.Serialize(ds);\n            type.Serialize(ds);\n            ds.Put<>(keySize);\n        }\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_X963 code for operations.h"}, {"role": "assistant", "content": "class KDF_X963 : public Operation {\n    public:\n        const component::DigestType digestType;\n        const component::Cleartext secret;\n        const component::Cleartext info;\n        const uint64_t keySize;\n\n        KDF_X963(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            digestType(ds),\n            secret(ds),\n            info(ds),\n            keySize(ds.Get<uint64_t>() % 1024)\n        { }\n        KDF_X963(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            digestType(json[\"digestType\"]),\n            secret(json[\"secret\"]),\n            info(json[\"info\"]),\n            keySize(json[\"keySize\"].get<uint64_t>())\n        { }\n\n        static size_t MaxOperations(void) { return 20; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const KDF_X963& rhs) const {\n            return\n                (digestType == rhs.digestType) &&\n                (secret == rhs.secret) &&\n                (info == rhs.info) &&\n                (keySize == rhs.keySize) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            digestType.Serialize(ds);\n            secret.Serialize(ds);\n            info.Serialize(ds);\n            ds.Put<>(keySize);\n        }\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_BCRYPT code for operations.h"}, {"role": "assistant", "content": "class KDF_BCRYPT : public Operation {\n    public:\n        const component::DigestType digestType;\n        const component::Cleartext secret;\n        const component::Cleartext salt;\n        const uint32_t iterations;\n        const uint64_t keySize;\n\n        KDF_BCRYPT(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            digestType(ds),\n            secret(ds),\n            salt(ds),\n            iterations(ds.Get<uint32_t>() % 3),\n            keySize(ds.Get<uint64_t>() % 1024)\n        { }\n        KDF_BCRYPT(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            digestType(json[\"digestType\"]),\n            secret(json[\"secret\"]),\n            salt(json[\"salt\"]),\n            iterations(json[\"iterations\"].get<uint32_t>()),\n            keySize(json[\"keySize\"].get<uint64_t>())\n        { }\n\n        static size_t MaxOperations(void) { return 2; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const KDF_BCRYPT& rhs) const {\n            return\n                (digestType == rhs.digestType) &&\n                (secret == rhs.secret) &&\n                (salt == rhs.salt) &&\n                (iterations == rhs.iterations) &&\n                (keySize == rhs.keySize) &&\n                (modifier == rhs.modifier);\n        }\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_SP_800_108 code for operations.h"}, {"role": "assistant", "content": "class KDF_SP_800_108 : public Operation {\n    public:\n        const component::MACType mech;\n        const component::Cleartext secret;\n        const component::Cleartext salt;\n        const component::Cleartext label;\n        const uint8_t mode;\n        const uint64_t keySize;\n\n        KDF_SP_800_108(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            mech(ds),\n            secret(ds),\n            salt(ds),\n            label(ds),\n            mode(ds.Get<uint8_t>()),\n            keySize(ds.Get<uint64_t>() % 17000)\n        { }\n        KDF_SP_800_108(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            mech(json[\"mech\"]),\n            secret(json[\"secret\"]),\n            salt(json[\"salt\"]),\n            label(json[\"label\"]),\n            mode(json[\"mode\"].get<uint8_t>()),\n            keySize(json[\"keySize\"].get<uint64_t>())\n        { }\n\n        static size_t MaxOperations(void) { return 20; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const KDF_SP_800_108& rhs) const {\n            return\n                (mech == rhs.mech) &&\n                (secret == rhs.secret) &&\n                (salt == rhs.salt) &&\n                (label == rhs.label) &&\n                (mode == rhs.mode) &&\n                (keySize == rhs.keySize) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            mech.Serialize(ds);\n            secret.Serialize(ds);\n            salt.Serialize(ds);\n            label.Serialize(ds);\n            ds.Put<>(mode);\n            ds.Put<>(keySize);\n        }\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_SRTP code for operations.h"}, {"role": "assistant", "content": "class KDF_SRTP : public Operation {\n    public:\n        const component::Cleartext key;\n        const component::Cleartext salt;\n        const uint8_t kdr;\n        const uint64_t index;\n        const uint64_t key1Size;\n        const uint64_t key2Size;\n        const uint64_t key3Size;\n\n        KDF_SRTP(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            key(ds),\n            salt(ds),\n            kdr(ds.Get<uint8_t>()),\n            index(ds.Get<uint64_t>()),\n            key1Size(ds.Get<uint64_t>() % (1024*1024)),\n            key2Size(ds.Get<uint64_t>() % (1024*1024)),\n            key3Size(ds.Get<uint64_t>() % (1024*1024))\n        { }\n        KDF_SRTP(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            key(json[\"key\"]),\n            salt(json[\"salt\"]),\n            kdr(json[\"kdr\"].get<uint8_t>()),\n            index(json[\"index\"].get<uint64_t>()),\n            key1Size(json[\"key1Size\"].get<uint64_t>()),\n            key2Size(json[\"key2Size\"].get<uint64_t>()),\n            key3Size(json[\"key3Size\"].get<uint64_t>())\n        { }\n\n        static size_t MaxOperations(void) { return 20; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const KDF_SRTP& rhs) const {\n            return\n                (key == rhs.key) &&\n                (salt == rhs.salt) &&\n                (kdr == rhs.kdr) &&\n                (index == rhs.index) &&\n                (key1Size == rhs.key1Size) &&\n                (key2Size == rhs.key2Size) &&\n                (key3Size == rhs.key3Size) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            key.Serialize(ds);\n            salt.Serialize(ds);\n            ds.Put<>(kdr);\n            ds.Put<>(key1Size);\n            ds.Put<>(key2Size);\n            ds.Put<>(key3Size);\n        }\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_SRTCP code for operations.h"}, {"role": "assistant", "content": "class KDF_SRTCP : public Operation {\n    public:\n        const component::Cleartext key;\n        const component::Cleartext salt;\n        const uint8_t kdr;\n        const uint32_t index;\n        const uint64_t key1Size;\n        const uint64_t key2Size;\n        const uint64_t key3Size;\n\n        KDF_SRTCP(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            key(ds),\n            salt(ds),\n            kdr(ds.Get<uint8_t>()),\n            index(ds.Get<uint32_t>()),\n            key1Size(ds.Get<uint64_t>() % (1024*1024)),\n            key2Size(ds.Get<uint64_t>() % (1024*1024)),\n            key3Size(ds.Get<uint64_t>() % (1024*1024))\n        { }\n        KDF_SRTCP(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            key(json[\"key\"]),\n            salt(json[\"salt\"]),\n            kdr(json[\"kdr\"].get<uint8_t>()),\n            index(json[\"index\"].get<uint32_t>()),\n            key1Size(json[\"key1Size\"].get<uint64_t>()),\n            key2Size(json[\"key2Size\"].get<uint64_t>()),\n            key3Size(json[\"key3Size\"].get<uint64_t>())\n        { }\n\n        static size_t MaxOperations(void) { return 20; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const KDF_SRTCP& rhs) const {\n            return\n                (key == rhs.key) &&\n                (salt == rhs.salt) &&\n                (kdr == rhs.kdr) &&\n                (index == rhs.index) &&\n                (key1Size == rhs.key1Size) &&\n                (key2Size == rhs.key2Size) &&\n                (key3Size == rhs.key3Size) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            key.Serialize(ds);\n            salt.Serialize(ds);\n            ds.Put<>(kdr);\n            ds.Put<>(key1Size);\n            ds.Put<>(key2Size);\n            ds.Put<>(key3Size);\n        }\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate CMAC code for operations.h"}, {"role": "assistant", "content": "class CMAC : public Operation {\n    public:\n        const component::Cleartext cleartext;\n        const component::SymmetricCipher cipher;\n\n        CMAC(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            cleartext(ds),\n            cipher(ds)\n        { }\n        CMAC(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            cleartext(json[\"cleartext\"]),\n            cipher(json[\"cipher\"])\n        { }\n\n        static size_t MaxOperations(void) { return 20; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const CMAC& rhs) const {\n            return\n                (cleartext == rhs.cleartext) &&\n                (cipher == rhs.cipher) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            cleartext.Serialize(ds);\n            cipher.Serialize(ds);\n        }\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_PrivateToPublic code for operations.h"}, {"role": "assistant", "content": "class ECC_PrivateToPublic : public Operation {\n    public:\n        const component::CurveType curveType;\n        const component::ECC_PrivateKey priv;\n\n        ECC_PrivateToPublic(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            priv(ds)\n        { }\n        ECC_PrivateToPublic(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            priv(json[\"priv\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const ECC_PrivateToPublic& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (priv == rhs.priv) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            priv.Serialize(ds);\n        }\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_ValidatePubkey code for operations.h"}, {"role": "assistant", "content": "class ECC_ValidatePubkey : public Operation {\n    public:\n        const component::CurveType curveType;\n        const component::ECC_PublicKey pub;\n\n        ECC_ValidatePubkey(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            pub(ds)\n        { }\n        ECC_ValidatePubkey(\n                const component::CurveType curveType,\n                const component::ECC_PublicKey& pub,\n                component::Modifier& modifier);\n        ECC_ValidatePubkey(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            pub(json[\"pub_x\"], json[\"pub_y\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const ECC_ValidatePubkey& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (pub == rhs.pub) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            pub.Serialize(ds);\n        }\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_GenerateKeyPair code for operations.h"}, {"role": "assistant", "content": "class ECC_GenerateKeyPair : public Operation {\n    public:\n        const component::CurveType curveType;\n\n        ECC_GenerateKeyPair(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds)\n        { }\n\n        ECC_GenerateKeyPair(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const ECC_GenerateKeyPair& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n        }\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECCSI_Sign code for operations.h"}, {"role": "assistant", "content": "class ECCSI_Sign : public Operation {\n    public:\n        const component::CurveType curveType;\n        const component::ECC_PrivateKey priv;\n        const component::Cleartext cleartext;\n        const component::Cleartext id;\n        const component::DigestType digestType;\n\n        ECCSI_Sign(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            priv(ds),\n            cleartext(ds),\n            id(ds),\n            digestType(ds)\n        { }\n        ECCSI_Sign(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            priv(json[\"priv\"]),\n            cleartext(json[\"cleartext\"]),\n            id(json[\"id\"]),\n            digestType(json[\"digestType\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const ECCSI_Sign& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (priv == rhs.priv) &&\n                (cleartext == rhs.cleartext) &&\n                (id == rhs.id) &&\n                (digestType == rhs.digestType ) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            priv.Serialize(ds);\n            cleartext.Serialize(ds);\n            id.Serialize(ds);\n            digestType.Serialize(ds);\n        }\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECDSA_Sign code for operations.h"}, {"role": "assistant", "content": "class ECDSA_Sign : public Operation {\n    public:\n        const component::CurveType curveType;\n        const component::ECC_PrivateKey priv;\n        const component::Bignum nonce;\n        const component::Cleartext cleartext;\n        const uint8_t nonceSource;\n        const component::DigestType digestType;\n\n        ECDSA_Sign(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            priv(ds),\n            nonce(ds),\n            cleartext(ds),\n            nonceSource(ds.Get<uint8_t>()),\n            digestType(ds)\n        { }\n        ECDSA_Sign(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            priv(json[\"priv\"]),\n            nonce(json[\"nonce\"]),\n            cleartext(json[\"cleartext\"]),\n            nonceSource(json[\"nonceSource\"].get<uint8_t>()),\n            digestType(json[\"digestType\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const ECDSA_Sign& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (priv == rhs.priv) &&\n                (nonce == rhs.nonce) &&\n                (cleartext == rhs.cleartext) &&\n                (nonceSource == rhs.nonceSource ) &&\n                (digestType == rhs.digestType ) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            priv.Serialize(ds);\n            nonce.Serialize(ds);\n            cleartext.Serialize(ds);\n            ds.Put<>(nonceSource);\n            digestType.Serialize(ds);\n        }\n        bool UseRandomNonce(void) const {\n            return nonceSource == 0;\n        }\n        bool UseRFC6979Nonce(void) const {\n            return nonceSource == 1;\n        }\n        bool UseSpecifiedNonce(void) const {\n            return nonceSource == 2;\n        }\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECGDSA_Sign code for operations.h"}, {"role": "assistant", "content": "class ECGDSA_Sign : public Operation {\n    public:\n        const component::CurveType curveType;\n        const component::ECC_PrivateKey priv;\n        const component::Bignum nonce;\n        const component::Cleartext cleartext;\n        const uint8_t nonceSource;\n        const component::DigestType digestType;\n\n        ECGDSA_Sign(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            priv(ds),\n            nonce(ds),\n            cleartext(ds),\n            nonceSource(ds.Get<uint8_t>()),\n            digestType(ds)\n        { }\n        ECGDSA_Sign(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            priv(json[\"priv\"]),\n            nonce(json[\"nonce\"]),\n            cleartext(json[\"cleartext\"]),\n            nonceSource(json[\"nonceSource\"].get<uint8_t>()),\n            digestType(json[\"digestType\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const ECGDSA_Sign& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (priv == rhs.priv) &&\n                (nonce == rhs.nonce) &&\n                (cleartext == rhs.cleartext) &&\n                (nonceSource == rhs.nonceSource ) &&\n                (digestType == rhs.digestType ) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            priv.Serialize(ds);\n            nonce.Serialize(ds);\n            cleartext.Serialize(ds);\n            ds.Put<>(nonceSource);\n            digestType.Serialize(ds);\n        }\n        bool UseRandomNonce(void) const {\n            return nonceSource == 0;\n        }\n        bool UseRFC6979Nonce(void) const {\n            return nonceSource == 1;\n        }\n        bool UseSpecifiedNonce(void) const {\n            return nonceSource == 2;\n        }\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECRDSA_Sign code for operations.h"}, {"role": "assistant", "content": "class ECRDSA_Sign : public Operation {\n    public:\n        const component::CurveType curveType;\n        const component::ECC_PrivateKey priv;\n        const component::Bignum nonce;\n        const component::Cleartext cleartext;\n        const uint8_t nonceSource;\n        const component::DigestType digestType;\n\n        ECRDSA_Sign(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            priv(ds),\n            nonce(ds),\n            cleartext(ds),\n            nonceSource(ds.Get<uint8_t>()),\n            digestType(ds)\n        { }\n        ECRDSA_Sign(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            priv(json[\"priv\"]),\n            nonce(json[\"nonce\"]),\n            cleartext(json[\"cleartext\"]),\n            nonceSource(json[\"nonceSource\"].get<uint8_t>()),\n            digestType(json[\"digestType\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const ECRDSA_Sign& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (priv == rhs.priv) &&\n                (nonce == rhs.nonce) &&\n                (cleartext == rhs.cleartext) &&\n                (nonceSource == rhs.nonceSource ) &&\n                (digestType == rhs.digestType ) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            priv.Serialize(ds);\n            nonce.Serialize(ds);\n            cleartext.Serialize(ds);\n            ds.Put<>(nonceSource);\n            digestType.Serialize(ds);\n        }\n        bool UseRandomNonce(void) const {\n            return nonceSource == 0;\n        }\n        bool UseRFC6979Nonce(void) const {\n            return nonceSource == 1;\n        }\n        bool UseSpecifiedNonce(void) const {\n            return nonceSource == 2;\n        }\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate Schnorr_Sign code for operations.h"}, {"role": "assistant", "content": "class Schnorr_Sign : public Operation {\n    public:\n        const component::CurveType curveType;\n        const component::ECC_PrivateKey priv;\n        const component::Bignum nonce;\n        const component::Cleartext cleartext;\n        const uint8_t nonceSource;\n        const component::DigestType digestType;\n\n        Schnorr_Sign(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            priv(ds),\n            nonce(ds),\n            cleartext(ds),\n            nonceSource(ds.Get<uint8_t>()),\n            digestType(ds)\n        { }\n        Schnorr_Sign(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            priv(json[\"priv\"]),\n            nonce(json[\"nonce\"]),\n            cleartext(json[\"cleartext\"]),\n            nonceSource(json[\"nonceSource\"].get<uint8_t>()),\n            digestType(json[\"digestType\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const Schnorr_Sign& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (priv == rhs.priv) &&\n                (nonce == rhs.nonce) &&\n                (cleartext == rhs.cleartext) &&\n                (nonceSource == rhs.nonceSource ) &&\n                (digestType == rhs.digestType ) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            priv.Serialize(ds);\n            nonce.Serialize(ds);\n            cleartext.Serialize(ds);\n            ds.Put<>(nonceSource);\n            digestType.Serialize(ds);\n        }\n        bool UseRandomNonce(void) const {\n            return nonceSource == 0;\n        }\n        bool UseBIP340Nonce(void) const {\n            return nonceSource == 1;\n        }\n        bool UseSpecifiedNonce(void) const {\n            return nonceSource == 2;\n        }\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECCSI_Verify code for operations.h"}, {"role": "assistant", "content": "class ECCSI_Verify : public Operation {\n    public:\n        const component::CurveType curveType;\n        const component::Cleartext cleartext;\n        const component::Cleartext id;\n        const component::ECCSI_Signature signature;\n        const component::DigestType digestType;\n\n        ECCSI_Verify(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            cleartext(ds),\n            id(ds),\n            signature(ds),\n            digestType(ds)\n        { }\n        ECCSI_Verify(const ECCSI_Sign& opECCSI_Sign, const component::ECCSI_Signature signature, component::Modifier modifier);\n        ECCSI_Verify(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            cleartext(json[\"cleartext\"]),\n            id(json[\"id\"]),\n            signature(json[\"signature\"]),\n            digestType(json[\"digestType\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const ECCSI_Verify& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (cleartext == rhs.cleartext) &&\n                (id == rhs.id) &&\n                (signature == rhs.signature) &&\n                (digestType == rhs.digestType) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            cleartext.Serialize(ds);\n            id.Serialize(ds);\n            signature.Serialize(ds);\n            digestType.Serialize(ds);\n        }\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECDSA_Verify code for operations.h"}, {"role": "assistant", "content": "class ECDSA_Verify : public Operation {\n    public:\n        const component::CurveType curveType;\n        const component::Cleartext cleartext;\n        const component::ECDSA_Signature signature;\n        const component::DigestType digestType;\n\n        ECDSA_Verify(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            cleartext(ds),\n            signature(ds),\n            digestType(ds)\n        { }\n        ECDSA_Verify(const ECDSA_Sign& opECDSA_Sign, const component::ECDSA_Signature signature, component::Modifier modifier);\n        ECDSA_Verify(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            cleartext(json[\"cleartext\"]),\n            signature(json[\"signature\"]),\n            digestType(json[\"digestType\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const ECDSA_Verify& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (cleartext == rhs.cleartext) &&\n                (signature == rhs.signature) &&\n                (digestType == rhs.digestType) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            cleartext.Serialize(ds);\n            signature.Serialize(ds);\n            digestType.Serialize(ds);\n        }\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECGDSA_Verify code for operations.h"}, {"role": "assistant", "content": "class ECGDSA_Verify : public Operation {\n    public:\n        const component::CurveType curveType;\n        const component::Cleartext cleartext;\n        const component::ECGDSA_Signature signature;\n        const component::DigestType digestType;\n\n        ECGDSA_Verify(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            cleartext(ds),\n            signature(ds),\n            digestType(ds)\n        { }\n        ECGDSA_Verify(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            cleartext(json[\"cleartext\"]),\n            signature(json[\"signature\"]),\n            digestType(json[\"digestType\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const ECGDSA_Verify& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (cleartext == rhs.cleartext) &&\n                (signature == rhs.signature) &&\n                (digestType == rhs.digestType) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            cleartext.Serialize(ds);\n            signature.Serialize(ds);\n            digestType.Serialize(ds);\n        }\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECRDSA_Verify code for operations.h"}, {"role": "assistant", "content": "class ECRDSA_Verify : public Operation {\n    public:\n        const component::CurveType curveType;\n        const component::Cleartext cleartext;\n        const component::ECRDSA_Signature signature;\n        const component::DigestType digestType;\n\n        ECRDSA_Verify(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            cleartext(ds),\n            signature(ds),\n            digestType(ds)\n        { }\n        ECRDSA_Verify(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            cleartext(json[\"cleartext\"]),\n            signature(json[\"signature\"]),\n            digestType(json[\"digestType\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const ECRDSA_Verify& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (cleartext == rhs.cleartext) &&\n                (signature == rhs.signature) &&\n                (digestType == rhs.digestType) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            cleartext.Serialize(ds);\n            signature.Serialize(ds);\n            digestType.Serialize(ds);\n        }\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECDSA_Recover code for operations.h"}, {"role": "assistant", "content": "class ECDSA_Recover : public Operation {\n    public:\n        const component::CurveType curveType;\n        const component::Cleartext cleartext;\n        const component::BignumPair signature;\n        const component::DigestType digestType;\n        const uint8_t id;\n\n        ECDSA_Recover(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            cleartext(ds),\n            signature(ds),\n            digestType(ds),\n            id(ds.Get<uint8_t>())\n        { }\n        ECDSA_Recover(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            cleartext(json[\"cleartext\"]),\n            signature(json[\"signature\"]),\n            digestType(json[\"digestType\"]),\n            id(json[\"id\"].get<uint8_t>())\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const ECDSA_Recover& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (cleartext == rhs.cleartext) &&\n                (signature == rhs.signature) &&\n                (digestType == rhs.digestType) &&\n                (id == rhs.id) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            cleartext.Serialize(ds);\n            signature.Serialize(ds);\n            digestType.Serialize(ds);\n            ds.Put<>(id);\n        }\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate DSA_GenerateParameters code for operations.h"}, {"role": "assistant", "content": "class DSA_GenerateParameters : public Operation {\n    public:\n        DSA_GenerateParameters(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier))\n        { (void)ds; }\n        DSA_GenerateParameters(nlohmann::json json) :\n            Operation(json[\"modifier\"])\n        { }\n        DSA_GenerateParameters(component::Modifier modifier) :\n            Operation(std::move(modifier))\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const DSA_GenerateParameters& rhs) const {\n            return\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            (void)ds;\n        }\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate DSA_PrivateToPublic code for operations.h"}, {"role": "assistant", "content": "class DSA_PrivateToPublic : public Operation {\n    public:\n        const component::Bignum g;\n        const component::Bignum p;\n        const component::Bignum priv;\n\n        DSA_PrivateToPublic(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            g(ds),\n            p(ds),\n            priv(ds)\n        { }\n        DSA_PrivateToPublic(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            g(json[\"g\"]),\n            p(json[\"p\"]),\n            priv(json[\"priv\"])\n        { }\n        DSA_PrivateToPublic(\n                component::Modifier modifier,\n                component::Bignum g,\n                component::Bignum p,\n                component::Bignum priv) :\n            Operation(std::move(modifier)),\n            g(g),\n            p(p),\n            priv(priv)\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const DSA_PrivateToPublic& rhs) const {\n            return\n                (g == rhs.g) &&\n                (p == rhs.p) &&\n                (priv == rhs.priv) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            priv.Serialize(ds);\n        }\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate DSA_GenerateKeyPair code for operations.h"}, {"role": "assistant", "content": "class DSA_GenerateKeyPair : public Operation {\n    public:\n        const component::Bignum p;\n        const component::Bignum q;\n        const component::Bignum g;\n\n        DSA_GenerateKeyPair(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            p(ds),\n            q(ds),\n            g(ds)\n        { }\n        DSA_GenerateKeyPair(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            p(json[\"p\"]),\n            q(json[\"q\"]),\n            g(json[\"g\"])\n        { }\n        DSA_GenerateKeyPair(\n                component::Modifier modifier,\n                component::Bignum p,\n                component::Bignum q,\n                component::Bignum g) :\n            Operation(std::move(modifier)),\n            p(p),\n            q(q),\n            g(g)\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const DSA_GenerateKeyPair& rhs) const {\n            return\n                (p == rhs.p) &&\n                (q == rhs.q) &&\n                (g == rhs.g) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            p.Serialize(ds);\n            q.Serialize(ds);\n            g.Serialize(ds);\n        }\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate DSA_Sign code for operations.h"}, {"role": "assistant", "content": "class DSA_Sign : public Operation {\n    public:\n        const component::DSA_Parameters parameters;\n        const component::Bignum priv;\n        const component::Cleartext cleartext;\n\n        DSA_Sign(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            parameters(ds),\n            priv(ds),\n            cleartext(ds)\n        { }\n        DSA_Sign(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            parameters(json[\"parameters\"]),\n            priv(json[\"priv\"]),\n            cleartext(json[\"cleartext\"])\n        { }\n        DSA_Sign(\n                component::Modifier modifier,\n                component::DSA_Parameters parameters,\n                component::Bignum priv,\n                component::Cleartext cleartext) :\n            Operation(std::move(modifier)),\n            parameters(parameters),\n            priv(priv),\n            cleartext(cleartext)\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const DSA_Sign& rhs) const {\n            return\n                (parameters == rhs.parameters) &&\n                (priv == rhs.priv) &&\n                (cleartext == rhs.cleartext) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            parameters.Serialize(ds);\n            priv.Serialize(ds);\n            cleartext.Serialize(ds);\n        }\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate DSA_Verify code for operations.h"}, {"role": "assistant", "content": "class DSA_Verify : public Operation {\n    public:\n        const component::DSA_Parameters parameters;\n        const component::Bignum pub;\n        const component::BignumPair signature;\n        const component::Cleartext cleartext;\n\n        DSA_Verify(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            parameters(ds),\n            pub(ds),\n            signature(ds),\n            cleartext(ds)\n        { }\n        DSA_Verify(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            parameters(json[\"parameters\"]),\n            pub(json[\"pub\"]),\n            signature(json[\"signature\"]),\n            cleartext(json[\"cleartext\"])\n        { }\n        DSA_Verify(\n                component::Modifier modifier,\n                component::DSA_Parameters parameters,\n                component::Bignum pub,\n                component::BignumPair signature,\n                component::Cleartext cleartext) :\n            Operation(std::move(modifier)),\n            parameters(parameters),\n            pub(pub),\n            signature(signature),\n            cleartext(cleartext)\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const DSA_Verify& rhs) const {\n            return\n                (parameters == rhs.parameters) &&\n                (pub == rhs.pub) &&\n                (signature == rhs.signature) &&\n                (cleartext == rhs.cleartext) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            parameters.Serialize(ds);\n            pub.Serialize(ds);\n            signature.Serialize(ds);\n            cleartext.Serialize(ds);\n        }\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate Schnorr_Verify code for operations.h"}, {"role": "assistant", "content": "class Schnorr_Verify : public Operation {\n    public:\n        const component::CurveType curveType;\n        const component::Cleartext cleartext;\n        const component::ECDSA_Signature signature;\n        const component::DigestType digestType;\n\n        Schnorr_Verify(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            cleartext(ds),\n            signature(ds),\n            digestType(ds)\n        { }\n        Schnorr_Verify(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            cleartext(json[\"cleartext\"]),\n            signature(json[\"signature\"]),\n            digestType(json[\"digestType\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const Schnorr_Verify& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (cleartext == rhs.cleartext) &&\n                (signature == rhs.signature) &&\n                (digestType == rhs.digestType) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            cleartext.Serialize(ds);\n            signature.Serialize(ds);\n            digestType.Serialize(ds);\n        }\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECDH_Derive code for operations.h"}, {"role": "assistant", "content": "class ECDH_Derive : public Operation {\n    public:\n        const component::CurveType curveType;\n        const component::ECC_PrivateKey priv;\n        const component::ECC_PublicKey pub;\n\n        ECDH_Derive(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            priv(ds),\n            pub(ds)\n        { }\n        ECDH_Derive(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            priv(json[\"priv\"]),\n            pub(json[\"pub_x\"], json[\"pub_y\"])\n        { }\n        ECDH_Derive(\n                component::Modifier modifier,\n                component::CurveType curveType,\n                component::ECC_PrivateKey priv,\n                component::ECC_PublicKey pub) :\n            Operation(std::move(modifier)),\n            curveType(curveType),\n            priv(priv),\n            pub(pub)\n        { }\n\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const ECDH_Derive& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (priv == rhs.priv) &&\n                (pub == rhs.pub) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            priv.Serialize(ds);\n            pub.Serialize(ds);\n        }\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECIES_Encrypt code for operations.h"}, {"role": "assistant", "content": "class ECIES_Encrypt : public Operation {\n    public:\n        const component::Cleartext cleartext;\n        const component::CurveType curveType;\n        const component::ECC_PrivateKey priv;\n        const component::ECC_PublicKey pub;\n        const component::SymmetricCipherType cipherType;\n        const std::optional<component::SymmetricIV> iv;\n        /* TODO kdf type */\n        /* TODO mac type */\n\n        ECIES_Encrypt(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            cleartext(ds),\n            curveType(ds),\n            priv(ds),\n            pub(ds),\n            cipherType(ds),\n            iv(ds.Get<bool>() ? std::nullopt : std::make_optional<component::SymmetricIV>(ds))\n        { }\n        ECIES_Encrypt(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            cleartext(json[\"cleartext\"]),\n            curveType(json[\"curveType\"]),\n            priv(json[\"priv\"]),\n            pub(json[\"pub_x\"], json[\"pub_y\"]),\n            cipherType(json[\"cipherType\"]),\n            iv(\n                    json[\"iv_enabled\"].get<bool>() ?\n                        std::optional<component::SymmetricIV>(json[\"iv\"]) :\n                        std::optional<component::SymmetricIV>(std::nullopt)\n            )\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const ECIES_Encrypt& rhs) const {\n            return\n                (cleartext == rhs.cleartext) &&\n                (curveType == rhs.curveType) &&\n                (priv == rhs.priv) &&\n                (pub == rhs.pub) &&\n                (cipherType == rhs.cipherType) &&\n                (iv == rhs.iv) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            cleartext.Serialize(ds);\n            curveType.Serialize(ds);\n            priv.Serialize(ds);\n            pub.Serialize(ds);\n            cipherType.Serialize(ds);\n            if ( iv == std::nullopt ) {\n                ds.Put<bool>(true);\n            } else {\n                ds.Put<bool>(false);\n                iv->Serialize(ds);\n            }\n        }\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECIES_Decrypt code for operations.h"}, {"role": "assistant", "content": "class ECIES_Decrypt : public Operation {\n    public:\n        const Buffer ciphertext;\n        const component::CurveType curveType;\n        const component::ECC_PrivateKey priv;\n        const component::ECC_PublicKey pub;\n        const component::SymmetricCipherType cipherType;\n        const std::optional<component::SymmetricIV> iv;\n        /* TODO kdf type */\n        /* TODO mac type */\n\n        ECIES_Decrypt(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            ciphertext(ds),\n            curveType(ds),\n            priv(ds),\n            pub(ds),\n            cipherType(ds),\n            iv(ds.Get<bool>() ? std::nullopt : std::make_optional<component::SymmetricIV>(ds))\n        { }\n        ECIES_Decrypt(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            ciphertext(json[\"ciphertext\"]),\n            curveType(json[\"curveType\"]),\n            priv(json[\"priv\"]),\n            pub(json[\"pub_x\"], json[\"pub_y\"]),\n            cipherType(json[\"cipherType\"]),\n            iv(\n                    json[\"iv_enabled\"].get<bool>() ?\n                        std::optional<component::SymmetricIV>(json[\"iv\"]) :\n                        std::optional<component::SymmetricIV>(std::nullopt)\n            )\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const ECIES_Decrypt& rhs) const {\n            return\n                (ciphertext == rhs.ciphertext) &&\n                (curveType == rhs.curveType) &&\n                (priv == rhs.priv) &&\n                (pub == rhs.pub) &&\n                (cipherType == rhs.cipherType) &&\n                (iv == rhs.iv) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            ciphertext.Serialize(ds);\n            curveType.Serialize(ds);\n            priv.Serialize(ds);\n            pub.Serialize(ds);\n            cipherType.Serialize(ds);\n            if ( iv == std::nullopt ) {\n                ds.Put<bool>(true);\n            } else {\n                ds.Put<bool>(false);\n                iv->Serialize(ds);\n            }\n        }\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_Point_Add code for operations.h"}, {"role": "assistant", "content": "class ECC_Point_Add : public Operation {\n    public:\n        const component::CurveType curveType;\n        const component::ECC_Point a, b;\n\n        ECC_Point_Add(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            a(ds),\n            b(ds)\n        { }\n        ECC_Point_Add(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            a(json[\"a_x\"], json[\"a_y\"]),\n            b(json[\"b_x\"], json[\"b_y\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const ECC_Point_Add& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (a == rhs.a) &&\n                (b == rhs.b) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            a.Serialize(ds);\n            b.Serialize(ds);\n        }\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_Point_Sub code for operations.h"}, {"role": "assistant", "content": "class ECC_Point_Sub : public Operation {\n    public:\n        const component::CurveType curveType;\n        const component::ECC_Point a, b;\n\n        ECC_Point_Sub(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            a(ds),\n            b(ds)\n        { }\n        ECC_Point_Sub(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            a(json[\"a_x\"], json[\"a_y\"]),\n            b(json[\"b_x\"], json[\"b_y\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const ECC_Point_Sub& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (a == rhs.a) &&\n                (b == rhs.b) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            a.Serialize(ds);\n            b.Serialize(ds);\n        }\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_Point_Mul code for operations.h"}, {"role": "assistant", "content": "class ECC_Point_Mul : public Operation {\n    public:\n        const component::CurveType curveType;\n        const component::ECC_Point a;\n        const component::Bignum b;\n\n        ECC_Point_Mul(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            a(ds),\n            b(ds)\n        { }\n        ECC_Point_Mul(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            a(json[\"a_x\"], json[\"a_y\"]),\n            b(json[\"b\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const ECC_Point_Mul& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (a == rhs.a) &&\n                (b == rhs.b) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            a.Serialize(ds);\n            b.Serialize(ds);\n        }\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_Point_Neg code for operations.h"}, {"role": "assistant", "content": "class ECC_Point_Neg : public Operation {\n    public:\n        const component::CurveType curveType;\n        const component::ECC_Point a;\n\n        ECC_Point_Neg(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            a(ds)\n        { }\n        ECC_Point_Neg(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            a(json[\"a_x\"], json[\"a_y\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const ECC_Point_Neg& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (a == rhs.a) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            a.Serialize(ds);\n        }\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_Point_Dbl code for operations.h"}, {"role": "assistant", "content": "class ECC_Point_Dbl : public Operation {\n    public:\n        const component::CurveType curveType;\n        const component::ECC_Point a;\n\n        ECC_Point_Dbl(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            a(ds)\n        { }\n        ECC_Point_Dbl(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            a(json[\"a_x\"], json[\"a_y\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const ECC_Point_Dbl& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (a == rhs.a) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            a.Serialize(ds);\n        }\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_Point_Cmp code for operations.h"}, {"role": "assistant", "content": "class ECC_Point_Cmp : public Operation {\n    public:\n        const component::CurveType curveType;\n        const component::ECC_Point a, b;\n\n        ECC_Point_Cmp(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            a(ds),\n            b(ds)\n        { }\n        ECC_Point_Cmp(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            a(json[\"a_x\"], json[\"a_y\"]),\n            b(json[\"b_x\"], json[\"b_y\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const ECC_Point_Cmp& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (a == rhs.a) &&\n                (b == rhs.b) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            a.Serialize(ds);\n            b.Serialize(ds);\n        }\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate DH_GenerateKeyPair code for operations.h"}, {"role": "assistant", "content": "class DH_GenerateKeyPair : public Operation {\n    public:\n        const component::Bignum prime;\n        const component::Bignum base;\n\n        DH_GenerateKeyPair(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            prime(ds),\n            base(ds)\n        { }\n        DH_GenerateKeyPair(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            prime(json[\"prime\"]),\n            base(json[\"base\"])\n        { }\n        DH_GenerateKeyPair(\n                component::Modifier modifier,\n                component::Bignum prime,\n                component::Bignum base) :\n            Operation(std::move(modifier)),\n            prime(prime),\n            base(base)\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const DH_GenerateKeyPair& rhs) const {\n            return\n                (prime == rhs.prime) &&\n                (base  == rhs.base) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            prime.Serialize(ds);\n            base.Serialize(ds);\n        }\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate DH_Derive code for operations.h"}, {"role": "assistant", "content": "class DH_Derive : public Operation {\n    public:\n        const component::Bignum prime;\n        const component::Bignum base;\n        const component::Bignum pub;\n        const component::Bignum priv;\n\n        DH_Derive(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            prime(ds),\n            base(ds),\n            pub(ds),\n            priv(ds)\n        { }\n        DH_Derive(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            prime(json[\"prime\"]),\n            base(json[\"base\"]),\n            pub(json[\"pub\"]),\n            priv(json[\"priv\"])\n        { }\n        DH_Derive(\n                component::Modifier modifier,\n                component::Bignum prime,\n                component::Bignum base,\n                component::Bignum pub,\n                component::Bignum priv) :\n            Operation(std::move(modifier)),\n            prime(prime),\n            base(base),\n            pub(pub),\n            priv(priv)\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const DH_Derive& rhs) const {\n            return\n                (prime == rhs.prime) &&\n                (base  == rhs.base) &&\n                (pub == rhs.pub) &&\n                (priv == rhs.priv) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            prime.Serialize(ds);\n            base.Serialize(ds);\n            pub.Serialize(ds);\n            priv.Serialize(ds);\n        }\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc code for operations.h"}, {"role": "assistant", "content": "class BignumCalc : public Operation {\n    public:\n        const component::CalcOp calcOp;\n        const component::Bignum bn0;\n        const component::Bignum bn1;\n        const component::Bignum bn2;\n        const component::Bignum bn3;\n        std::optional<component::Bignum> modulo;\n\n        BignumCalc(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            calcOp(ds),\n            bn0(ds),\n            bn1(ds),\n            bn2(ds),\n            bn3(ds)\n        { }\n        BignumCalc(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            calcOp(json[\"calcOp\"]),\n            bn0(json[\"bn1\"]),\n            bn1(json[\"bn2\"]),\n            bn2(json[\"bn3\"]),\n            bn3(json[\"bn4\"])\n        { }\n        BignumCalc(\n                component::Modifier modifier,\n                component::CurveType calcOp,\n                component::Bignum bn0,\n                component::Bignum bn1,\n                component::Bignum bn2,\n                component::Bignum bn3) :\n            Operation(std::move(modifier)),\n            calcOp(calcOp),\n            bn0(bn0),\n            bn1(bn1),\n            bn2(bn2),\n            bn3(bn3)\n        { }\n\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const BignumCalc& rhs) const {\n            return\n                (calcOp == rhs.calcOp) &&\n                (bn0 == rhs.bn0) &&\n                (bn1 == rhs.bn1) &&\n                (bn2 == rhs.bn2) &&\n                (bn3 == rhs.bn3) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            calcOp.Serialize(ds);\n            bn0.Serialize(ds);\n            bn1.Serialize(ds);\n            bn2.Serialize(ds);\n            bn3.Serialize(ds);\n        }\n        void SetModulo(component::Bignum& modulo);\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Fp2 code for operations.h"}, {"role": "assistant", "content": "class BignumCalc_Fp2 : public Operation {\n    public:\n        const component::CalcOp calcOp;\n        const component::Fp2 bn0;\n        const component::Fp2 bn1;\n        const component::Fp2 bn2;\n        const component::Fp2 bn3;\n        std::optional<component::Fp2> modulo;\n\n        BignumCalc_Fp2(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            calcOp(ds),\n            bn0(ds),\n            bn1(ds),\n            bn2(ds),\n            bn3(ds)\n        { }\n        BignumCalc_Fp2(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            calcOp(json[\"calcOp\"]),\n            bn0(json[\"bn1\"]),\n            bn1(json[\"bn2\"]),\n            bn2(json[\"bn3\"]),\n            bn3(json[\"bn4\"])\n        { }\n        BignumCalc_Fp2(\n                component::Modifier modifier,\n                component::CurveType calcOp,\n                component::Fp2 bn0,\n                component::Fp2 bn1,\n                component::Fp2 bn2,\n                component::Fp2 bn3) :\n            Operation(std::move(modifier)),\n            calcOp(calcOp),\n            bn0(bn0),\n            bn1(bn1),\n            bn2(bn2),\n            bn3(bn3)\n        { }\n\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const BignumCalc_Fp2& rhs) const {\n            return\n                (calcOp == rhs.calcOp) &&\n                (bn0 == rhs.bn0) &&\n                (bn1 == rhs.bn1) &&\n                (bn2 == rhs.bn2) &&\n                (bn3 == rhs.bn3) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            calcOp.Serialize(ds);\n            bn0.Serialize(ds);\n            bn1.Serialize(ds);\n            bn2.Serialize(ds);\n            bn3.Serialize(ds);\n        }\n        void SetModulo(component::Fp2& modulo);\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Fp12 code for operations.h"}, {"role": "assistant", "content": "class BignumCalc_Fp12 : public Operation {\n    public:\n        const component::CalcOp calcOp;\n        const component::Fp12 bn0;\n        const component::Fp12 bn1;\n        const component::Fp12 bn2;\n        const component::Fp12 bn3;\n        std::optional<component::Fp12> modulo;\n\n        BignumCalc_Fp12(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            calcOp(ds),\n            bn0(ds),\n            bn1(ds),\n            bn2(ds),\n            bn3(ds)\n        { }\n        BignumCalc_Fp12(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            calcOp(json[\"calcOp\"]),\n            bn0(json[\"bn1\"]),\n            bn1(json[\"bn2\"]),\n            bn2(json[\"bn3\"]),\n            bn3(json[\"bn4\"])\n        { }\n        BignumCalc_Fp12(\n                component::Modifier modifier,\n                component::CurveType calcOp,\n                component::Fp12 bn0,\n                component::Fp12 bn1,\n                component::Fp12 bn2,\n                component::Fp12 bn3) :\n            Operation(std::move(modifier)),\n            calcOp(calcOp),\n            bn0(bn0),\n            bn1(bn1),\n            bn2(bn2),\n            bn3(bn3)\n        { }\n\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const BignumCalc_Fp12& rhs) const {\n            return\n                (calcOp == rhs.calcOp) &&\n                (bn0 == rhs.bn0) &&\n                (bn1 == rhs.bn1) &&\n                (bn2 == rhs.bn2) &&\n                (bn3 == rhs.bn3) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            calcOp.Serialize(ds);\n            bn0.Serialize(ds);\n            bn1.Serialize(ds);\n            bn2.Serialize(ds);\n            bn3.Serialize(ds);\n        }\n        void SetModulo(component::Fp12& modulo);\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_PrivateToPublic code for operations.h"}, {"role": "assistant", "content": "class BLS_PrivateToPublic : public Operation {\n    public:\n        const component::CurveType curveType;\n        const component::BLS_PrivateKey priv;\n\n        BLS_PrivateToPublic(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            priv(ds)\n        { }\n        BLS_PrivateToPublic(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            priv(json[\"priv\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const BLS_PrivateToPublic& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (priv == rhs.priv) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            priv.Serialize(ds);\n        }\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_PrivateToPublic_G2 code for operations.h"}, {"role": "assistant", "content": "class BLS_PrivateToPublic_G2 : public Operation {\n    public:\n        const component::CurveType curveType;\n        const component::BLS_PrivateKey priv;\n\n        BLS_PrivateToPublic_G2(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            priv(ds)\n        { }\n        BLS_PrivateToPublic_G2(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            priv(json[\"priv\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const BLS_PrivateToPublic_G2& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (priv == rhs.priv) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            priv.Serialize(ds);\n        }\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_Sign code for operations.h"}, {"role": "assistant", "content": "class BLS_Sign : public Operation {\n    public:\n        const component::CurveType curveType;\n        const component::BLS_PrivateKey priv;\n        const bool hashOrPoint;\n        const component::G2 point;\n        const component::Cleartext cleartext;\n        const component::Cleartext dest;\n        const component::Cleartext aug;\n\n        BLS_Sign(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            priv(ds),\n            hashOrPoint(ds.Get<bool>()),\n            point(ds),\n            cleartext(ds),\n            dest(ds),\n            aug(ds)\n        { }\n        BLS_Sign(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            priv(json[\"priv\"]),\n            hashOrPoint(json[\"hashOrPoint\"]),\n            point(json[\"point_v\"], json[\"point_w\"], json[\"point_x\"], json[\"point_y\"]),\n            cleartext(json[\"cleartext\"]),\n            dest(json[\"dest\"]),\n            aug(json[\"aug\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const BLS_Sign& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (priv == rhs.priv) &&\n                (hashOrPoint == rhs.hashOrPoint) &&\n                (point == rhs.point) &&\n                (cleartext == rhs.cleartext) &&\n                (dest == rhs.dest) &&\n                (aug == rhs.aug) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            priv.Serialize(ds);\n            ds.Put<bool>(hashOrPoint);\n            point.Serialize(ds);\n            cleartext.Serialize(ds);\n            dest.Serialize(ds);\n            aug.Serialize(ds);\n        }\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_Verify code for operations.h"}, {"role": "assistant", "content": "class BLS_Verify : public Operation {\n    public:\n        const component::CurveType curveType;\n        const component::BLS_PublicKey pub;\n        const bool hashOrPoint;\n        const component::G2 point;\n        const component::Cleartext cleartext;\n        const component::Cleartext dest;\n        const component::G2 signature;\n\n        BLS_Verify(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            pub(ds),\n            hashOrPoint(ds.Get<bool>()),\n            point(ds),\n            cleartext(ds),\n            dest(ds),\n            signature(ds)\n        { }\n        BLS_Verify(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            pub(json[\"pub_x\"], json[\"pub_y\"]),\n            hashOrPoint(json[\"hashOrPoint\"]),\n            point(json[\"point_v\"], json[\"point_w\"], json[\"point_x\"], json[\"point_y\"]),\n            cleartext(json[\"cleartext\"]),\n            dest(json[\"dest\"]),\n            signature(json[\"sig_v\"], json[\"sig_w\"], json[\"sig_x\"], json[\"sig_y\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const BLS_Verify& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (pub == rhs.pub) &&\n                (hashOrPoint == rhs.hashOrPoint) &&\n                (point == rhs.point) &&\n                (cleartext == rhs.cleartext) &&\n                (dest == rhs.dest) &&\n                (signature == rhs.signature) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            pub.Serialize(ds);\n            ds.Put<bool>(hashOrPoint);\n            point.Serialize(ds);\n            cleartext.Serialize(ds);\n            dest.Serialize(ds);\n            signature.Serialize(ds);\n        }\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_BatchSign code for operations.h"}, {"role": "assistant", "content": "class BLS_BatchSign : public Operation {\n    public:\n        component::BLS_BatchSign_Vector bf;\n\n        BLS_BatchSign(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            bf(ds)\n        { }\n        BLS_BatchSign(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            bf(json[\"bf\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const BLS_BatchSign& rhs) const {\n            return\n                (bf == rhs.bf) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            bf.Serialize(ds);\n        }\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_BatchVerify code for operations.h"}, {"role": "assistant", "content": "class BLS_BatchVerify : public Operation {\n    public:\n        component::BLS_BatchVerify_Vector bf;\n\n        BLS_BatchVerify(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            bf(ds)\n        { }\n        BLS_BatchVerify(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            bf(json[\"bf\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const BLS_BatchVerify& rhs) const {\n            return\n                (bf == rhs.bf) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            bf.Serialize(ds);\n        }\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_Aggregate_G1 code for operations.h"}, {"role": "assistant", "content": "class BLS_Aggregate_G1 : public Operation {\n    public:\n        const component::CurveType curveType;\n        component::BLS_G1_Vector points;\n\n        BLS_Aggregate_G1(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            points(ds)\n        { }\n        BLS_Aggregate_G1(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            points(json[\"points\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const BLS_Aggregate_G1& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (points == rhs.points) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            points.Serialize(ds);\n        }\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_Aggregate_G2 code for operations.h"}, {"role": "assistant", "content": "class BLS_Aggregate_G2 : public Operation {\n    public:\n        const component::CurveType curveType;\n        component::BLS_G2_Vector points;\n\n        BLS_Aggregate_G2(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            points(ds)\n        { }\n        BLS_Aggregate_G2(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            points(json[\"points\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const BLS_Aggregate_G2& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (points == rhs.points) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            points.Serialize(ds);\n        }\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_Pairing code for operations.h"}, {"role": "assistant", "content": "class BLS_Pairing : public Operation {\n    public:\n        const component::CurveType curveType;\n        const component::G1 g1;\n        const component::G2 g2;\n\n        BLS_Pairing(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            g1(ds),\n            g2(ds)\n        { }\n        BLS_Pairing(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            g1(json[\"g1_x\"], json[\"g1_y\"]),\n            g2(json[\"g2_v\"], json[\"g2_w\"], json[\"g2_x\"], json[\"g2_y\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const BLS_Pairing& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (g1 == rhs.g1) &&\n                (g2 == rhs.g2) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            g1.Serialize(ds);\n            g2.Serialize(ds);\n        }\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_MillerLoop code for operations.h"}, {"role": "assistant", "content": "class BLS_MillerLoop : public Operation {\n    public:\n        const component::CurveType curveType;\n        const component::G1 g1;\n        const component::G2 g2;\n\n        BLS_MillerLoop(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            g1(ds),\n            g2(ds)\n        { }\n        BLS_MillerLoop(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            g1(json[\"g1_x\"], json[\"g1_y\"]),\n            g2(json[\"g2_v\"], json[\"g2_w\"], json[\"g2_x\"], json[\"g2_y\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const BLS_MillerLoop& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (g1 == rhs.g1) &&\n                (g2 == rhs.g2) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            g1.Serialize(ds);\n            g2.Serialize(ds);\n        }\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_FinalExp code for operations.h"}, {"role": "assistant", "content": "class BLS_FinalExp : public Operation {\n    public:\n        const component::CurveType curveType;\n        const component::Fp12 fp12;\n\n        BLS_FinalExp(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            fp12(ds)\n        { }\n        BLS_FinalExp(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            fp12(json[\"fp12\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const BLS_FinalExp& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (fp12 == rhs.fp12) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            fp12.Serialize(ds);\n        }\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_HashToG1 code for operations.h"}, {"role": "assistant", "content": "class BLS_HashToG1 : public Operation {\n    public:\n        const component::CurveType curveType;\n        const component::Cleartext cleartext;\n        const component::Cleartext dest;\n        const component::Cleartext aug;\n\n        BLS_HashToG1(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            cleartext(ds),\n            dest(ds),\n            aug(ds)\n        { }\n        BLS_HashToG1(const component::CurveType curveType, const component::Cleartext cleartext, const component::Cleartext dest, const component::Cleartext aug, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(curveType),\n            cleartext(cleartext),\n            dest(dest),\n            aug(aug)\n        { }\n        BLS_HashToG1(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            cleartext(json[\"cleartext\"]),\n            dest(json[\"dest\"]),\n            aug(json[\"aug\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const BLS_HashToG1& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (cleartext == rhs.cleartext) &&\n                (dest == rhs.dest) &&\n                (aug == rhs.aug) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            cleartext.Serialize(ds);\n            dest.Serialize(ds);\n            aug.Serialize(ds);\n        }\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_HashToG2 code for operations.h"}, {"role": "assistant", "content": "class BLS_HashToG2 : public Operation {\n    public:\n        const component::CurveType curveType;\n        const component::Cleartext cleartext;\n        const component::Cleartext dest;\n        const component::Cleartext aug;\n\n        BLS_HashToG2(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            cleartext(ds),\n            dest(ds),\n            aug(ds)\n        { }\n        BLS_HashToG2(const component::CurveType curveType, const component::Cleartext cleartext, const component::Cleartext dest, const component::Cleartext aug, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(curveType),\n            cleartext(cleartext),\n            dest(dest),\n            aug(aug)\n        { }\n        BLS_HashToG2(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            cleartext(json[\"cleartext\"]),\n            dest(json[\"dest\"]),\n            aug(json[\"aug\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const BLS_HashToG2& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (cleartext == rhs.cleartext) &&\n                (dest == rhs.dest) &&\n                (aug == rhs.aug) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            cleartext.Serialize(ds);\n            dest.Serialize(ds);\n            aug.Serialize(ds);\n        }\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_MapToG1 code for operations.h"}, {"role": "assistant", "content": "class BLS_MapToG1 : public Operation {\n    public:\n        const component::CurveType curveType;\n        const component::Bignum u;\n        const component::Bignum v;\n\n        BLS_MapToG1(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            u(ds),\n            v(ds)\n        { }\n        BLS_MapToG1(const component::CurveType curveType, const component::Bignum u, const component::Bignum v, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(curveType),\n            u(u),\n            v(v)\n        { }\n        BLS_MapToG1(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            u(json[\"u\"]),\n            v(json[\"v\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const BLS_MapToG1& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (u == rhs.u) &&\n                (v == rhs.v) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            u.Serialize(ds);\n            v.Serialize(ds);\n        }\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_MapToG2 code for operations.h"}, {"role": "assistant", "content": "class BLS_MapToG2 : public Operation {\n    public:\n        const component::CurveType curveType;\n        const component::Fp2 u;\n        const component::Fp2 v;\n\n        BLS_MapToG2(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            u(ds),\n            v(ds)\n        { }\n        BLS_MapToG2(const component::CurveType curveType, const component::Fp2 u, const component::Fp2 v, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(curveType),\n            u(u),\n            v(v)\n        { }\n        BLS_MapToG2(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            u(json[\"u\"]),\n            v(json[\"v\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const BLS_MapToG2& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (u == rhs.u) &&\n                (v == rhs.v) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            u.Serialize(ds);\n            v.Serialize(ds);\n        }\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_IsG1OnCurve code for operations.h"}, {"role": "assistant", "content": "class BLS_IsG1OnCurve : public Operation {\n    public:\n        const component::CurveType curveType;\n        const component::G1 g1;\n\n        BLS_IsG1OnCurve(Datasource& ds, component::Modifier modifier) :\n            Operation(std::move(modifier)),\n            curveType(ds),\n            g1(ds)\n        { }\n        BLS_IsG1OnCurve(nlohmann::json json) :\n            Operation(json[\"modifier\"]),\n            curveType(json[\"curveType\"]),\n            g1(json[\"g1_x\"], json[\"g1_y\"])\n        { }\n\n        static size_t MaxOperations(void) { return 5; }\n        std::string Name(void) const override;\n        std::string ToString(void) const override;\n        nlohmann::json ToJSON(void) const override;\n        inline bool operator==(const BLS_IsG1OnCurve& rhs) const {\n            return\n                (curveType == rhs.curveType) &&\n                (g1 == rhs.g1) &&\n                (modifier == rhs.modifier);\n        }\n        void Serialize(Datasource& ds) const {\n            curveType.Serialize(ds);\n            g1.Serialize(ds);\n        }\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate Digest code for module.h"}, {"role": "assistant", "content": "        virtual std::optional<component::Digest> OpDigest(operation::Digest& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate HMAC code for module.h"}, {"role": "assistant", "content": "        virtual std::optional<component::MAC> OpHMAC(operation::HMAC& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate UMAC code for module.h"}, {"role": "assistant", "content": "        virtual std::optional<component::MAC> OpUMAC(operation::UMAC& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate SymmetricEncrypt code for module.h"}, {"role": "assistant", "content": "        virtual std::optional<component::Ciphertext> OpSymmetricEncrypt(operation::SymmetricEncrypt& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate SymmetricDecrypt code for module.h"}, {"role": "assistant", "content": "        virtual std::optional<component::Cleartext> OpSymmetricDecrypt(operation::SymmetricDecrypt& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_SCRYPT code for module.h"}, {"role": "assistant", "content": "        virtual std::optional<component::Key> OpKDF_SCRYPT(operation::KDF_SCRYPT& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_HKDF code for module.h"}, {"role": "assistant", "content": "        virtual std::optional<component::Key> OpKDF_HKDF(operation::KDF_HKDF& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_TLS1_PRF code for module.h"}, {"role": "assistant", "content": "        virtual std::optional<component::Key> OpKDF_TLS1_PRF(operation::KDF_TLS1_PRF& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_PBKDF code for module.h"}, {"role": "assistant", "content": "        virtual std::optional<component::Key> OpKDF_PBKDF(operation::KDF_PBKDF& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_PBKDF1 code for module.h"}, {"role": "assistant", "content": "        virtual std::optional<component::Key> OpKDF_PBKDF1(operation::KDF_PBKDF1& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_PBKDF2 code for module.h"}, {"role": "assistant", "content": "        virtual std::optional<component::Key> OpKDF_PBKDF2(operation::KDF_PBKDF2& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_ARGON2 code for module.h"}, {"role": "assistant", "content": "        virtual std::optional<component::Key> OpKDF_ARGON2(operation::KDF_ARGON2& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_SSH code for module.h"}, {"role": "assistant", "content": "        virtual std::optional<component::Key> OpKDF_SSH(operation::KDF_SSH& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_X963 code for module.h"}, {"role": "assistant", "content": "        virtual std::optional<component::Key> OpKDF_X963(operation::KDF_X963& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_BCRYPT code for module.h"}, {"role": "assistant", "content": "        virtual std::optional<component::Key> OpKDF_BCRYPT(operation::KDF_BCRYPT& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_SP_800_108 code for module.h"}, {"role": "assistant", "content": "        virtual std::optional<component::Key> OpKDF_SP_800_108(operation::KDF_SP_800_108& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_SRTP code for module.h"}, {"role": "assistant", "content": "        virtual std::optional<component::Key3> OpKDF_SRTP(operation::KDF_SRTP& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_SRTCP code for module.h"}, {"role": "assistant", "content": "        virtual std::optional<component::Key3> OpKDF_SRTCP(operation::KDF_SRTCP& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate CMAC code for module.h"}, {"role": "assistant", "content": "        virtual std::optional<component::MAC> OpCMAC(operation::CMAC& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_PrivateToPublic code for module.h"}, {"role": "assistant", "content": "        virtual std::optional<component::ECC_PublicKey> OpECC_PrivateToPublic(operation::ECC_PrivateToPublic& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_ValidatePubkey code for module.h"}, {"role": "assistant", "content": "        virtual std::optional<bool> OpECC_ValidatePubkey(operation::ECC_ValidatePubkey& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_GenerateKeyPair code for module.h"}, {"role": "assistant", "content": "        virtual std::optional<component::ECC_KeyPair> OpECC_GenerateKeyPair(operation::ECC_GenerateKeyPair& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECCSI_Sign code for module.h"}, {"role": "assistant", "content": "        virtual std::optional<component::ECCSI_Signature> OpECCSI_Sign(operation::ECCSI_Sign& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECDSA_Sign code for module.h"}, {"role": "assistant", "content": "        virtual std::optional<component::ECDSA_Signature> OpECDSA_Sign(operation::ECDSA_Sign& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECGDSA_Sign code for module.h"}, {"role": "assistant", "content": "        virtual std::optional<component::ECGDSA_Signature> OpECGDSA_Sign(operation::ECGDSA_Sign& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECRDSA_Sign code for module.h"}, {"role": "assistant", "content": "        virtual std::optional<component::ECRDSA_Signature> OpECRDSA_Sign(operation::ECRDSA_Sign& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate Schnorr_Sign code for module.h"}, {"role": "assistant", "content": "        virtual std::optional<component::Schnorr_Signature> OpSchnorr_Sign(operation::Schnorr_Sign& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECCSI_Verify code for module.h"}, {"role": "assistant", "content": "        virtual std::optional<bool> OpECCSI_Verify(operation::ECCSI_Verify& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECDSA_Verify code for module.h"}, {"role": "assistant", "content": "        virtual std::optional<bool> OpECDSA_Verify(operation::ECDSA_Verify& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECGDSA_Verify code for module.h"}, {"role": "assistant", "content": "        virtual std::optional<bool> OpECGDSA_Verify(operation::ECGDSA_Verify& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECRDSA_Verify code for module.h"}, {"role": "assistant", "content": "        virtual std::optional<bool> OpECRDSA_Verify(operation::ECRDSA_Verify& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate Schnorr_Verify code for module.h"}, {"role": "assistant", "content": "        virtual std::optional<bool> OpSchnorr_Verify(operation::Schnorr_Verify& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECDSA_Recover code for module.h"}, {"role": "assistant", "content": "        virtual std::optional<component::ECC_PublicKey> OpECDSA_Recover(operation::ECDSA_Recover& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate DSA_Verify code for module.h"}, {"role": "assistant", "content": "        virtual std::optional<bool> OpDSA_Verify(operation::DSA_Verify& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate DSA_Sign code for module.h"}, {"role": "assistant", "content": "        virtual std::optional<component::DSA_Signature> OpDSA_Sign(operation::DSA_Sign& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate DSA_GenerateParameters code for module.h"}, {"role": "assistant", "content": "        virtual std::optional<component::DSA_Parameters> OpDSA_GenerateParameters(operation::DSA_GenerateParameters& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate DSA_PrivateToPublic code for module.h"}, {"role": "assistant", "content": "        virtual std::optional<component::Bignum> OpDSA_PrivateToPublic(operation::DSA_PrivateToPublic& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate DSA_GenerateKeyPair code for module.h"}, {"role": "assistant", "content": "        virtual std::optional<component::DSA_KeyPair> OpDSA_GenerateKeyPair(operation::DSA_GenerateKeyPair& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECDH_Derive code for module.h"}, {"role": "assistant", "content": "        virtual std::optional<component::Secret> OpECDH_Derive(operation::ECDH_Derive& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECIES_Encrypt code for module.h"}, {"role": "assistant", "content": "        virtual std::optional<component::Ciphertext> OpECIES_Encrypt(operation::ECIES_Encrypt& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECIES_Decrypt code for module.h"}, {"role": "assistant", "content": "        virtual std::optional<component::Cleartext> OpECIES_Decrypt(operation::ECIES_Decrypt& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_Point_Add code for module.h"}, {"role": "assistant", "content": "        virtual std::optional<component::ECC_Point> OpECC_Point_Add(operation::ECC_Point_Add& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_Point_Sub code for module.h"}, {"role": "assistant", "content": "        virtual std::optional<component::ECC_Point> OpECC_Point_Sub(operation::ECC_Point_Sub& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_Point_Mul code for module.h"}, {"role": "assistant", "content": "        virtual std::optional<component::ECC_Point> OpECC_Point_Mul(operation::ECC_Point_Mul& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_Point_Neg code for module.h"}, {"role": "assistant", "content": "        virtual std::optional<component::ECC_Point> OpECC_Point_Neg(operation::ECC_Point_Neg& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_Point_Dbl code for module.h"}, {"role": "assistant", "content": "        virtual std::optional<component::ECC_Point> OpECC_Point_Dbl(operation::ECC_Point_Dbl& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_Point_Cmp code for module.h"}, {"role": "assistant", "content": "        virtual std::optional<bool> OpECC_Point_Cmp(operation::ECC_Point_Cmp& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate DH_GenerateKeyPair code for module.h"}, {"role": "assistant", "content": "        virtual std::optional<component::DH_KeyPair> OpDH_GenerateKeyPair(operation::DH_GenerateKeyPair& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate DH_Derive code for module.h"}, {"role": "assistant", "content": "        virtual std::optional<component::Bignum> OpDH_Derive(operation::DH_Derive& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc code for module.h"}, {"role": "assistant", "content": "        virtual std::optional<component::Bignum> OpBignumCalc(operation::BignumCalc& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Fp2 code for module.h"}, {"role": "assistant", "content": "        virtual std::optional<component::Fp2> OpBignumCalc_Fp2(operation::BignumCalc_Fp2& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Fp12 code for module.h"}, {"role": "assistant", "content": "        virtual std::optional<component::Fp12> OpBignumCalc_Fp12(operation::BignumCalc_Fp12& op) {\n            (void)op;\n            return std::nullopt;\n        }\n        virtual bool SupportsModularBignumCalc(void) const {\n            return false;\n        }\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_PrivateToPublic code for module.h"}, {"role": "assistant", "content": "        virtual std::optional<component::BLS_PublicKey> OpBLS_PrivateToPublic(operation::BLS_PrivateToPublic& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_PrivateToPublic_G2 code for module.h"}, {"role": "assistant", "content": "        virtual std::optional<component::G2> OpBLS_PrivateToPublic_G2(operation::BLS_PrivateToPublic_G2& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_Sign code for module.h"}, {"role": "assistant", "content": "        virtual std::optional<component::BLS_Signature> OpBLS_Sign(operation::BLS_Sign& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_Verify code for module.h"}, {"role": "assistant", "content": "        virtual std::optional<bool> OpBLS_Verify(operation::BLS_Verify& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_BatchSign code for module.h"}, {"role": "assistant", "content": "        virtual std::optional<component::BLS_BatchSignature> OpBLS_BatchSign(operation::BLS_BatchSign& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_BatchVerify code for module.h"}, {"role": "assistant", "content": "        virtual std::optional<bool> OpBLS_BatchVerify(operation::BLS_BatchVerify& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_Aggregate_G1 code for module.h"}, {"role": "assistant", "content": "        virtual std::optional<component::G1> OpBLS_Aggregate_G1(operation::BLS_Aggregate_G1& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_Aggregate_G2 code for module.h"}, {"role": "assistant", "content": "        virtual std::optional<component::G2> OpBLS_Aggregate_G2(operation::BLS_Aggregate_G2& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_Pairing code for module.h"}, {"role": "assistant", "content": "        virtual std::optional<component::Fp12> OpBLS_Pairing(operation::BLS_Pairing& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_MillerLoop code for module.h"}, {"role": "assistant", "content": "        virtual std::optional<component::Fp12> OpBLS_MillerLoop(operation::BLS_MillerLoop& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_FinalExp code for module.h"}, {"role": "assistant", "content": "        virtual std::optional<component::Fp12> OpBLS_FinalExp(operation::BLS_FinalExp& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_HashToG1 code for module.h"}, {"role": "assistant", "content": "        virtual std::optional<component::G1> OpBLS_HashToG1(operation::BLS_HashToG1& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_HashToG2 code for module.h"}, {"role": "assistant", "content": "        virtual std::optional<component::G2> OpBLS_HashToG2(operation::BLS_HashToG2& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_MapToG1 code for module.h"}, {"role": "assistant", "content": "        virtual std::optional<component::G1> OpBLS_MapToG1(operation::BLS_MapToG1& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_MapToG2 code for module.h"}, {"role": "assistant", "content": "        virtual std::optional<component::G2> OpBLS_MapToG2(operation::BLS_MapToG2& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_IsG1OnCurve code for module.h"}, {"role": "assistant", "content": "        virtual std::optional<bool> OpBLS_IsG1OnCurve(operation::BLS_IsG1OnCurve& op) {\n            (void)op;\n            return std::nullopt;\n        }\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate Digest code for operation.cpp"}, {"role": "assistant", "content": "std::string Digest::Name(void) const { return \"Digest\"; }std::string Digest::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: Digest\" << std::endl;\n    ss << \"digest: \" << repository::DigestToString(digestType.Get()) << std::endl;\n    ss << \"cleartext: \" << util::HexDump(cleartext.Get()) << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json Digest::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"Digest\";\n    j[\"cleartext\"] = cleartext.ToJSON();\n    j[\"digestType\"] = digestType.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate HMAC code for operation.cpp"}, {"role": "assistant", "content": "std::string HMAC::Name(void) const { return \"HMAC\"; }std::string HMAC::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: HMAC\" << std::endl;\n    ss << \"digest: \" << repository::DigestToString(digestType.Get()) << std::endl;\n    ss << \"key: \" << util::HexDump(cipher.key.Get()) << std::endl;\n    ss << \"cleartext: \" << util::HexDump(cleartext.Get()) << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json HMAC::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"HMAC\";\n    j[\"cleartext\"] = cleartext.ToJSON();\n    j[\"digestType\"] = digestType.ToJSON();\n    j[\"cipher\"] = cipher.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate UMAC code for operation.cpp"}, {"role": "assistant", "content": "std::string UMAC::Name(void) const { return \"UMAC\"; }std::string UMAC::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: UMAC\" << std::endl;\n    ss << \"cleartext: \" << util::HexDump(cleartext.Get()) << std::endl;\n    ss << \"key: \" << util::HexDump(key.Get()) << std::endl;\n    ss << \"iv: \" << util::HexDump(iv.Get()) << std::endl;\n    ss << \"type: \" << std::to_string(type) << std::endl;\n    ss << \"outSize: \" << std::to_string(outSize) << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json UMAC::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"UMAC\";\n    j[\"cleartext\"] = cleartext.ToJSON();\n    j[\"key\"] = key.ToJSON();\n    j[\"iv\"] = iv.ToJSON();\n    j[\"type\"] = type;\n    j[\"outSize\"] = outSize;\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate SymmetricEncrypt code for operation.cpp"}, {"role": "assistant", "content": "std::string SymmetricEncrypt::Name(void) const { return \"SymmetricEncrypt\"; }std::string SymmetricEncrypt::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: SymmetricEncrypt\" << std::endl;\n    ss << \"cleartext: \" << util::HexDump(cleartext.Get()) << std::endl;\n    ss << \"aad: \" << (aad ? util::HexDump(aad->Get()) : \"nullopt\") << std::endl;\n    ss << \"cipher iv: \" << util::HexDump(cipher.iv.Get()) << std::endl;\n    ss << \"cipher key: \" << util::HexDump(cipher.key.Get()) << std::endl;\n    ss << \"cipher: \" << repository::CipherToString(cipher.cipherType.Get()) << std::endl;\n    ss << \"ciphertextSize: \" << std::to_string(ciphertextSize) << std::endl;\n    ss << \"tagSize: \" << (tagSize ? std::to_string(*tagSize) : \"nullopt\") << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json SymmetricEncrypt::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"SymmetricEncrypt\";\n    j[\"cleartext\"] = cleartext.ToJSON();\n    j[\"cipher\"] = cipher.ToJSON();\n    j[\"aad_enabled\"] = (bool)(aad != std::nullopt);\n    j[\"aad\"] = aad != std::nullopt ? aad->ToJSON() : \"\";\n    j[\"ciphertextSize\"] = ciphertextSize;\n    j[\"tagSize_enabled\"] = (bool)(tagSize != std::nullopt);\n    j[\"tagSize\"] = tagSize != std::nullopt ? *tagSize : 0;\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate SymmetricDecrypt code for operation.cpp"}, {"role": "assistant", "content": "std::string SymmetricDecrypt::Name(void) const { return \"SymmetricDecrypt\"; }std::string SymmetricDecrypt::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: SymmetricDecrypt\" << std::endl;\n    ss << \"ciphertext: \" << util::HexDump(ciphertext.Get()) << std::endl;\n    ss << \"tag: \" << (tag ? util::HexDump(tag->Get()) : \"nullopt\") << std::endl;\n    ss << \"aad: \" << (aad ? util::HexDump(aad->Get()) : \"nullopt\") << std::endl;\n    ss << \"cipher iv: \" << util::HexDump(cipher.iv.Get()) << std::endl;\n    ss << \"cipher key: \" << util::HexDump(cipher.key.Get()) << std::endl;\n    ss << \"cipher: \" << repository::CipherToString(cipher.cipherType.Get()) << std::endl;\n    ss << \"cleartextSize: \" << std::to_string(cleartextSize) << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json SymmetricDecrypt::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"SymmetricDecrypt\";\n    j[\"ciphertext\"] = ciphertext.ToJSON();\n    j[\"cipher\"] = cipher.ToJSON();\n    j[\"aad_enabled\"] = (bool)(aad != std::nullopt);\n    j[\"aad\"] = aad != std::nullopt ? aad->ToJSON() : \"\";\n    j[\"tag_enabled\"] = (bool)(tag != std::nullopt);\n    j[\"tag\"] = tag != std::nullopt ? tag->ToJSON() : \"\";\n    j[\"cleartextSize\"] = cleartextSize;\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n/* Construct SymmetricDecrypt from SymmetricEncrypt */\nSymmetricDecrypt::SymmetricDecrypt(const SymmetricEncrypt& opSymmetricEncrypt, const component::Ciphertext ciphertext, const uint64_t cleartextSize, std::optional<component::AAD> aad, component::Modifier modifier) :\n    Operation(std::move(modifier)),\n    ciphertext(ciphertext.ciphertext),\n    cipher(opSymmetricEncrypt.cipher),\n    tag(ciphertext.tag),\n    aad(aad),\n    cleartextSize(cleartextSize)\n{ }\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_SCRYPT code for operation.cpp"}, {"role": "assistant", "content": "std::string KDF_SCRYPT::Name(void) const { return \"KDF_SCRYPT\"; }std::string KDF_SCRYPT::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: KDF_SCRYPT\" << std::endl;\n    ss << \"password: \" << util::HexDump(password.Get()) << std::endl;\n    ss << \"salt: \" << util::HexDump(salt.Get()) << std::endl;\n    ss << \"N: \" << std::to_string(N) << std::endl;\n    ss << \"r: \" << std::to_string(r) << std::endl;\n    ss << \"p: \" << std::to_string(p) << std::endl;\n    ss << \"keySize: \" << std::to_string(keySize) << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json KDF_SCRYPT::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"KDF_SCRYPT\";\n    j[\"password\"] = password.ToJSON();\n    j[\"salt\"] = salt.ToJSON();\n    j[\"N\"] = N;\n    j[\"r\"] = r;\n    j[\"p\"] = p;\n    j[\"keySize\"] = keySize;\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_HKDF code for operation.cpp"}, {"role": "assistant", "content": "std::string KDF_HKDF::Name(void) const { return \"KDF_HKDF\"; }std::string KDF_HKDF::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: KDF_HKDF\" << std::endl;\n    ss << \"digest: \" << repository::DigestToString(digestType.Get()) << std::endl;\n    ss << \"password: \" << util::HexDump(password.Get()) << std::endl;\n    ss << \"salt: \" << util::HexDump(salt.Get()) << std::endl;\n    ss << \"info: \" << util::HexDump(info.Get()) << std::endl;\n    ss << \"keySize: \" << std::to_string(keySize) << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json KDF_HKDF::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"KDF_HKDF\";\n    j[\"digestType\"] = digestType.ToJSON();\n    j[\"password\"] = password.ToJSON();\n    j[\"salt\"] = salt.ToJSON();\n    j[\"info\"] = info.ToJSON();\n    j[\"keySize\"] = keySize;\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_TLS1_PRF code for operation.cpp"}, {"role": "assistant", "content": "std::string KDF_TLS1_PRF::Name(void) const { return \"KDF_TLS1_PRF\"; }std::string KDF_TLS1_PRF::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: KDF_TLS1_PRF\" << std::endl;\n    ss << \"digest: \" << repository::DigestToString(digestType.Get()) << std::endl;\n    ss << \"secret: \" << util::HexDump(secret.Get()) << std::endl;\n    ss << \"seed: \" << util::HexDump(seed.Get()) << std::endl;\n    ss << \"keySize: \" << std::to_string(keySize) << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json KDF_TLS1_PRF::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"KDF_TLS1_PRF\";\n    j[\"digestType\"] = digestType.ToJSON();\n    j[\"secret\"] = secret.ToJSON();\n    j[\"seed\"] = seed.ToJSON();\n    j[\"keySize\"] = keySize;\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_PBKDF code for operation.cpp"}, {"role": "assistant", "content": "std::string KDF_PBKDF::Name(void) const { return \"KDF_PBKDF\"; }std::string KDF_PBKDF::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: KDF_PBKDF\" << std::endl;\n    ss << \"digest: \" << repository::DigestToString(digestType.Get()) << std::endl;\n    ss << \"password: \" << util::HexDump(password.Get()) << std::endl;\n    ss << \"salt: \" << util::HexDump(salt.Get()) << std::endl;\n    ss << \"iterations: \" << std::to_string(iterations) << std::endl;\n    ss << \"keySize: \" << std::to_string(keySize) << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json KDF_PBKDF::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"KDF_PBKDF\";\n    j[\"digestType\"] = digestType.ToJSON();\n    j[\"password\"] = password.ToJSON();\n    j[\"salt\"] = salt.ToJSON();\n    j[\"iterations\"] = iterations;\n    j[\"keySize\"] = keySize;\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_PBKDF1 code for operation.cpp"}, {"role": "assistant", "content": "std::string KDF_PBKDF1::Name(void) const { return \"KDF_PBKDF1\"; }std::string KDF_PBKDF1::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: KDF_PBKDF1\" << std::endl;\n    ss << \"digest: \" << repository::DigestToString(digestType.Get()) << std::endl;\n    ss << \"password: \" << util::HexDump(password.Get()) << std::endl;\n    ss << \"salt: \" << util::HexDump(salt.Get()) << std::endl;\n    ss << \"iterations: \" << std::to_string(iterations) << std::endl;\n    ss << \"keySize: \" << std::to_string(keySize) << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json KDF_PBKDF1::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"KDF_PBKDF1\";\n    j[\"digestType\"] = digestType.ToJSON();\n    j[\"password\"] = password.ToJSON();\n    j[\"salt\"] = salt.ToJSON();\n    j[\"iterations\"] = iterations;\n    j[\"keySize\"] = keySize;\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_PBKDF2 code for operation.cpp"}, {"role": "assistant", "content": "std::string KDF_PBKDF2::Name(void) const { return \"KDF_PBKDF2\"; }std::string KDF_PBKDF2::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: KDF_PBKDF2\" << std::endl;\n    ss << \"digest: \" << repository::DigestToString(digestType.Get()) << std::endl;\n    ss << \"password: \" << util::HexDump(password.Get()) << std::endl;\n    ss << \"salt: \" << util::HexDump(salt.Get()) << std::endl;\n    ss << \"iterations: \" << std::to_string(iterations) << std::endl;\n    ss << \"keySize: \" << std::to_string(keySize) << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json KDF_PBKDF2::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"KDF_PBKDF2\";\n    j[\"digestType\"] = digestType.ToJSON();\n    j[\"password\"] = password.ToJSON();\n    j[\"salt\"] = salt.ToJSON();\n    j[\"iterations\"] = iterations;\n    j[\"keySize\"] = keySize;\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_ARGON2 code for operation.cpp"}, {"role": "assistant", "content": "std::string KDF_ARGON2::Name(void) const { return \"KDF_ARGON2\"; }std::string KDF_ARGON2::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: KDF_ARGON2\" << std::endl;\n    ss << \"password: \" << util::HexDump(password.Get()) << std::endl;\n    ss << \"salt: \" << util::HexDump(salt.Get()) << std::endl;\n    ss << \"type: \" << std::to_string(type) << std::endl;\n    ss << \"threads: \" << std::to_string(threads) << std::endl;\n    ss << \"memory: \" << std::to_string(memory) << std::endl;\n    ss << \"iterations: \" << std::to_string(iterations) << std::endl;\n    ss << \"keySize: \" << std::to_string(keySize) << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json KDF_ARGON2::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"KDF_ARGON2\";\n    j[\"password\"] = password.ToJSON();\n    j[\"salt\"] = salt.ToJSON();\n    j[\"type\"] = type;\n    j[\"threads\"] = threads;\n    j[\"memory\"] = memory;\n    j[\"iterations\"] = iterations;\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_SSH code for operation.cpp"}, {"role": "assistant", "content": "std::string KDF_SSH::Name(void) const { return \"KDF_SSH\"; }std::string KDF_SSH::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: KDF_SSH\" << std::endl;\n    ss << \"digest: \" << repository::DigestToString(digestType.Get()) << std::endl;\n    ss << \"key: \" << util::HexDump(key.Get()) << std::endl;\n    ss << \"xcghash: \" << util::HexDump(xcghash.Get()) << std::endl;\n    ss << \"session_id: \" << util::HexDump(session_id.Get()) << std::endl;\n    ss << \"type: \" << util::HexDump(type.Get()) << std::endl;\n    ss << \"keySize: \" << std::to_string(keySize) << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json KDF_SSH::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"KDF_SSH\";\n    j[\"digestType\"] = digestType.ToJSON();\n    j[\"key\"] = key.ToJSON();\n    j[\"xcghash\"] = xcghash.ToJSON();\n    j[\"session_id\"] = session_id.ToJSON();\n    j[\"type\"] = type.ToJSON();\n    j[\"keySize\"] = keySize;\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_X963 code for operation.cpp"}, {"role": "assistant", "content": "std::string KDF_X963::Name(void) const { return \"KDF_X963\"; }std::string KDF_X963::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: KDF_X963\" << std::endl;\n    ss << \"digest: \" << repository::DigestToString(digestType.Get()) << std::endl;\n    ss << \"secret: \" << util::HexDump(secret.Get()) << std::endl;\n    ss << \"info: \" << util::HexDump(info.Get()) << std::endl;\n    ss << \"keySize: \" << std::to_string(keySize) << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json KDF_X963::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"KDF_X963\";\n    j[\"digestType\"] = digestType.ToJSON();\n    j[\"secret\"] = secret.ToJSON();\n    j[\"info\"] = info.ToJSON();\n    j[\"keySize\"] = keySize;\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_BCRYPT code for operation.cpp"}, {"role": "assistant", "content": "std::string KDF_BCRYPT::Name(void) const { return \"KDF_BCRYPT\"; }std::string KDF_BCRYPT::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: KDF_BCRYPT\" << std::endl;\n    ss << \"digest: \" << repository::DigestToString(digestType.Get()) << std::endl;\n    ss << \"secret: \" << util::HexDump(secret.Get()) << std::endl;\n    ss << \"salt: \" << util::HexDump(salt.Get()) << std::endl;\n    ss << \"iterations: \" << std::to_string(iterations) << std::endl;\n    ss << \"keySize: \" << std::to_string(keySize) << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json KDF_BCRYPT::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"KDF_BCRYPT\";\n    j[\"digestType\"] = digestType.ToJSON();\n    j[\"secret\"] = secret.ToJSON();\n    j[\"salt\"] = salt.ToJSON();\n    j[\"iterations\"] = iterations;\n    j[\"keySize\"] = keySize;\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_SP_800_108 code for operation.cpp"}, {"role": "assistant", "content": "std::string KDF_SP_800_108::Name(void) const { return \"KDF_SP_800_108\"; }std::string KDF_SP_800_108::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: KDF_SP_800_108\" << std::endl;\n    ss << \"hmac/cmac: \" << (mech.mode ? \"HMAC\" : \"CMAC\") << std::endl;\n    if ( mech.mode == true ) {\n        ss << \"digest: \" << repository::DigestToString(mech.type.Get()) << std::endl;\n    } else {\n        ss << \"cipher: \" << repository::CipherToString(mech.type.Get()) << std::endl;\n    }\n    ss << \"secret: \" << util::HexDump(secret.Get()) << std::endl;\n    ss << \"salt: \" << util::HexDump(salt.Get()) << std::endl;\n    ss << \"label: \" << util::HexDump(label.Get()) << std::endl;\n    ss << \"mode: \" << std::to_string(mode) << std::endl;\n    ss << \"keySize: \" << std::to_string(keySize) << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json KDF_SP_800_108::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"KDF_SP_800_108\";\n    j[\"mech\"] = mech.ToJSON();\n    j[\"secret\"] = secret.ToJSON();\n    j[\"salt\"] = salt.ToJSON();\n    j[\"label\"] = label.ToJSON();\n    j[\"mode\"] = mode;\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_SRTP code for operation.cpp"}, {"role": "assistant", "content": "std::string KDF_SRTP::Name(void) const { return \"KDF_SRTP\"; }std::string KDF_SRTP::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: KDF_SRTP\" << std::endl;\n    ss << \"key: \" << util::HexDump(key.Get()) << std::endl;\n    ss << \"salt: \" << util::HexDump(salt.Get()) << std::endl;\n    ss << \"kdr: \" << std::to_string(kdr) << std::endl;\n    ss << \"index: \" << std::to_string(index) << std::endl;\n    ss << \"key1Size: \" << std::to_string(key1Size) << std::endl;\n    ss << \"key2Size: \" << std::to_string(key2Size) << std::endl;\n    ss << \"key3Size: \" << std::to_string(key3Size) << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json KDF_SRTP::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"KDF_SRTP\";\n    j[\"key\"] = key.ToJSON();\n    j[\"salt\"] = salt.ToJSON();\n    j[\"kdr\"] = kdr;\n    j[\"index\"] = index;\n    j[\"key1Size\"] = key1Size;\n    j[\"key2Size\"] = key2Size;\n    j[\"key3Size\"] = key3Size;\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_SRTCP code for operation.cpp"}, {"role": "assistant", "content": "std::string KDF_SRTCP::Name(void) const { return \"KDF_SRTCP\"; }std::string KDF_SRTCP::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: KDF_SRTCP\" << std::endl;\n    ss << \"key: \" << util::HexDump(key.Get()) << std::endl;\n    ss << \"salt: \" << util::HexDump(salt.Get()) << std::endl;\n    ss << \"kdr: \" << std::to_string(kdr) << std::endl;\n    ss << \"index: \" << std::to_string(index) << std::endl;\n    ss << \"key1Size: \" << std::to_string(key1Size) << std::endl;\n    ss << \"key2Size: \" << std::to_string(key2Size) << std::endl;\n    ss << \"key3Size: \" << std::to_string(key3Size) << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json KDF_SRTCP::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"KDF_SRTCP\";\n    j[\"key\"] = key.ToJSON();\n    j[\"salt\"] = salt.ToJSON();\n    j[\"kdr\"] = kdr;\n    j[\"index\"] = index;\n    j[\"key1Size\"] = key1Size;\n    j[\"key2Size\"] = key2Size;\n    j[\"key3Size\"] = key3Size;\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate CMAC code for operation.cpp"}, {"role": "assistant", "content": "std::string CMAC::Name(void) const { return \"CMAC\"; }std::string CMAC::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: CMAC\" << std::endl;\n    ss << \"cipher iv: \" << util::HexDump(cipher.iv.Get()) << std::endl;\n    ss << \"cipher key: \" << util::HexDump(cipher.key.Get()) << std::endl;\n    ss << \"cipher: \" << repository::CipherToString(cipher.cipherType.Get()) << std::endl;\n    ss << \"cleartext: \" << util::HexDump(cleartext.Get()) << std::endl;\n    ss << \"key: \" << util::HexDump(cipher.key.Get()) << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json CMAC::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"CMAC\";\n    j[\"cleartext\"] = cleartext.ToJSON();\n    j[\"cipher\"] = cipher.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_PrivateToPublic code for operation.cpp"}, {"role": "assistant", "content": "std::string ECC_PrivateToPublic::Name(void) const { return \"ECC_PrivateToPublic\"; }std::string ECC_PrivateToPublic::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: ECC_PrivateToPublic\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"private key: \" << priv.ToString() << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json ECC_PrivateToPublic::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"ECC_PrivateToPublic\";\n    j[\"priv\"] = priv.ToJSON();\n    j[\"curveType\"] = curveType.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_ValidatePubkey code for operation.cpp"}, {"role": "assistant", "content": "std::string ECC_ValidatePubkey::Name(void) const { return \"ECC_ValidatePubkey\"; }std::string ECC_ValidatePubkey::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: ECC_ValidatePubkey\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"public key X: \" << pub.first.ToString() << std::endl;\n    ss << \"public key Y: \" << pub.second.ToString() << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json ECC_ValidatePubkey::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"ECC_ValidatePubkey\";\n    j[\"pub_x\"] = pub.first.ToJSON();\n    j[\"pub_y\"] = pub.second.ToJSON();\n    j[\"curveType\"] = curveType.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\nECC_ValidatePubkey::ECC_ValidatePubkey(\n        const component::CurveType curveType,\n        const component::ECC_PublicKey& pub,\n        component::Modifier& modifier) :\n    Operation(std::move(modifier)),\n    curveType(curveType),\n    pub(pub)\n{ }\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_GenerateKeyPair code for operation.cpp"}, {"role": "assistant", "content": "std::string ECC_GenerateKeyPair::Name(void) const { return \"ECC_GenerateKeyPair\"; }std::string ECC_GenerateKeyPair::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: ECC_GenerateKeyPair\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json ECC_GenerateKeyPair::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"ECC_GenerateKeyPair\";\n    j[\"curveType\"] = curveType.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECCSI_Sign code for operation.cpp"}, {"role": "assistant", "content": "std::string ECCSI_Sign::Name(void) const { return \"ECCSI_Sign\"; }std::string ECCSI_Sign::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: ECCSI_Sign\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"private key: \" << priv.ToString() << std::endl;\n    ss << \"cleartext: \" << util::HexDump(cleartext.Get()) << std::endl;\n    ss << \"id: \" << util::HexDump(id.Get()) << std::endl;\n\n    ss << \"digest: \" << repository::DigestToString(digestType.Get()) << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json ECCSI_Sign::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"ECCSI_Sign\";\n    j[\"priv\"] = priv.ToJSON();\n    j[\"curveType\"] = curveType.ToJSON();\n    j[\"cleartext\"] = cleartext.ToJSON();\n    j[\"id\"] = id.ToJSON();\n    j[\"digestType\"] = digestType.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECDSA_Sign code for operation.cpp"}, {"role": "assistant", "content": "std::string ECDSA_Sign::Name(void) const { return \"ECDSA_Sign\"; }std::string ECDSA_Sign::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: ECDSA_Sign\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"nonce: \" << nonce.ToString() << std::endl;\n    ss << \"private key: \" << priv.ToString() << std::endl;\n    ss << \"cleartext: \" << util::HexDump(cleartext.Get()) << std::endl;\n    ss << \"nonce source: \";\n    if ( UseRandomNonce() ) {\n        ss << \"random\";\n    } else if ( UseRFC6979Nonce() ) {\n        ss << \"RFC 6979\";\n    } else if ( UseSpecifiedNonce() ) {\n        ss << \"specified\";\n    } else {\n        ss << \"(unknown)\";\n    }\n    ss << std::endl;\n\n    ss << \"digest: \" << repository::DigestToString(digestType.Get()) << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json ECDSA_Sign::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"ECDSA_Sign\";\n    j[\"priv\"] = priv.ToJSON();\n    j[\"nonce\"] = priv.ToJSON();\n    j[\"curveType\"] = curveType.ToJSON();\n    j[\"cleartext\"] = cleartext.ToJSON();\n    j[\"nonceSource\"] = nonceSource;\n    j[\"digestType\"] = digestType.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECGDSA_Sign code for operation.cpp"}, {"role": "assistant", "content": "std::string ECGDSA_Sign::Name(void) const { return \"ECGDSA_Sign\"; }std::string ECGDSA_Sign::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: ECGDSA_Sign\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"nonce: \" << nonce.ToString() << std::endl;\n    ss << \"private key: \" << priv.ToString() << std::endl;\n    ss << \"cleartext: \" << util::HexDump(cleartext.Get()) << std::endl;\n    ss << \"nonce source: \";\n    if ( UseRandomNonce() ) {\n        ss << \"random\";\n    } else if ( UseRFC6979Nonce() ) {\n        ss << \"RFC 6979\";\n    } else if ( UseSpecifiedNonce() ) {\n        ss << \"specified\";\n    } else {\n        ss << \"(unknown)\";\n    }\n    ss << std::endl;\n\n    ss << \"digest: \" << repository::DigestToString(digestType.Get()) << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json ECGDSA_Sign::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"ECGDSA_Sign\";\n    j[\"priv\"] = priv.ToJSON();\n    j[\"nonce\"] = priv.ToJSON();\n    j[\"curveType\"] = curveType.ToJSON();\n    j[\"cleartext\"] = cleartext.ToJSON();\n    j[\"nonceSource\"] = nonceSource;\n    j[\"digestType\"] = digestType.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECRDSA_Sign code for operation.cpp"}, {"role": "assistant", "content": "std::string ECRDSA_Sign::Name(void) const { return \"ECRDSA_Sign\"; }std::string ECRDSA_Sign::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: ECRDSA_Sign\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"nonce: \" << nonce.ToString() << std::endl;\n    ss << \"private key: \" << priv.ToString() << std::endl;\n    ss << \"cleartext: \" << util::HexDump(cleartext.Get()) << std::endl;\n    ss << \"nonce source: \";\n    if ( UseRandomNonce() ) {\n        ss << \"random\";\n    } else if ( UseRFC6979Nonce() ) {\n        ss << \"RFC 6979\";\n    } else if ( UseSpecifiedNonce() ) {\n        ss << \"specified\";\n    } else {\n        ss << \"(unknown)\";\n    }\n    ss << std::endl;\n\n    ss << \"digest: \" << repository::DigestToString(digestType.Get()) << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json ECRDSA_Sign::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"ECRDSA_Sign\";\n    j[\"priv\"] = priv.ToJSON();\n    j[\"nonce\"] = priv.ToJSON();\n    j[\"curveType\"] = curveType.ToJSON();\n    j[\"cleartext\"] = cleartext.ToJSON();\n    j[\"nonceSource\"] = nonceSource;\n    j[\"digestType\"] = digestType.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate Schnorr_Sign code for operation.cpp"}, {"role": "assistant", "content": "std::string Schnorr_Sign::Name(void) const { return \"Schnorr_Sign\"; }std::string Schnorr_Sign::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: Schnorr_Sign\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"nonce: \" << nonce.ToString() << std::endl;\n    ss << \"private key: \" << priv.ToString() << std::endl;\n    ss << \"cleartext: \" << util::HexDump(cleartext.Get()) << std::endl;\n    ss << \"nonce source: \";\n    if ( UseRandomNonce() ) {\n        ss << \"random\";\n    } else if ( UseBIP340Nonce() ) {\n        ss << \"BIP 340\";\n    } else if ( UseSpecifiedNonce() ) {\n        ss << \"specified\";\n    } else {\n        ss << \"(unknown)\";\n    }\n    ss << std::endl;\n\n    ss << \"digest: \" << repository::DigestToString(digestType.Get()) << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json Schnorr_Sign::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"Schnorr_Sign\";\n    j[\"priv\"] = priv.ToJSON();\n    j[\"nonce\"] = priv.ToJSON();\n    j[\"curveType\"] = curveType.ToJSON();\n    j[\"cleartext\"] = cleartext.ToJSON();\n    j[\"nonceSource\"] = nonceSource;\n    j[\"digestType\"] = digestType.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECCSI_Verify code for operation.cpp"}, {"role": "assistant", "content": "std::string ECCSI_Verify::Name(void) const { return \"ECCSI_Verify\"; }std::string ECCSI_Verify::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: ECCSI_Verify\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"public key X: \" << signature.pub.first.ToString() << std::endl;\n    ss << \"public key Y: \" << signature.pub.second.ToString() << std::endl;\n    ss << \"cleartext: \" << util::HexDump(cleartext.Get()) << std::endl;\n    ss << \"id: \" << util::HexDump(id.Get()) << std::endl;\n    ss << \"signature R: \" << signature.signature.first.ToString() << std::endl;\n    ss << \"signature S: \" << signature.signature.second.ToString() << std::endl;\n    ss << \"digest: \" << repository::DigestToString(digestType.Get()) << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json ECCSI_Verify::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"ECCSI_Verify\";\n    j[\"curveType\"] = curveType.ToJSON();\n    j[\"pub_x\"] = signature.pub.first.ToJSON();\n    j[\"pub_y\"] = signature.pub.second.ToJSON();\n    j[\"cleartext\"] = cleartext.ToJSON();\n    j[\"id\"] = id.ToJSON();\n    j[\"sig_r\"] = signature.signature.first.ToJSON();\n    j[\"sig_s\"] = signature.signature.second.ToJSON();\n    j[\"digestType\"] = digestType.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n/* Construct ECCSI_Verify from ECCSI_Sign */\nECCSI_Verify::ECCSI_Verify(const ECCSI_Sign& opECCSI_Sign, const component::ECCSI_Signature signature, component::Modifier modifier) :\n    Operation(std::move(modifier)),\n    curveType(opECCSI_Sign.curveType),\n    cleartext(opECCSI_Sign.cleartext),\n    id(opECCSI_Sign.id),\n    signature(signature),\n    digestType(opECCSI_Sign.digestType)\n{ }\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECDSA_Verify code for operation.cpp"}, {"role": "assistant", "content": "std::string ECDSA_Verify::Name(void) const { return \"ECDSA_Verify\"; }std::string ECDSA_Verify::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: ECDSA_Verify\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"public key X: \" << signature.pub.first.ToString() << std::endl;\n    ss << \"public key Y: \" << signature.pub.second.ToString() << std::endl;\n    ss << \"cleartext: \" << util::HexDump(cleartext.Get()) << std::endl;\n    ss << \"signature R: \" << signature.signature.first.ToString() << std::endl;\n    ss << \"signature S: \" << signature.signature.second.ToString() << std::endl;\n    ss << \"digest: \" << repository::DigestToString(digestType.Get()) << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json ECDSA_Verify::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"ECDSA_Verify\";\n    j[\"curveType\"] = curveType.ToJSON();\n    j[\"pub_x\"] = signature.pub.first.ToJSON();\n    j[\"pub_y\"] = signature.pub.second.ToJSON();\n    j[\"cleartext\"] = cleartext.ToJSON();\n    j[\"sig_r\"] = signature.signature.first.ToJSON();\n    j[\"sig_s\"] = signature.signature.second.ToJSON();\n    j[\"digestType\"] = digestType.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n/* Construct ECDSA_Verify from ECDSA_Sign */\nECDSA_Verify::ECDSA_Verify(const ECDSA_Sign& opECDSA_Sign, const component::ECDSA_Signature signature, component::Modifier modifier) :\n    Operation(std::move(modifier)),\n    curveType(opECDSA_Sign.curveType),\n    cleartext(opECDSA_Sign.cleartext),\n    signature(signature),\n    digestType(opECDSA_Sign.digestType)\n{ }\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECGDSA_Verify code for operation.cpp"}, {"role": "assistant", "content": "std::string ECGDSA_Verify::Name(void) const { return \"ECGDSA_Verify\"; }std::string ECGDSA_Verify::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: ECGDSA_Verify\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"public key X: \" << signature.pub.first.ToString() << std::endl;\n    ss << \"public key Y: \" << signature.pub.second.ToString() << std::endl;\n    ss << \"cleartext: \" << util::HexDump(cleartext.Get()) << std::endl;\n    ss << \"signature R: \" << signature.signature.first.ToString() << std::endl;\n    ss << \"signature S: \" << signature.signature.second.ToString() << std::endl;\n    ss << \"digest: \" << repository::DigestToString(digestType.Get()) << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json ECGDSA_Verify::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"ECGDSA_Verify\";\n    j[\"curveType\"] = curveType.ToJSON();\n    j[\"pub_x\"] = signature.pub.first.ToJSON();\n    j[\"pub_y\"] = signature.pub.second.ToJSON();\n    j[\"cleartext\"] = cleartext.ToJSON();\n    j[\"sig_r\"] = signature.signature.first.ToJSON();\n    j[\"sig_s\"] = signature.signature.second.ToJSON();\n    j[\"digestType\"] = digestType.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECRDSA_Verify code for operation.cpp"}, {"role": "assistant", "content": "std::string ECRDSA_Verify::Name(void) const { return \"ECRDSA_Verify\"; }std::string ECRDSA_Verify::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: ECRDSA_Verify\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"public key X: \" << signature.pub.first.ToString() << std::endl;\n    ss << \"public key Y: \" << signature.pub.second.ToString() << std::endl;\n    ss << \"cleartext: \" << util::HexDump(cleartext.Get()) << std::endl;\n    ss << \"signature R: \" << signature.signature.first.ToString() << std::endl;\n    ss << \"signature S: \" << signature.signature.second.ToString() << std::endl;\n    ss << \"digest: \" << repository::DigestToString(digestType.Get()) << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json ECRDSA_Verify::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"ECRDSA_Verify\";\n    j[\"curveType\"] = curveType.ToJSON();\n    j[\"pub_x\"] = signature.pub.first.ToJSON();\n    j[\"pub_y\"] = signature.pub.second.ToJSON();\n    j[\"cleartext\"] = cleartext.ToJSON();\n    j[\"sig_r\"] = signature.signature.first.ToJSON();\n    j[\"sig_s\"] = signature.signature.second.ToJSON();\n    j[\"digestType\"] = digestType.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate Schnorr_Verify code for operation.cpp"}, {"role": "assistant", "content": "std::string Schnorr_Verify::Name(void) const { return \"Schnorr_Verify\"; }std::string Schnorr_Verify::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: Schnorr_Verify\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"public key X: \" << signature.pub.first.ToString() << std::endl;\n    ss << \"public key Y: \" << signature.pub.second.ToString() << std::endl;\n    ss << \"cleartext: \" << util::HexDump(cleartext.Get()) << std::endl;\n    ss << \"signature R: \" << signature.signature.first.ToString() << std::endl;\n    ss << \"signature S: \" << signature.signature.second.ToString() << std::endl;\n    ss << \"digest: \" << repository::DigestToString(digestType.Get()) << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json Schnorr_Verify::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"Schnorr_Verify\";\n    j[\"curveType\"] = curveType.ToJSON();\n    j[\"pub_x\"] = signature.pub.first.ToJSON();\n    j[\"pub_y\"] = signature.pub.second.ToJSON();\n    j[\"cleartext\"] = cleartext.ToJSON();\n    j[\"sig_r\"] = signature.signature.first.ToJSON();\n    j[\"sig_s\"] = signature.signature.second.ToJSON();\n    j[\"digestType\"] = digestType.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECDSA_Recover code for operation.cpp"}, {"role": "assistant", "content": "std::string ECDSA_Recover::Name(void) const { return \"ECDSA_Recover\"; }std::string ECDSA_Recover::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: ECDSA_Recover\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"cleartext: \" << util::HexDump(cleartext.Get()) << std::endl;\n    ss << \"signature R: \" << signature.first.ToString() << std::endl;\n    ss << \"signature S: \" << signature.second.ToString() << std::endl;\n    ss << \"digest: \" << repository::DigestToString(digestType.Get()) << std::endl;\n    ss << \"recovery ID: \" << std::to_string(id) << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json ECDSA_Recover::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"ECDSA_Recover\";\n    j[\"curveType\"] = curveType.ToJSON();\n    j[\"cleartext\"] = cleartext.ToJSON();\n    j[\"sig_r\"] = signature.first.ToJSON();\n    j[\"sig_s\"] = signature.second.ToJSON();\n    j[\"id\"] = id;\n    j[\"digestType\"] = digestType.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate DSA_Verify code for operation.cpp"}, {"role": "assistant", "content": "std::string DSA_Verify::Name(void) const { return \"DSA_Verify\"; }std::string DSA_Verify::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: DSA_Verify\" << std::endl;\n    ss << \"p: \" << parameters.p.ToString() << std::endl;\n    ss << \"q: \" << parameters.q.ToString() << std::endl;\n    ss << \"g: \" << parameters.g.ToString() << std::endl;\n    ss << \"public key: \" << pub.ToString() << std::endl;\n    ss << \"r: \" << signature.first.ToString() << std::endl;\n    ss << \"s: \" << signature.second.ToString() << std::endl;\n    ss << \"cleartext: \" << util::HexDump(cleartext.Get()) << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json DSA_Verify::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"p\"] = parameters.p.ToJSON();\n    j[\"q\"] = parameters.q.ToJSON();\n    j[\"g\"] = parameters.g.ToJSON();\n    j[\"pub\"] = pub.ToJSON();\n    j[\"r\"] = signature.first.ToJSON();\n    j[\"s\"] = signature.second.ToJSON();\n    j[\"cleartext\"] = cleartext.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate DSA_Sign code for operation.cpp"}, {"role": "assistant", "content": "std::string DSA_Sign::Name(void) const { return \"DSA_Sign\"; }std::string DSA_Sign::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: DSA_Sign\" << std::endl;\n    ss << \"p: \" << parameters.p.ToString() << std::endl;\n    ss << \"q: \" << parameters.q.ToString() << std::endl;\n    ss << \"g: \" << parameters.g.ToString() << std::endl;\n    ss << \"private key: \" << priv.ToString() << std::endl;\n    ss << \"cleartext: \" << util::HexDump(cleartext.Get()) << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json DSA_Sign::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"p\"] = parameters.p.ToJSON();\n    j[\"q\"] = parameters.q.ToJSON();\n    j[\"g\"] = parameters.g.ToJSON();\n    j[\"priv\"] = priv.ToJSON();\n    j[\"cleartext\"] = cleartext.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate DSA_PrivateToPublic code for operation.cpp"}, {"role": "assistant", "content": "std::string DSA_PrivateToPublic::Name(void) const { return \"DSA_PrivateToPublic\"; }std::string DSA_PrivateToPublic::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: DSA_PrivateToPublic\" << std::endl;\n    ss << \"priv: \" << priv.ToString() << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json DSA_PrivateToPublic::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"priv\"] = priv.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate DSA_GenerateKeyPair code for operation.cpp"}, {"role": "assistant", "content": "std::string DSA_GenerateKeyPair::Name(void) const { return \"DSA_GenerateKeyPair\"; }std::string DSA_GenerateKeyPair::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: DSA_GenerateKeyPair\" << std::endl;\n    ss << \"p: \" << p.ToString() << std::endl;\n    ss << \"q: \" << q.ToString() << std::endl;\n    ss << \"g: \" << g.ToString() << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json DSA_GenerateKeyPair::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"p\"] = p.ToJSON();\n    j[\"q\"] = q.ToJSON();\n    j[\"g\"] = g.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate DSA_GenerateParameters code for operation.cpp"}, {"role": "assistant", "content": "std::string DSA_GenerateParameters::Name(void) const { return \"DSA_GenerateParameters\"; }std::string DSA_GenerateParameters::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: DSA_GenerateParameters\" << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json DSA_GenerateParameters::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECDH_Derive code for operation.cpp"}, {"role": "assistant", "content": "std::string ECDH_Derive::Name(void) const { return \"ECDH_Derive\"; }std::string ECDH_Derive::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: ECDH_Derive\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"private key: \" << priv.ToString() << std::endl;\n    ss << \"public key X: \" << pub.first.ToString() << std::endl;\n    ss << \"public key Y: \" << pub.second.ToString() << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json ECDH_Derive::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"ECDH_Derive\";\n    j[\"curveType\"] = curveType.ToJSON();\n    j[\"priv\"] = priv.ToJSON();\n    j[\"pub_x\"] = pub.first.ToJSON();\n    j[\"pub_y\"] = pub.second.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECIES_Encrypt code for operation.cpp"}, {"role": "assistant", "content": "std::string ECIES_Encrypt::Name(void) const { return \"ECIES_Encrypt\"; }std::string ECIES_Encrypt::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: ECIES_Encrypt\" << std::endl;\n    ss << \"cleartext: \" << util::HexDump(cleartext.Get()) << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"private key: \" << priv.ToString() << std::endl;\n    ss << \"public key X: \" << pub.first.ToString() << std::endl;\n    ss << \"public key Y: \" << pub.second.ToString() << std::endl;\n    ss << \"cipher: \" << repository::CipherToString(cipherType.Get()) << std::endl;\n    ss << \"iv: \" << (iv ? util::HexDump(iv->Get()) : \"nullopt\") << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json ECIES_Encrypt::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"ECIES_Encrypt\";\n    j[\"cleartext\"] = cleartext.ToJSON();\n    j[\"curveType\"] = curveType.ToJSON();\n    j[\"priv\"] = priv.ToJSON();\n    j[\"pub_x\"] = pub.first.ToJSON();\n    j[\"pub_y\"] = pub.second.ToJSON();\n    j[\"cipherType\"] = cipherType.ToJSON();\n    j[\"iv_enabled\"] = (bool)(iv != std::nullopt);\n    j[\"iv\"] = iv != std::nullopt ? iv->ToJSON() : \"\";\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECIES_Decrypt code for operation.cpp"}, {"role": "assistant", "content": "std::string ECIES_Decrypt::Name(void) const { return \"ECIES_Decrypt\"; }std::string ECIES_Decrypt::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: ECIES_Decrypt\" << std::endl;\n    ss << \"ciphertext: \" << util::HexDump(ciphertext.Get()) << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"private key: \" << priv.ToString() << std::endl;\n    ss << \"public key X: \" << pub.first.ToString() << std::endl;\n    ss << \"public key Y: \" << pub.second.ToString() << std::endl;\n    ss << \"cipher: \" << repository::CipherToString(cipherType.Get()) << std::endl;\n    ss << \"iv: \" << (iv ? util::HexDump(iv->Get()) : \"nullopt\") << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json ECIES_Decrypt::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"ECIES_Decrypt\";\n    j[\"ciphertext\"] = ciphertext.ToJSON();\n    j[\"curveType\"] = curveType.ToJSON();\n    j[\"priv\"] = priv.ToJSON();\n    j[\"pub_x\"] = pub.first.ToJSON();\n    j[\"pub_y\"] = pub.second.ToJSON();\n    j[\"cipherType\"] = cipherType.ToJSON();\n    j[\"iv_enabled\"] = (bool)(iv != std::nullopt);\n    j[\"iv\"] = iv != std::nullopt ? iv->ToJSON() : \"\";\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_Point_Add code for operation.cpp"}, {"role": "assistant", "content": "std::string ECC_Point_Add::Name(void) const { return \"ECC_Point_Add\"; }std::string ECC_Point_Add::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: ECC_Point_Add\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"A X: \" << a.first.ToString() << std::endl;\n    ss << \"A Y: \" << a.second.ToString() << std::endl;\n    ss << \"B X: \" << b.first.ToString() << std::endl;\n    ss << \"B Y: \" << b.second.ToString() << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json ECC_Point_Add::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"ECC_Point_Add\";\n    j[\"curveType\"] = curveType.ToJSON();\n\n    j[\"a_x\"] = a.first.ToJSON();\n    j[\"a_y\"] = a.second.ToJSON();\n\n    j[\"b_x\"] = b.first.ToJSON();\n    j[\"b_y\"] = b.second.ToJSON();\n\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_Point_Sub code for operation.cpp"}, {"role": "assistant", "content": "std::string ECC_Point_Sub::Name(void) const { return \"ECC_Point_Sub\"; }std::string ECC_Point_Sub::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: ECC_Point_Sub\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"A X: \" << a.first.ToString() << std::endl;\n    ss << \"A Y: \" << a.second.ToString() << std::endl;\n    ss << \"B X: \" << b.first.ToString() << std::endl;\n    ss << \"B Y: \" << b.second.ToString() << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json ECC_Point_Sub::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"ECC_Point_Sub\";\n    j[\"curveType\"] = curveType.ToJSON();\n\n    j[\"a_x\"] = a.first.ToJSON();\n    j[\"a_y\"] = a.second.ToJSON();\n\n    j[\"b_x\"] = b.first.ToJSON();\n    j[\"b_y\"] = b.second.ToJSON();\n\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_Point_Mul code for operation.cpp"}, {"role": "assistant", "content": "std::string ECC_Point_Mul::Name(void) const { return \"ECC_Point_Mul\"; }std::string ECC_Point_Mul::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: ECC_Point_Mul\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"A X: \" << a.first.ToString() << std::endl;\n    ss << \"A Y: \" << a.second.ToString() << std::endl;\n    ss << \"B: \" << b.ToString() << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json ECC_Point_Mul::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"ECC_Point_Mul\";\n    j[\"curveType\"] = curveType.ToJSON();\n\n    j[\"a_x\"] = a.first.ToJSON();\n    j[\"a_y\"] = a.second.ToJSON();\n\n    j[\"b\"] = b.ToJSON();\n\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_Point_Neg code for operation.cpp"}, {"role": "assistant", "content": "std::string ECC_Point_Neg::Name(void) const { return \"ECC_Point_Neg\"; }std::string ECC_Point_Neg::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: ECC_Point_Neg\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"A X: \" << a.first.ToString() << std::endl;\n    ss << \"A Y: \" << a.second.ToString() << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json ECC_Point_Neg::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"curveType\"] = curveType.ToJSON();\n\n    j[\"a_x\"] = a.first.ToJSON();\n    j[\"a_y\"] = a.second.ToJSON();\n\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_Point_Dbl code for operation.cpp"}, {"role": "assistant", "content": "std::string ECC_Point_Dbl::Name(void) const { return \"ECC_Point_Dbl\"; }std::string ECC_Point_Dbl::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: ECC_Point_Dbl\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"A X: \" << a.first.ToString() << std::endl;\n    ss << \"A Y: \" << a.second.ToString() << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json ECC_Point_Dbl::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"curveType\"] = curveType.ToJSON();\n\n    j[\"a_x\"] = a.first.ToJSON();\n    j[\"a_y\"] = a.second.ToJSON();\n\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_Point_Cmp code for operation.cpp"}, {"role": "assistant", "content": "std::string ECC_Point_Cmp::Name(void) const { return \"ECC_Point_Cmp\"; }std::string ECC_Point_Cmp::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: ECC_Point_Cmp\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"A X: \" << a.first.ToString() << std::endl;\n    ss << \"A Y: \" << a.second.ToString() << std::endl;\n    ss << \"B X: \" << b.first.ToString() << std::endl;\n    ss << \"B Y: \" << b.second.ToString() << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json ECC_Point_Cmp::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"ECC_Point_Cmp\";\n    j[\"curveType\"] = curveType.ToJSON();\n\n    j[\"a_x\"] = a.first.ToJSON();\n    j[\"a_y\"] = a.second.ToJSON();\n\n    j[\"b_x\"] = b.first.ToJSON();\n    j[\"b_y\"] = b.second.ToJSON();\n\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate DH_GenerateKeyPair code for operation.cpp"}, {"role": "assistant", "content": "std::string DH_GenerateKeyPair::Name(void) const { return \"DH_GenerateKeyPair\"; }std::string DH_GenerateKeyPair::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: DH_GenerateKeyPair\" << std::endl;\n    ss << \"prime: \" << prime.ToString() << std::endl;\n    ss << \"base: \" << base.ToString() << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json DH_GenerateKeyPair::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"DH_GenerateKeyPair\";\n    j[\"prime\"] = prime.ToJSON();\n    j[\"base\"] = base.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate DH_Derive code for operation.cpp"}, {"role": "assistant", "content": "std::string DH_Derive::Name(void) const { return \"DH_Derive\"; }std::string DH_Derive::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: DH_Derive\" << std::endl;\n    ss << \"prime: \" << prime.ToString() << std::endl;\n    ss << \"base: \" << base.ToString() << std::endl;\n    ss << \"public key: \" << pub.ToString() << std::endl;\n    ss << \"private key: \" << priv.ToString() << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json DH_Derive::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"DH_Derive\";\n    j[\"prime\"] = prime.ToJSON();\n    j[\"base\"] = base.ToJSON();\n    j[\"pub\"] = pub.ToJSON();\n    j[\"priv\"] = priv.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc code for operation.cpp"}, {"role": "assistant", "content": "std::string BignumCalc::Name(void) const { return \"BignumCalc\"; }std::string BignumCalc::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: BignumCalc\" << std::endl;\n    ss << \"calc operation: \" << repository::CalcOpToString(calcOp.Get()) << std::endl;\n    ss << \"bignum 1: \" << bn0.ToString() << std::endl;\n    ss << \"bignum 2: \" << bn1.ToString() << std::endl;\n    ss << \"bignum 3: \" << bn2.ToString() << std::endl;\n    ss << \"bignum 4: \" << bn3.ToString() << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json BignumCalc::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"BignumCalc\";\n    j[\"calcOp\"] = calcOp.ToJSON();\n    j[\"bn0\"] = bn0.ToJSON();\n    j[\"bn1\"] = bn1.ToJSON();\n    j[\"bn2\"] = bn2.ToJSON();\n    j[\"bn3\"] = bn3.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Fp2 code for operation.cpp"}, {"role": "assistant", "content": "std::string BignumCalc_Fp2::Name(void) const { return \"BignumCalc_Fp2\"; }std::string BignumCalc_Fp2::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: BignumCalc_Fp2\" << std::endl;\n    ss << \"calc operation: \" << repository::CalcOpToString(calcOp.Get()) << std::endl;\n    ss << \"Fp2 1 x: \" << bn0.first.ToString() << std::endl;\n    ss << \"Fp2 1 x: \" << bn0.second.ToString() << std::endl;\n    ss << \"Fp2 2 x: \" << bn1.first.ToString() << std::endl;\n    ss << \"Fp2 2 x: \" << bn1.second.ToString() << std::endl;\n    ss << \"Fp2 3 x: \" << bn2.first.ToString() << std::endl;\n    ss << \"Fp2 3 x: \" << bn2.second.ToString() << std::endl;\n    ss << \"Fp2 4 x: \" << bn3.first.ToString() << std::endl;\n    ss << \"Fp2 4 x: \" << bn3.second.ToString() << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json BignumCalc_Fp2::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"BignumCalc\";\n    j[\"calcOp\"] = calcOp.ToJSON();\n    j[\"bn0\"] = bn0.ToJSON();\n    j[\"bn1\"] = bn1.ToJSON();\n    j[\"bn2\"] = bn2.ToJSON();\n    j[\"bn3\"] = bn3.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Fp12 code for operation.cpp"}, {"role": "assistant", "content": "std::string BignumCalc_Fp12::Name(void) const { return \"BignumCalc_Fp12\"; }std::string BignumCalc_Fp12::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: BignumCalc_Fp12\" << std::endl;\n    ss << \"calc operation: \" << repository::CalcOpToString(calcOp.Get()) << std::endl;\n    ss << \"bn0 1: \" << bn0.bn1.ToString() << std::endl;\n    ss << \"bn0 2: \" << bn0.bn2.ToString() << std::endl;\n    ss << \"bn0 3: \" << bn0.bn3.ToString() << std::endl;\n    ss << \"bn0 4: \" << bn0.bn4.ToString() << std::endl;\n    ss << \"bn0 5: \" << bn0.bn5.ToString() << std::endl;\n    ss << \"bn0 6: \" << bn0.bn6.ToString() << std::endl;\n    ss << \"bn0 7: \" << bn0.bn7.ToString() << std::endl;\n    ss << \"bn0 8: \" << bn0.bn8.ToString() << std::endl;\n    ss << \"bn0 9: \" << bn0.bn9.ToString() << std::endl;\n    ss << \"bn0 10: \" << bn0.bn10.ToString() << std::endl;\n    ss << \"bn0 11: \" << bn0.bn11.ToString() << std::endl;\n    ss << \"bn0 12: \" << bn0.bn12.ToString() << std::endl;\n\n    ss << std::endl;\n\n    ss << \"bn1 1: \" << bn1.bn1.ToString() << std::endl;\n    ss << \"bn1 2: \" << bn1.bn2.ToString() << std::endl;\n    ss << \"bn1 3: \" << bn1.bn3.ToString() << std::endl;\n    ss << \"bn1 4: \" << bn1.bn4.ToString() << std::endl;\n    ss << \"bn1 5: \" << bn1.bn5.ToString() << std::endl;\n    ss << \"bn1 6: \" << bn1.bn6.ToString() << std::endl;\n    ss << \"bn1 7: \" << bn1.bn7.ToString() << std::endl;\n    ss << \"bn1 8: \" << bn1.bn8.ToString() << std::endl;\n    ss << \"bn1 9: \" << bn1.bn9.ToString() << std::endl;\n    ss << \"bn1 10: \" << bn1.bn10.ToString() << std::endl;\n    ss << \"bn1 11: \" << bn1.bn11.ToString() << std::endl;\n    ss << \"bn1 12: \" << bn1.bn12.ToString() << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json BignumCalc_Fp12::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"BignumCalc\";\n    j[\"calcOp\"] = calcOp.ToJSON();\n    j[\"bn0\"] = bn0.ToJSON();\n    j[\"bn1\"] = bn1.ToJSON();\n    j[\"bn2\"] = bn2.ToJSON();\n    j[\"bn3\"] = bn3.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_PrivateToPublic code for operation.cpp"}, {"role": "assistant", "content": "std::string BLS_PrivateToPublic::Name(void) const { return \"BLS_PrivateToPublic\"; }std::string BLS_PrivateToPublic::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: BLS_PrivateToPublic\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"private key: \" << priv.ToString() << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json BLS_PrivateToPublic::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"BLS_PrivateToPublic\";\n    j[\"priv\"] = priv.ToJSON();\n    j[\"curveType\"] = curveType.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_PrivateToPublic_G2 code for operation.cpp"}, {"role": "assistant", "content": "std::string BLS_PrivateToPublic_G2::Name(void) const { return \"BLS_PrivateToPublic_G2\"; }std::string BLS_PrivateToPublic_G2::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: BLS_PrivateToPublic_G2\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"private key: \" << priv.ToString() << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json BLS_PrivateToPublic_G2::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"BLS_PrivateToPublic_G2\";\n    j[\"priv\"] = priv.ToJSON();\n    j[\"curveType\"] = curveType.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_Sign code for operation.cpp"}, {"role": "assistant", "content": "std::string BLS_Sign::Name(void) const { return \"BLS_Sign\"; }std::string BLS_Sign::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: BLS_Sign\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"private key: \" << priv.ToString() << std::endl;\n    if ( hashOrPoint == true ) {\n        ss << \"cleartext: \" << util::HexDump(cleartext.Get()) << std::endl;\n    } else {\n        ss << \"point V: \" << point.first.first.ToString() << std::endl;\n        ss << \"point W: \" << point.first.second.ToString() << std::endl;\n        ss << \"point X: \" << point.second.first.ToString() << std::endl;\n        ss << \"point Y: \" << point.second.second.ToString() << std::endl;\n    }\n    ss << \"dest: \" << util::HexDump(dest.Get()) << std::endl;\n    ss << \"aug: \" << util::HexDump(aug.Get()) << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json BLS_Sign::ToJSON(void) const {\n    nlohmann::json j;\n\n    j[\"operation\"] = \"BLS_Sign\";\n    j[\"curveType\"] = curveType.ToJSON();\n\n    j[\"hashOrPoint\"] = hashOrPoint;\n\n    j[\"priv\"] = priv.ToJSON();\n\n    if ( hashOrPoint == true ) {\n        j[\"cleartext\"] = cleartext.ToJSON();\n    } else {\n        j[\"g2_v\"] = point.first.first.ToJSON();\n        j[\"g2_w\"] = point.first.second.ToJSON();\n        j[\"g2_x\"] = point.second.first.ToJSON();\n        j[\"g2_y\"] = point.second.second.ToJSON();\n    }\n    j[\"dest\"] = dest.ToJSON();\n    j[\"aug\"] = aug.ToJSON();\n\n    j[\"modifier\"] = modifier.ToJSON();\n\n    return j;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_Verify code for operation.cpp"}, {"role": "assistant", "content": "std::string BLS_Verify::Name(void) const { return \"BLS_Verify\"; }std::string BLS_Verify::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: BLS_Verify\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"public key X: \" << pub.first.ToString() << std::endl;\n    ss << \"public key Y: \" << pub.second.ToString() << std::endl;\n    ss << \"cleartext: \" << util::HexDump(cleartext.Get()) << std::endl;\n    ss << \"signature V: \" << signature.first.first.ToString() << std::endl;\n    ss << \"signature W: \" << signature.first.second.ToString() << std::endl;\n    ss << \"signature X: \" << signature.second.first.ToString() << std::endl;\n    ss << \"signature Y: \" << signature.second.second.ToString() << std::endl;\n    ss << \"dest: \" << util::HexDump(dest.Get()) << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json BLS_Verify::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"BLS_Verify\";\n    j[\"curveType\"] = curveType.ToJSON();\n\n    j[\"cleartext\"] = cleartext.ToJSON();\n\n    j[\"g1_x\"] = pub.first.ToJSON();\n    j[\"g1_y\"] = pub.second.ToJSON();\n\n    j[\"g2_v\"] = signature.first.first.ToJSON();\n    j[\"g2_w\"] = signature.first.second.ToJSON();\n    j[\"g2_x\"] = signature.second.first.ToJSON();\n    j[\"g2_y\"] = signature.second.second.ToJSON();\n\n    j[\"dest\"] = dest.ToJSON();\n\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_BatchSign code for operation.cpp"}, {"role": "assistant", "content": "std::string BLS_BatchSign::Name(void) const { return \"BLS_BatchSign\"; }std::string BLS_BatchSign::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: BLS_BatchSign\" << std::endl;\n\n    for (const auto& cur : bf.c) {\n        ss << \"priv: \" << cur.priv.ToString() << std::endl;\n        ss << \"G1 X: \" << cur.g1.first.ToString() << std::endl;\n        ss << \"G1 Y: \" << cur.g1.second.ToString() << std::endl;\n    }\n    return ss.str();\n}\n\nnlohmann::json BLS_BatchSign::ToJSON(void) const {\n    nlohmann::json j;\n    /* TODO */\n    return j;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_BatchVerify code for operation.cpp"}, {"role": "assistant", "content": "std::string BLS_BatchVerify::Name(void) const { return \"BLS_BatchVerify\"; }std::string BLS_BatchVerify::ToString(void) const {\n    std::stringstream ss;\n\n    for (const auto& cur : bf.c) {\n        ss << \"G1 X: \" << cur.g1.first.ToString() << std::endl;\n        ss << \"G1 Y: \" << cur.g1.second.ToString() << std::endl;\n        ss << std::endl;\n        ss << \"G2 V: \" << cur.g2.first.first.ToString() << std::endl;\n        ss << \"G2 W: \" << cur.g2.first.second.ToString() << std::endl;\n        ss << \"G2 X: \" << cur.g2.second.first.ToString() << std::endl;\n        ss << \"G2 Y: \" << cur.g2.second.second.ToString() << std::endl;\n        ss << \"----------\" << std::endl;\n    }\n\n    /* TODO */\n    return ss.str();\n}\n\nnlohmann::json BLS_BatchVerify::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"BLS_BatchVerify\";\n    j[\"modifier\"] = modifier.ToJSON();\n    j[\"bf\"] = bf.ToJSON();\n    return j;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_Pairing code for operation.cpp"}, {"role": "assistant", "content": "std::string BLS_Pairing::Name(void) const { return \"BLS_Pairing\"; }std::string BLS_Pairing::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: BLS_Pairing\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"G1 X: \" << g1.first.ToString() << std::endl;\n    ss << \"G1 Y: \" << g1.second.ToString() << std::endl;\n    ss << \"G2 V: \" << g2.first.first.ToString() << std::endl;\n    ss << \"G2 W: \" << g2.first.second.ToString() << std::endl;\n    ss << \"G2 X: \" << g2.second.first.ToString() << std::endl;\n    ss << \"G2 Y: \" << g2.second.second.ToString() << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json BLS_Pairing::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"BLS_Pairing\";\n    j[\"curveType\"] = curveType.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n    j[\"g1_x\"] = g1.first.ToJSON();\n    j[\"g1_y\"] = g1.second.ToJSON();\n    j[\"g2_v\"] = g2.first.first.ToJSON();\n    j[\"g2_w\"] = g2.first.second.ToJSON();\n    j[\"g2_x\"] = g2.second.first.ToJSON();\n    j[\"g2_y\"] = g2.second.second.ToJSON();\n    return j;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_MillerLoop code for operation.cpp"}, {"role": "assistant", "content": "std::string BLS_MillerLoop::Name(void) const { return \"BLS_MillerLoop\"; }std::string BLS_MillerLoop::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: BLS_MillerLoop\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"G1 X: \" << g1.first.ToString() << std::endl;\n    ss << \"G1 Y: \" << g1.second.ToString() << std::endl;\n    ss << \"G2 V: \" << g2.first.first.ToString() << std::endl;\n    ss << \"G2 W: \" << g2.first.second.ToString() << std::endl;\n    ss << \"G2 X: \" << g2.second.first.ToString() << std::endl;\n    ss << \"G2 Y: \" << g2.second.second.ToString() << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json BLS_MillerLoop::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"curveType\"] = curveType.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_FinalExp code for operation.cpp"}, {"role": "assistant", "content": "std::string BLS_FinalExp::Name(void) const { return \"BLS_FinalExp\"; }std::string BLS_FinalExp::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: BLS_FinalExp\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"Fp12 c0.b0.a0: \" << fp12.bn1.ToString() << std::endl;\n    ss << \"Fp12 c0.b0.a1: \" << fp12.bn2.ToString() << std::endl;\n    ss << \"Fp12 c0.b1.a0: \" << fp12.bn3.ToString() << std::endl;\n    ss << \"Fp12 c0.b1.a1: \" << fp12.bn4.ToString() << std::endl;\n    ss << \"Fp12 c0.b2.a0: \" << fp12.bn5.ToString() << std::endl;\n    ss << \"Fp12 c0.b2.a1: \" << fp12.bn6.ToString() << std::endl;\n    ss << \"Fp12 c1.b0.a0: \" << fp12.bn7.ToString() << std::endl;\n    ss << \"Fp12 c1.b0.a1: \" << fp12.bn8.ToString() << std::endl;\n    ss << \"Fp12 c1.b1.a0: \" << fp12.bn9.ToString() << std::endl;\n    ss << \"Fp12 c1.b1.a1: \" << fp12.bn10.ToString() << std::endl;\n    ss << \"Fp12 c1.b2.a0: \" << fp12.bn11.ToString() << std::endl;\n    ss << \"Fp12 c1.b2.a1: \" << fp12.bn12.ToString() << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json BLS_FinalExp::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"BLS_FinalExp\";\n    j[\"curveType\"] = curveType.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n    j[\"fp12\"] = fp12.ToJSON();\n    return j;\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_Aggregate_G1 code for operation.cpp"}, {"role": "assistant", "content": "std::string BLS_Aggregate_G1::Name(void) const { return \"BLS_Aggregate_G1\"; }std::string BLS_Aggregate_G1::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: BLS_Aggregate_G1\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n\n    for (const auto& g1 : points.points) {\n        ss << \"    X: \" << g1.first.ToString() << std::endl;\n        ss << \"    Y: \" << g1.second.ToString() << std::endl;\n        ss << std::endl;\n    }\n\n    return ss.str();\n}\n\nnlohmann::json BLS_Aggregate_G1::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"BLS_Aggregate_G1\";\n    j[\"curveType\"] = curveType.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n\n    nlohmann::json points_json = nlohmann::json::array();\n\n    for (const auto& g1 : points.points) {\n        nlohmann::json point;\n\n        point[\"x\"] = g1.first.ToJSON();\n        point[\"y\"] = g1.second.ToJSON();\n\n        points_json.push_back(point);\n    }\n\n    j[\"points\"] = points_json;\n\n    return j;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_Aggregate_G2 code for operation.cpp"}, {"role": "assistant", "content": "std::string BLS_Aggregate_G2::Name(void) const { return \"BLS_Aggregate_G2\"; }std::string BLS_Aggregate_G2::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: BLS_Aggregate_G2\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n\n    for (const auto& g2 : points.points) {\n        ss << \"    V:\" << g2.first.first.ToString() << std::endl;\n        ss << \"    W:\" << g2.first.second.ToString() << std::endl;\n        ss << \"    X:\" << g2.second.first.ToString() << std::endl;\n        ss << \"    Y:\" << g2.second.second.ToString() << std::endl;\n        ss << std::endl;\n    }\n\n    return ss.str();\n}\n\nnlohmann::json BLS_Aggregate_G2::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"BLS_Aggregate_G2\";\n    j[\"curveType\"] = curveType.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n\n    nlohmann::json points_json = nlohmann::json::array();\n\n    for (const auto& g2 : points.points) {\n        nlohmann::json point;\n\n        point[\"v\"] = g2.first.first.ToJSON();\n        point[\"w\"] = g2.first.second.ToJSON();\n        point[\"x\"] = g2.second.first.ToJSON();\n        point[\"y\"] = g2.second.second.ToJSON();\n\n        points_json.push_back(point);\n    }\n\n    j[\"points\"] = points_json;\n    return j;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_HashToG1 code for operation.cpp"}, {"role": "assistant", "content": "std::string BLS_HashToG1::Name(void) const { return \"BLS_HashToG1\"; }std::string BLS_HashToG1::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: BLS_HashToG1\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"cleartext: \" << util::HexDump(cleartext.Get()) << std::endl;\n    ss << \"dest: \" << util::HexDump(dest.Get()) << std::endl;\n    ss << \"aug: \" << util::HexDump(aug.Get()) << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json BLS_HashToG1::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"BLS_HashToG1\";\n    j[\"curveType\"] = curveType.ToJSON();\n    j[\"cleartext\"] = cleartext.ToJSON();\n    j[\"dest\"] = dest.ToJSON();\n    j[\"aug\"] = aug.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_HashToG2 code for operation.cpp"}, {"role": "assistant", "content": "std::string BLS_HashToG2::Name(void) const { return \"BLS_HashToG2\"; }std::string BLS_HashToG2::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: BLS_HashToG2\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"cleartext: \" << util::HexDump(cleartext.Get()) << std::endl;\n    ss << \"dest: \" << util::HexDump(dest.Get()) << std::endl;\n    ss << \"aug: \" << util::HexDump(aug.Get()) << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json BLS_HashToG2::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"BLS_HashToG2\";\n    j[\"curveType\"] = curveType.ToJSON();\n    j[\"cleartext\"] = cleartext.ToJSON();\n    j[\"dest\"] = dest.ToJSON();\n    j[\"aug\"] = aug.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_MapToG1 code for operation.cpp"}, {"role": "assistant", "content": "std::string BLS_MapToG1::Name(void) const { return \"BLS_MapToG1\"; }std::string BLS_MapToG1::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: BLS_MapToG1\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"u: \" << u.ToString() << std::endl;\n    ss << \"v: \" << v.ToString() << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json BLS_MapToG1::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"BLS_MapToG1\";\n    j[\"curveType\"] = curveType.ToJSON();\n    j[\"u\"] = u.ToJSON();\n    j[\"v\"] = v.ToJSON();\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_MapToG2 code for operation.cpp"}, {"role": "assistant", "content": "std::string BLS_MapToG2::Name(void) const { return \"BLS_MapToG2\"; }std::string BLS_MapToG2::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: BLS_MapToG2\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"u_x: \" << u.first.ToString() << std::endl;\n    ss << \"u_y: \" << u.second.ToString() << std::endl;\n    ss << \"v_x: \" << v.first.ToString() << std::endl;\n    ss << \"v_y: \" << v.second.ToString() << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json BLS_MapToG2::ToJSON(void) const {\n    nlohmann::json j;\n\n    j[\"operation\"] = \"BLS_MapToG2\";\n    j[\"u_x\"] = u.first.ToJSON();\n    j[\"u_y\"] = u.second.ToJSON();\n    j[\"v_x\"] = v.first.ToJSON();\n    j[\"v_y\"] = v.second.ToJSON();\n\n    return j;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_IsG1OnCurve code for operation.cpp"}, {"role": "assistant", "content": "std::string BLS_IsG1OnCurve::Name(void) const { return \"BLS_IsG1OnCurve\"; }std::string BLS_IsG1OnCurve::ToString(void) const {\n    std::stringstream ss;\n\n    ss << \"operation name: BLS_IsG1OnCurve\" << std::endl;\n    ss << \"ecc curve: \" << repository::ECC_CurveToString(curveType.Get()) << std::endl;\n    ss << \"G1 X: \" << g1.first.ToString() << std::endl;\n    ss << \"G1 Y: \" << g1.second.ToString() << std::endl;\n\n    return ss.str();\n}\n\nnlohmann::json BLS_IsG1OnCurve::ToJSON(void) const {\n    nlohmann::json j;\n    j[\"operation\"] = \"BLS_IsG1OnCurve\";\n    j[\"curveType\"] = curveType.ToJSON();\n\n    j[\"g1_x\"] = g1.first.ToJSON();\n    j[\"g1_y\"] = g1.second.ToJSON();\n\n    j[\"modifier\"] = modifier.ToJSON();\n    return j;\n}\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc code for executor.h"}, {"role": "assistant", "content": "class ExecutorBignumCalc : public ExecutorBase<component::Bignum, operation::BignumCalc> {    private:\n        std::optional<component::Bignum> callModule(std::shared_ptr<Module> module, operation::BignumCalc& op) const override;\n    protected:\n        std::optional<component::Bignum> modulo = std::nullopt;\n    public:\n        ExecutorBignumCalc(const uint64_t operationID, const std::map<uint64_t, std::shared_ptr<Module> >& modules, const Options& options);\n        void SetModulo(const std::string& modulo);\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_BLS12_381_R code for executor.h"}, {"role": "assistant", "content": "class ExecutorBignumCalc_Mod_BLS12_381_R : public ExecutorBignumCalc {    public:\n        ExecutorBignumCalc_Mod_BLS12_381_R(const uint64_t operationID, const std::map<uint64_t, std::shared_ptr<Module> >& modules, const Options& options);\n        operation::BignumCalc getOpPostprocess(Datasource* parentDs, operation::BignumCalc op) const override;\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_BLS12_381_P code for executor.h"}, {"role": "assistant", "content": "class ExecutorBignumCalc_Mod_BLS12_381_P : public ExecutorBignumCalc {    public:\n        ExecutorBignumCalc_Mod_BLS12_381_P(const uint64_t operationID, const std::map<uint64_t, std::shared_ptr<Module> >& modules, const Options& options);\n        operation::BignumCalc getOpPostprocess(Datasource* parentDs, operation::BignumCalc op) const override;\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_BLS12_377_R code for executor.h"}, {"role": "assistant", "content": "class ExecutorBignumCalc_Mod_BLS12_377_R : public ExecutorBignumCalc {    public:\n        ExecutorBignumCalc_Mod_BLS12_377_R(const uint64_t operationID, const std::map<uint64_t, std::shared_ptr<Module> >& modules, const Options& options);\n        operation::BignumCalc getOpPostprocess(Datasource* parentDs, operation::BignumCalc op) const override;\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_BLS12_377_P code for executor.h"}, {"role": "assistant", "content": "class ExecutorBignumCalc_Mod_BLS12_377_P : public ExecutorBignumCalc {    public:\n        ExecutorBignumCalc_Mod_BLS12_377_P(const uint64_t operationID, const std::map<uint64_t, std::shared_ptr<Module> >& modules, const Options& options);\n        operation::BignumCalc getOpPostprocess(Datasource* parentDs, operation::BignumCalc op) const override;\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_BN128_R code for executor.h"}, {"role": "assistant", "content": "class ExecutorBignumCalc_Mod_BN128_R : public ExecutorBignumCalc {    public:\n        ExecutorBignumCalc_Mod_BN128_R(const uint64_t operationID, const std::map<uint64_t, std::shared_ptr<Module> >& modules, const Options& options);\n        operation::BignumCalc getOpPostprocess(Datasource* parentDs, operation::BignumCalc op) const override;\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_BN128_P code for executor.h"}, {"role": "assistant", "content": "class ExecutorBignumCalc_Mod_BN128_P : public ExecutorBignumCalc {    public:\n        ExecutorBignumCalc_Mod_BN128_P(const uint64_t operationID, const std::map<uint64_t, std::shared_ptr<Module> >& modules, const Options& options);\n        operation::BignumCalc getOpPostprocess(Datasource* parentDs, operation::BignumCalc op) const override;\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_Vesta_R code for executor.h"}, {"role": "assistant", "content": "class ExecutorBignumCalc_Mod_Vesta_R : public ExecutorBignumCalc {    public:\n        ExecutorBignumCalc_Mod_Vesta_R(const uint64_t operationID, const std::map<uint64_t, std::shared_ptr<Module> >& modules, const Options& options);\n        operation::BignumCalc getOpPostprocess(Datasource* parentDs, operation::BignumCalc op) const override;\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_Vesta_P code for executor.h"}, {"role": "assistant", "content": "class ExecutorBignumCalc_Mod_Vesta_P : public ExecutorBignumCalc {    public:\n        ExecutorBignumCalc_Mod_Vesta_P(const uint64_t operationID, const std::map<uint64_t, std::shared_ptr<Module> >& modules, const Options& options);\n        operation::BignumCalc getOpPostprocess(Datasource* parentDs, operation::BignumCalc op) const override;\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_ED25519 code for executor.h"}, {"role": "assistant", "content": "class ExecutorBignumCalc_Mod_ED25519 : public ExecutorBignumCalc {    public:\n        ExecutorBignumCalc_Mod_ED25519(const uint64_t operationID, const std::map<uint64_t, std::shared_ptr<Module> >& modules, const Options& options);\n        operation::BignumCalc getOpPostprocess(Datasource* parentDs, operation::BignumCalc op) const override;\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_Edwards_R code for executor.h"}, {"role": "assistant", "content": "class ExecutorBignumCalc_Mod_Edwards_R : public ExecutorBignumCalc {    public:\n        ExecutorBignumCalc_Mod_Edwards_R(const uint64_t operationID, const std::map<uint64_t, std::shared_ptr<Module> >& modules, const Options& options);\n        operation::BignumCalc getOpPostprocess(Datasource* parentDs, operation::BignumCalc op) const override;\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_Edwards_P code for executor.h"}, {"role": "assistant", "content": "class ExecutorBignumCalc_Mod_Edwards_P : public ExecutorBignumCalc {    public:\n        ExecutorBignumCalc_Mod_Edwards_P(const uint64_t operationID, const std::map<uint64_t, std::shared_ptr<Module> >& modules, const Options& options);\n        operation::BignumCalc getOpPostprocess(Datasource* parentDs, operation::BignumCalc op) const override;\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_Goldilocks code for executor.h"}, {"role": "assistant", "content": "class ExecutorBignumCalc_Mod_Goldilocks : public ExecutorBignumCalc {    public:\n        ExecutorBignumCalc_Mod_Goldilocks(const uint64_t operationID, const std::map<uint64_t, std::shared_ptr<Module> >& modules, const Options& options);\n        operation::BignumCalc getOpPostprocess(Datasource* parentDs, operation::BignumCalc op) const override;\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_MNT4_R code for executor.h"}, {"role": "assistant", "content": "class ExecutorBignumCalc_Mod_MNT4_R : public ExecutorBignumCalc {    public:\n        ExecutorBignumCalc_Mod_MNT4_R(const uint64_t operationID, const std::map<uint64_t, std::shared_ptr<Module> >& modules, const Options& options);\n        operation::BignumCalc getOpPostprocess(Datasource* parentDs, operation::BignumCalc op) const override;\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_MNT4_P code for executor.h"}, {"role": "assistant", "content": "class ExecutorBignumCalc_Mod_MNT4_P : public ExecutorBignumCalc {    public:\n        ExecutorBignumCalc_Mod_MNT4_P(const uint64_t operationID, const std::map<uint64_t, std::shared_ptr<Module> >& modules, const Options& options);\n        operation::BignumCalc getOpPostprocess(Datasource* parentDs, operation::BignumCalc op) const override;\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_MNT6_R code for executor.h"}, {"role": "assistant", "content": "class ExecutorBignumCalc_Mod_MNT6_R : public ExecutorBignumCalc {    public:\n        ExecutorBignumCalc_Mod_MNT6_R(const uint64_t operationID, const std::map<uint64_t, std::shared_ptr<Module> >& modules, const Options& options);\n        operation::BignumCalc getOpPostprocess(Datasource* parentDs, operation::BignumCalc op) const override;\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_MNT6_P code for executor.h"}, {"role": "assistant", "content": "class ExecutorBignumCalc_Mod_MNT6_P : public ExecutorBignumCalc {    public:\n        ExecutorBignumCalc_Mod_MNT6_P(const uint64_t operationID, const std::map<uint64_t, std::shared_ptr<Module> >& modules, const Options& options);\n        operation::BignumCalc getOpPostprocess(Datasource* parentDs, operation::BignumCalc op) const override;\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_2Exp64 code for executor.h"}, {"role": "assistant", "content": "class ExecutorBignumCalc_Mod_2Exp64 : public ExecutorBignumCalc {    public:\n        ExecutorBignumCalc_Mod_2Exp64(const uint64_t operationID, const std::map<uint64_t, std::shared_ptr<Module> >& modules, const Options& options);\n        operation::BignumCalc getOpPostprocess(Datasource* parentDs, operation::BignumCalc op) const override;\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_2Exp128 code for executor.h"}, {"role": "assistant", "content": "class ExecutorBignumCalc_Mod_2Exp128 : public ExecutorBignumCalc {    public:\n        ExecutorBignumCalc_Mod_2Exp128(const uint64_t operationID, const std::map<uint64_t, std::shared_ptr<Module> >& modules, const Options& options);\n        operation::BignumCalc getOpPostprocess(Datasource* parentDs, operation::BignumCalc op) const override;\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_2Exp256 code for executor.h"}, {"role": "assistant", "content": "class ExecutorBignumCalc_Mod_2Exp256 : public ExecutorBignumCalc {    public:\n        ExecutorBignumCalc_Mod_2Exp256(const uint64_t operationID, const std::map<uint64_t, std::shared_ptr<Module> >& modules, const Options& options);\n        operation::BignumCalc getOpPostprocess(Datasource* parentDs, operation::BignumCalc op) const override;\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_2Exp512 code for executor.h"}, {"role": "assistant", "content": "class ExecutorBignumCalc_Mod_2Exp512 : public ExecutorBignumCalc {    public:\n        ExecutorBignumCalc_Mod_2Exp512(const uint64_t operationID, const std::map<uint64_t, std::shared_ptr<Module> >& modules, const Options& options);\n        operation::BignumCalc getOpPostprocess(Datasource* parentDs, operation::BignumCalc op) const override;\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_SECP256K1 code for executor.h"}, {"role": "assistant", "content": "class ExecutorBignumCalc_Mod_SECP256K1 : public ExecutorBignumCalc {    public:\n        ExecutorBignumCalc_Mod_SECP256K1(const uint64_t operationID, const std::map<uint64_t, std::shared_ptr<Module> >& modules, const Options& options);\n        operation::BignumCalc getOpPostprocess(Datasource* parentDs, operation::BignumCalc op) const override;\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_SECP256K1_P code for executor.h"}, {"role": "assistant", "content": "class ExecutorBignumCalc_Mod_SECP256K1_P : public ExecutorBignumCalc {    public:\n        ExecutorBignumCalc_Mod_SECP256K1_P(const uint64_t operationID, const std::map<uint64_t, std::shared_ptr<Module> >& modules, const Options& options);\n        operation::BignumCalc getOpPostprocess(Datasource* parentDs, operation::BignumCalc op) const override;\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Fp2 code for executor.h"}, {"role": "assistant", "content": "class ExecutorBignumCalc_Fp2 : public ExecutorBase<component::Fp2, operation::BignumCalc_Fp2> {    private:\n        std::optional<component::Fp2> callModule(std::shared_ptr<Module> module, operation::BignumCalc_Fp2& op) const override;\n    protected:\n        std::optional<component::Bignum> modulo = std::nullopt;\n    public:\n        ExecutorBignumCalc_Fp2(const uint64_t operationID, const std::map<uint64_t, std::shared_ptr<Module> >& modules, const Options& options);\n        void SetModulo(const std::string& modulo);\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Fp12 code for executor.h"}, {"role": "assistant", "content": "class ExecutorBignumCalc_Fp12 : public ExecutorBase<component::Fp12, operation::BignumCalc_Fp12> {    private:\n        std::optional<component::Fp12> callModule(std::shared_ptr<Module> module, operation::BignumCalc_Fp12& op) const override;\n    protected:\n        std::optional<component::Bignum> modulo = std::nullopt;\n    public:\n        ExecutorBignumCalc_Fp12(const uint64_t operationID, const std::map<uint64_t, std::shared_ptr<Module> >& modules, const Options& options);\n        void SetModulo(const std::string& modulo);\n};\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate Digest code for executor.h"}, {"role": "assistant", "content": "using ExecutorDigest = ExecutorBase<component::Digest, operation::Digest>;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate HMAC code for executor.h"}, {"role": "assistant", "content": "using ExecutorHMAC = ExecutorBase<component::MAC, operation::HMAC>;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate UMAC code for executor.h"}, {"role": "assistant", "content": "using ExecutorUMAC = ExecutorBase<component::MAC, operation::UMAC>;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate CMAC code for executor.h"}, {"role": "assistant", "content": "using ExecutorCMAC = ExecutorBase<component::MAC, operation::CMAC>;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate SymmetricEncrypt code for executor.h"}, {"role": "assistant", "content": "using ExecutorSymmetricEncrypt = ExecutorBase<component::Ciphertext, operation::SymmetricEncrypt>;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate SymmetricDecrypt code for executor.h"}, {"role": "assistant", "content": "using ExecutorSymmetricDecrypt = ExecutorBase<component::Cleartext, operation::SymmetricDecrypt>;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_SCRYPT code for executor.h"}, {"role": "assistant", "content": "using ExecutorKDF_SCRYPT = ExecutorBase<component::Key, operation::KDF_SCRYPT>;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_HKDF code for executor.h"}, {"role": "assistant", "content": "using ExecutorKDF_HKDF = ExecutorBase<component::Key, operation::KDF_HKDF>;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_TLS1_PRF code for executor.h"}, {"role": "assistant", "content": "using ExecutorKDF_TLS1_PRF = ExecutorBase<component::Key, operation::KDF_TLS1_PRF>;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_PBKDF code for executor.h"}, {"role": "assistant", "content": "using ExecutorKDF_PBKDF = ExecutorBase<component::Key, operation::KDF_PBKDF>;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_PBKDF1 code for executor.h"}, {"role": "assistant", "content": "using ExecutorKDF_PBKDF1 = ExecutorBase<component::Key, operation::KDF_PBKDF1>;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_PBKDF2 code for executor.h"}, {"role": "assistant", "content": "using ExecutorKDF_PBKDF2 = ExecutorBase<component::Key, operation::KDF_PBKDF2>;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_ARGON2 code for executor.h"}, {"role": "assistant", "content": "using ExecutorKDF_ARGON2 = ExecutorBase<component::Key, operation::KDF_ARGON2>;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_SSH code for executor.h"}, {"role": "assistant", "content": "using ExecutorKDF_SSH = ExecutorBase<component::Key, operation::KDF_SSH>;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_X963 code for executor.h"}, {"role": "assistant", "content": "using ExecutorKDF_X963 = ExecutorBase<component::Key, operation::KDF_X963>;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_BCRYPT code for executor.h"}, {"role": "assistant", "content": "using ExecutorKDF_BCRYPT = ExecutorBase<component::Key, operation::KDF_BCRYPT>;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_SP_800_108 code for executor.h"}, {"role": "assistant", "content": "using ExecutorKDF_SP_800_108 = ExecutorBase<component::Key, operation::KDF_SP_800_108>;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_SRTP code for executor.h"}, {"role": "assistant", "content": "using ExecutorKDF_SRTP = ExecutorBase<component::Key3, operation::KDF_SRTP>;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_SRTCP code for executor.h"}, {"role": "assistant", "content": "using ExecutorKDF_SRTCP = ExecutorBase<component::Key3, operation::KDF_SRTCP>;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_PrivateToPublic code for executor.h"}, {"role": "assistant", "content": "using ExecutorECC_PrivateToPublic = ExecutorBase<component::ECC_PublicKey, operation::ECC_PrivateToPublic>;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_ValidatePubkey code for executor.h"}, {"role": "assistant", "content": "using ExecutorECC_ValidatePubkey = ExecutorBase<bool, operation::ECC_ValidatePubkey>;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_GenerateKeyPair code for executor.h"}, {"role": "assistant", "content": "using ExecutorECC_GenerateKeyPair = ExecutorBase<component::ECC_KeyPair, operation::ECC_GenerateKeyPair>;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECCSI_Sign code for executor.h"}, {"role": "assistant", "content": "using ExecutorECCSI_Sign = ExecutorBase<component::ECCSI_Signature, operation::ECCSI_Sign>;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECDSA_Sign code for executor.h"}, {"role": "assistant", "content": "using ExecutorECDSA_Sign = ExecutorBase<component::ECDSA_Signature, operation::ECDSA_Sign>;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECGDSA_Sign code for executor.h"}, {"role": "assistant", "content": "using ExecutorECGDSA_Sign = ExecutorBase<component::ECGDSA_Signature, operation::ECGDSA_Sign>;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECRDSA_Sign code for executor.h"}, {"role": "assistant", "content": "using ExecutorECRDSA_Sign = ExecutorBase<component::ECRDSA_Signature, operation::ECRDSA_Sign>;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate Schnorr_Sign code for executor.h"}, {"role": "assistant", "content": "using ExecutorSchnorr_Sign = ExecutorBase<component::Schnorr_Signature, operation::Schnorr_Sign>;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECCSI_Verify code for executor.h"}, {"role": "assistant", "content": "using ExecutorECCSI_Verify = ExecutorBase<bool, operation::ECCSI_Verify>;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECDSA_Verify code for executor.h"}, {"role": "assistant", "content": "using ExecutorECDSA_Verify = ExecutorBase<bool, operation::ECDSA_Verify>;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECGDSA_Verify code for executor.h"}, {"role": "assistant", "content": "using ExecutorECGDSA_Verify = ExecutorBase<bool, operation::ECGDSA_Verify>;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECRDSA_Verify code for executor.h"}, {"role": "assistant", "content": "using ExecutorECRDSA_Verify = ExecutorBase<bool, operation::ECRDSA_Verify>;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate Schnorr_Verify code for executor.h"}, {"role": "assistant", "content": "using ExecutorSchnorr_Verify = ExecutorBase<bool, operation::Schnorr_Verify>;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECDSA_Recover code for executor.h"}, {"role": "assistant", "content": "using ExecutorECDSA_Recover = ExecutorBase<component::ECC_PublicKey, operation::ECDSA_Recover>;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate DSA_Verify code for executor.h"}, {"role": "assistant", "content": "using ExecutorDSA_Verify = ExecutorBase<bool, operation::DSA_Verify>;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate DSA_Sign code for executor.h"}, {"role": "assistant", "content": "using ExecutorDSA_Sign = ExecutorBase<component::DSA_Signature, operation::DSA_Sign>;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate DSA_GenerateParameters code for executor.h"}, {"role": "assistant", "content": "using ExecutorDSA_GenerateParameters = ExecutorBase<component::DSA_Parameters, operation::DSA_GenerateParameters>;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate DSA_PrivateToPublic code for executor.h"}, {"role": "assistant", "content": "using ExecutorDSA_PrivateToPublic = ExecutorBase<component::Bignum, operation::DSA_PrivateToPublic>;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate DSA_GenerateKeyPair code for executor.h"}, {"role": "assistant", "content": "using ExecutorDSA_GenerateKeyPair = ExecutorBase<component::DSA_KeyPair, operation::DSA_GenerateKeyPair>;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECDH_Derive code for executor.h"}, {"role": "assistant", "content": "using ExecutorECDH_Derive = ExecutorBase<component::Secret, operation::ECDH_Derive>;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECIES_Encrypt code for executor.h"}, {"role": "assistant", "content": "using ExecutorECIES_Encrypt = ExecutorBase<component::Ciphertext, operation::ECIES_Encrypt>;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECIES_Decrypt code for executor.h"}, {"role": "assistant", "content": "using ExecutorECIES_Decrypt = ExecutorBase<component::Cleartext, operation::ECIES_Decrypt>;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_Point_Add code for executor.h"}, {"role": "assistant", "content": "using ExecutorECC_Point_Add = ExecutorBase<component::ECC_Point, operation::ECC_Point_Add>;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_Point_Sub code for executor.h"}, {"role": "assistant", "content": "using ExecutorECC_Point_Sub = ExecutorBase<component::ECC_Point, operation::ECC_Point_Sub>;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_Point_Mul code for executor.h"}, {"role": "assistant", "content": "using ExecutorECC_Point_Mul = ExecutorBase<component::ECC_Point, operation::ECC_Point_Mul>;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_Point_Neg code for executor.h"}, {"role": "assistant", "content": "using ExecutorECC_Point_Neg = ExecutorBase<component::ECC_Point, operation::ECC_Point_Neg>;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_Point_Dbl code for executor.h"}, {"role": "assistant", "content": "using ExecutorECC_Point_Dbl = ExecutorBase<component::ECC_Point, operation::ECC_Point_Dbl>;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_Point_Cmp code for executor.h"}, {"role": "assistant", "content": "using ExecutorECC_Point_Cmp = ExecutorBase<bool, operation::ECC_Point_Cmp>;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate DH_GenerateKeyPair code for executor.h"}, {"role": "assistant", "content": "using ExecutorDH_GenerateKeyPair = ExecutorBase<component::DH_KeyPair, operation::DH_GenerateKeyPair>;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate DH_Derive code for executor.h"}, {"role": "assistant", "content": "using ExecutorDH_Derive = ExecutorBase<component::Bignum, operation::DH_Derive>;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_PrivateToPublic code for executor.h"}, {"role": "assistant", "content": "using ExecutorBLS_PrivateToPublic = ExecutorBase<component::BLS_PublicKey, operation::BLS_PrivateToPublic>;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_PrivateToPublic_G2 code for executor.h"}, {"role": "assistant", "content": "using ExecutorBLS_PrivateToPublic_G2 = ExecutorBase<component::G2, operation::BLS_PrivateToPublic_G2>;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_Sign code for executor.h"}, {"role": "assistant", "content": "using ExecutorBLS_Sign = ExecutorBase<component::BLS_Signature, operation::BLS_Sign>;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_Verify code for executor.h"}, {"role": "assistant", "content": "using ExecutorBLS_Verify = ExecutorBase<bool, operation::BLS_Verify>;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_BatchSign code for executor.h"}, {"role": "assistant", "content": "using ExecutorBLS_BatchSign = ExecutorBase<component::BLS_BatchSignature, operation::BLS_BatchSign>;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_BatchVerify code for executor.h"}, {"role": "assistant", "content": "using ExecutorBLS_BatchVerify = ExecutorBase<bool, operation::BLS_BatchVerify>;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_Aggregate_G1 code for executor.h"}, {"role": "assistant", "content": "using ExecutorBLS_Aggregate_G1 = ExecutorBase<component::G1, operation::BLS_Aggregate_G1>;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_Aggregate_G2 code for executor.h"}, {"role": "assistant", "content": "using ExecutorBLS_Aggregate_G2 = ExecutorBase<component::G2, operation::BLS_Aggregate_G2>;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_Pairing code for executor.h"}, {"role": "assistant", "content": "using ExecutorBLS_Pairing = ExecutorBase<component::Fp12, operation::BLS_Pairing>;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_MillerLoop code for executor.h"}, {"role": "assistant", "content": "using ExecutorBLS_MillerLoop = ExecutorBase<component::Fp12, operation::BLS_MillerLoop>;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_FinalExp code for executor.h"}, {"role": "assistant", "content": "using ExecutorBLS_FinalExp = ExecutorBase<component::Fp12, operation::BLS_FinalExp>;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate Digest code for executor.cpp"}, {"role": "assistant", "content": "/* Specialization for operation::Digest */template<> void ExecutorBase<component::Digest, operation::Digest>::postprocess(std::shared_ptr<Module> module, operation::Digest& op, const ExecutorBase<component::Digest, operation::Digest>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n\n    if ( result.second != std::nullopt ) {\n        fuzzing::memory::memory_test_msan(result.second->GetPtr(), result.second->GetSize());\n    }\n}\n\ntemplate<> std::optional<component::Digest> ExecutorBase<component::Digest, operation::Digest>::callModule(std::shared_ptr<Module> module, operation::Digest& op) const {\n    RETURN_IF_DISABLED(options.digests, op.digestType.Get());\n\n    return module->OpDigest(op);\n}\n\n\ntemplate class ExecutorBase<component::Digest, operation::Digest>;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate HMAC code for executor.cpp"}, {"role": "assistant", "content": "/* Specialization for operation::HMAC */template<> void ExecutorBase<component::MAC, operation::HMAC>::postprocess(std::shared_ptr<Module> module, operation::HMAC& op, const ExecutorBase<component::MAC, operation::HMAC>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n\n    if ( result.second != std::nullopt ) {\n        fuzzing::memory::memory_test_msan(result.second->GetPtr(), result.second->GetSize());\n    }\n}\n\ntemplate<> std::optional<component::MAC> ExecutorBase<component::MAC, operation::HMAC>::callModule(std::shared_ptr<Module> module, operation::HMAC& op) const {\n    RETURN_IF_DISABLED(options.digests, op.digestType.Get());\n\n    return module->OpHMAC(op);\n}\n\ntemplate <>\nbool ExecutorBase<component::MAC, operation::HMAC>::dontCompare(const operation::HMAC& operation) const {\n    if ( operation.cipher.cipherType.Get() == CF_CIPHER(\"DES_EDE3_WRAP\") ) return true;\n\n    return false;\n}\n\n\ntemplate class ExecutorBase<component::MAC, operation::HMAC>;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate UMAC code for executor.cpp"}, {"role": "assistant", "content": "/* Specialization for operation::UMAC */template<> void ExecutorBase<component::MAC, operation::UMAC>::postprocess(std::shared_ptr<Module> module, operation::UMAC& op, const ExecutorBase<component::MAC, operation::UMAC>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n\n    if ( result.second != std::nullopt ) {\n        fuzzing::memory::memory_test_msan(result.second->GetPtr(), result.second->GetSize());\n    }\n}\n\ntemplate<> std::optional<component::MAC> ExecutorBase<component::MAC, operation::UMAC>::callModule(std::shared_ptr<Module> module, operation::UMAC& op) const {\n    return module->OpUMAC(op);\n}\n\n\ntemplate class ExecutorBase<component::MAC, operation::UMAC>;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate CMAC code for executor.cpp"}, {"role": "assistant", "content": "/* Specialization for operation::CMAC */template<> void ExecutorBase<component::MAC, operation::CMAC>::postprocess(std::shared_ptr<Module> module, operation::CMAC& op, const ExecutorBase<component::MAC, operation::CMAC>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n\n    if ( result.second != std::nullopt ) {\n        fuzzing::memory::memory_test_msan(result.second->GetPtr(), result.second->GetSize());\n    }\n}\n\ntemplate<> std::optional<component::MAC> ExecutorBase<component::MAC, operation::CMAC>::callModule(std::shared_ptr<Module> module, operation::CMAC& op) const {\n    RETURN_IF_DISABLED(options.ciphers, op.cipher.cipherType.Get());\n\n    return module->OpCMAC(op);\n}\n\ntemplate <>\nbool ExecutorBase<component::MAC, operation::CMAC>::dontCompare(const operation::CMAC& operation) const {\n    if ( operation.cipher.cipherType.Get() == CF_CIPHER(\"DES_EDE3_WRAP\") ) return true;\n\n    return false;\n}\n\n\ntemplate class ExecutorBase<component::MAC, operation::CMAC>;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate SymmetricEncrypt code for executor.cpp"}, {"role": "assistant", "content": "/* Specialization for operation::SymmetricEncrypt */template<> void ExecutorBase<component::Ciphertext, operation::SymmetricEncrypt>::postprocess(std::shared_ptr<Module> module, operation::SymmetricEncrypt& op, const ExecutorBase<component::Ciphertext, operation::SymmetricEncrypt>::ResultPair& result) const {\n    if ( options.noDecrypt == true ) {\n        return;\n    }\n\n    if ( result.second != std::nullopt ) {\n        fuzzing::memory::memory_test_msan(result.second->ciphertext.GetPtr(), result.second->ciphertext.GetSize());\n        if ( result.second->tag != std::nullopt ) {\n            fuzzing::memory::memory_test_msan(result.second->tag->GetPtr(), result.second->tag->GetSize());\n        }\n    }\n\n    if ( op.cleartext.GetSize() > 0 && result.second != std::nullopt && result.second->ciphertext.GetSize() > 0 ) {\n        using fuzzing::datasource::ID;\n\n        bool tryDecrypt = true;\n\n        if ( module->ID == CF_MODULE(\"OpenSSL\") ) {\n            switch ( op.cipher.cipherType.Get() ) {\n                case    ID(\"Cryptofuzz/Cipher/AES_128_OCB\"):\n                case    ID(\"Cryptofuzz/Cipher/AES_256_OCB\"):\n                    tryDecrypt = false;\n                    break;\n                case    ID(\"Cryptofuzz/Cipher/AES_128_GCM\"):\n                case    ID(\"Cryptofuzz/Cipher/AES_192_GCM\"):\n                case    ID(\"Cryptofuzz/Cipher/AES_256_GCM\"):\n                case    ID(\"Cryptofuzz/Cipher/AES_128_CCM\"):\n                case    ID(\"Cryptofuzz/Cipher/AES_192_CCM\"):\n                case    ID(\"Cryptofuzz/Cipher/AES_256_CCM\"):\n                case    ID(\"Cryptofuzz/Cipher/ARIA_128_CCM\"):\n                case    ID(\"Cryptofuzz/Cipher/ARIA_192_CCM\"):\n                case    ID(\"Cryptofuzz/Cipher/ARIA_256_CCM\"):\n                case    ID(\"Cryptofuzz/Cipher/ARIA_128_GCM\"):\n                case    ID(\"Cryptofuzz/Cipher/ARIA_192_GCM\"):\n                case    ID(\"Cryptofuzz/Cipher/ARIA_256_GCM\"):\n                    if ( op.tagSize == std::nullopt ) {\n                        /* OpenSSL fails to decrypt its own CCM and GCM ciphertexts if\n                         * a tag is not included\n                         */\n                        tryDecrypt = false;\n                    }\n                    break;\n            }\n        }\n\n        if ( tryDecrypt == true ) {\n            /* Try to decrypt the encrypted data */\n\n            /* Construct a SymmetricDecrypt instance with the SymmetricEncrypt instance */\n            auto opDecrypt = operation::SymmetricDecrypt(\n                    /* The SymmetricEncrypt instance */\n                    op,\n\n                    /* The ciphertext generated by OpSymmetricEncrypt */\n                    *(result.second),\n\n                    /* The size of the output buffer that OpSymmetricDecrypt() must use. */\n                    op.cleartext.GetSize() + 32,\n\n                    op.aad,\n\n                    /* Empty modifier */\n                    {});\n\n            const auto cleartext = module->OpSymmetricDecrypt(opDecrypt);\n\n            if ( cleartext == std::nullopt ) {\n                /* Decryption failed, OpSymmetricDecrypt() returned std::nullopt */\n                printf(\"Cannot decrypt ciphertext\\n\\n\");\n                printf(\"Operation:\\n%s\\n\", op.ToString().c_str());\n                printf(\"Ciphertext: %s\\n\", util::HexDump(result.second->ciphertext.Get()).c_str());\n                printf(\"Tag: %s\\n\", result.second->tag ? util::HexDump(result.second->tag->Get()).c_str() : \"nullopt\");\n                abort(\n                        {module->name},\n                        op.Name(),\n                        op.GetAlgorithmString(),\n                        \"cannot decrypt ciphertext\"\n                );\n            } else if ( cleartext->Get() != op.cleartext.Get() ) {\n                /* Decryption ostensibly succeeded, but the cleartext returned by OpSymmetricDecrypt()\n                 * does not match to original cleartext */\n\n                printf(\"Cannot decrypt ciphertext (but decryption ostensibly succeeded)\\n\\n\");\n                printf(\"Operation:\\n%s\\n\", op.ToString().c_str());\n                printf(\"Ciphertext: %s\\n\", util::HexDump(result.second->ciphertext.Get()).c_str());\n                printf(\"Tag: %s\\n\", result.second->tag ? util::HexDump(result.second->tag->Get()).c_str() : \"nullopt\");\n                printf(\"Purported cleartext: %s\\n\", util::HexDump(cleartext->Get()).c_str());\n                abort(\n                        {module->name},\n                        op.Name(),\n                        op.GetAlgorithmString(),\n                        \"cannot decrypt ciphertext\"\n                );\n            }\n        }\n    }\n}\n\ntemplate<> std::optional<component::Ciphertext> ExecutorBase<component::Ciphertext, operation::SymmetricEncrypt>::callModule(std::shared_ptr<Module> module, operation::SymmetricEncrypt& op) const {\n    RETURN_IF_DISABLED(options.ciphers , op.cipher.cipherType.Get());\n\n    return module->OpSymmetricEncrypt(op);\n}\n\ntemplate <>\nbool ExecutorBase<component::Ciphertext, operation::SymmetricEncrypt>::dontCompare(const operation::SymmetricEncrypt& operation) const {\n    if ( operation.cipher.cipherType.Get() == CF_CIPHER(\"DES_EDE3_WRAP\") ) { return true; }\n\n    return false;\n}\n\n\ntemplate class ExecutorBase<component::Ciphertext, operation::SymmetricEncrypt>;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate SymmetricDecrypt code for executor.cpp"}, {"role": "assistant", "content": "/* Specialization for operation::SymmetricDecrypt */template<> void ExecutorBase<component::MAC, operation::SymmetricDecrypt>::postprocess(std::shared_ptr<Module> module, operation::SymmetricDecrypt& op, const ExecutorBase<component::MAC, operation::SymmetricDecrypt>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n\n    if ( result.second != std::nullopt ) {\n        fuzzing::memory::memory_test_msan(result.second->GetPtr(), result.second->GetSize());\n    }\n}\n\ntemplate<> std::optional<component::MAC> ExecutorBase<component::MAC, operation::SymmetricDecrypt>::callModule(std::shared_ptr<Module> module, operation::SymmetricDecrypt& op) const {\n    RETURN_IF_DISABLED(options.ciphers , op.cipher.cipherType.Get());\n\n    return module->OpSymmetricDecrypt(op);\n}\n\ntemplate <>\nbool ExecutorBase<component::Cleartext, operation::SymmetricDecrypt>::dontCompare(const operation::SymmetricDecrypt& operation) const {\n    if ( operation.cipher.cipherType.Get() == CF_CIPHER(\"DES_EDE3_WRAP\") ) return true;\n\n    return false;\n}\n\n\ntemplate class ExecutorBase<component::Cleartext, operation::SymmetricDecrypt>;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_SCRYPT code for executor.cpp"}, {"role": "assistant", "content": "/* Specialization for operation::KDF_SCRYPT */template<> void ExecutorBase<component::Key, operation::KDF_SCRYPT>::postprocess(std::shared_ptr<Module> module, operation::KDF_SCRYPT& op, const ExecutorBase<component::Key, operation::KDF_SCRYPT>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n\n    if ( result.second != std::nullopt ) {\n        fuzzing::memory::memory_test_msan(result.second->GetPtr(), result.second->GetSize());\n    }\n}\n\ntemplate<> std::optional<component::Key> ExecutorBase<component::Key, operation::KDF_SCRYPT>::callModule(std::shared_ptr<Module> module, operation::KDF_SCRYPT& op) const {\n    return module->OpKDF_SCRYPT(op);\n}\n\n\ntemplate class ExecutorBase<component::Key, operation::KDF_SCRYPT>;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_HKDF code for executor.cpp"}, {"role": "assistant", "content": "/* Specialization for operation::KDF_HKDF */template<> void ExecutorBase<component::Key, operation::KDF_HKDF>::postprocess(std::shared_ptr<Module> module, operation::KDF_HKDF& op, const ExecutorBase<component::Key, operation::KDF_HKDF>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n\n    if ( result.second != std::nullopt ) {\n        fuzzing::memory::memory_test_msan(result.second->GetPtr(), result.second->GetSize());\n    }\n}\n\ntemplate<> std::optional<component::Key> ExecutorBase<component::Key, operation::KDF_HKDF>::callModule(std::shared_ptr<Module> module, operation::KDF_HKDF& op) const {\n    RETURN_IF_DISABLED(options.digests, op.digestType.Get());\n\n    return module->OpKDF_HKDF(op);\n}\n\n\ntemplate class ExecutorBase<component::Key, operation::KDF_HKDF>;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_PBKDF code for executor.cpp"}, {"role": "assistant", "content": "/* Specialization for operation::KDF_PBKDF */template<> void ExecutorBase<component::Key, operation::KDF_PBKDF>::postprocess(std::shared_ptr<Module> module, operation::KDF_PBKDF& op, const ExecutorBase<component::Key, operation::KDF_PBKDF>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n\n    if ( result.second != std::nullopt ) {\n        fuzzing::memory::memory_test_msan(result.second->GetPtr(), result.second->GetSize());\n    }\n}\n\ntemplate<> std::optional<component::Key> ExecutorBase<component::Key, operation::KDF_PBKDF>::callModule(std::shared_ptr<Module> module, operation::KDF_PBKDF& op) const {\n    RETURN_IF_DISABLED(options.digests, op.digestType.Get());\n\n    return module->OpKDF_PBKDF(op);\n}\n\n\ntemplate class ExecutorBase<component::Key, operation::KDF_PBKDF>;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_PBKDF1 code for executor.cpp"}, {"role": "assistant", "content": "/* Specialization for operation::KDF_PBKDF1 */template<> void ExecutorBase<component::Key, operation::KDF_PBKDF1>::postprocess(std::shared_ptr<Module> module, operation::KDF_PBKDF1& op, const ExecutorBase<component::Key, operation::KDF_PBKDF1>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n\n    if ( result.second != std::nullopt ) {\n        fuzzing::memory::memory_test_msan(result.second->GetPtr(), result.second->GetSize());\n    }\n}\n\ntemplate<> std::optional<component::Key> ExecutorBase<component::Key, operation::KDF_PBKDF1>::callModule(std::shared_ptr<Module> module, operation::KDF_PBKDF1& op) const {\n    RETURN_IF_DISABLED(options.digests, op.digestType.Get());\n\n    return module->OpKDF_PBKDF1(op);\n}\n\n\ntemplate class ExecutorBase<component::Key, operation::KDF_PBKDF1>;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_PBKDF2 code for executor.cpp"}, {"role": "assistant", "content": "/* Specialization for operation::KDF_PBKDF2 */template<> void ExecutorBase<component::Key, operation::KDF_PBKDF2>::postprocess(std::shared_ptr<Module> module, operation::KDF_PBKDF2& op, const ExecutorBase<component::Key, operation::KDF_PBKDF2>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n\n    if ( result.second != std::nullopt ) {\n        fuzzing::memory::memory_test_msan(result.second->GetPtr(), result.second->GetSize());\n    }\n}\n\ntemplate<> std::optional<component::Key> ExecutorBase<component::Key, operation::KDF_PBKDF2>::callModule(std::shared_ptr<Module> module, operation::KDF_PBKDF2& op) const {\n    RETURN_IF_DISABLED(options.digests, op.digestType.Get());\n\n    return module->OpKDF_PBKDF2(op);\n}\n\n\ntemplate class ExecutorBase<component::Key, operation::KDF_PBKDF2>;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_ARGON2 code for executor.cpp"}, {"role": "assistant", "content": "/* Specialization for operation::KDF_ARGON2 */template<> void ExecutorBase<component::Key, operation::KDF_ARGON2>::postprocess(std::shared_ptr<Module> module, operation::KDF_ARGON2& op, const ExecutorBase<component::Key, operation::KDF_ARGON2>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n\n    if ( result.second != std::nullopt ) {\n        fuzzing::memory::memory_test_msan(result.second->GetPtr(), result.second->GetSize());\n    }\n}\n\ntemplate<> std::optional<component::Key> ExecutorBase<component::Key, operation::KDF_ARGON2>::callModule(std::shared_ptr<Module> module, operation::KDF_ARGON2& op) const {\n    return module->OpKDF_ARGON2(op);\n}\n\n\ntemplate class ExecutorBase<component::Key, operation::KDF_ARGON2>;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_SSH code for executor.cpp"}, {"role": "assistant", "content": "/* Specialization for operation::KDF_SSH */template<> void ExecutorBase<component::Key, operation::KDF_SSH>::postprocess(std::shared_ptr<Module> module, operation::KDF_SSH& op, const ExecutorBase<component::Key, operation::KDF_SSH>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n\n    if ( result.second != std::nullopt ) {\n        fuzzing::memory::memory_test_msan(result.second->GetPtr(), result.second->GetSize());\n    }\n}\n\ntemplate<> std::optional<component::Key> ExecutorBase<component::Key, operation::KDF_SSH>::callModule(std::shared_ptr<Module> module, operation::KDF_SSH& op) const {\n    RETURN_IF_DISABLED(options.digests, op.digestType.Get());\n\n    return module->OpKDF_SSH(op);\n}\n\n\ntemplate class ExecutorBase<component::Key, operation::KDF_SSH>;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_TLS1_PRF code for executor.cpp"}, {"role": "assistant", "content": "/* Specialization for operation::KDF_TLS1_PRF */template<> void ExecutorBase<component::Key, operation::KDF_TLS1_PRF>::postprocess(std::shared_ptr<Module> module, operation::KDF_TLS1_PRF& op, const ExecutorBase<component::Key, operation::KDF_TLS1_PRF>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n\n    if ( result.second != std::nullopt ) {\n        fuzzing::memory::memory_test_msan(result.second->GetPtr(), result.second->GetSize());\n    }\n}\n\ntemplate<> std::optional<component::Key> ExecutorBase<component::Key, operation::KDF_TLS1_PRF>::callModule(std::shared_ptr<Module> module, operation::KDF_TLS1_PRF& op) const {\n    RETURN_IF_DISABLED(options.digests, op.digestType.Get());\n\n    return module->OpKDF_TLS1_PRF(op);\n}\n\n\ntemplate class ExecutorBase<component::Key, operation::KDF_TLS1_PRF>;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_X963 code for executor.cpp"}, {"role": "assistant", "content": "/* Specialization for operation::KDF_X963 */template<> void ExecutorBase<component::Key, operation::KDF_X963>::postprocess(std::shared_ptr<Module> module, operation::KDF_X963& op, const ExecutorBase<component::Key, operation::KDF_X963>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n\n    if ( result.second != std::nullopt ) {\n        fuzzing::memory::memory_test_msan(result.second->GetPtr(), result.second->GetSize());\n    }\n}\n\ntemplate<> std::optional<component::Key> ExecutorBase<component::Key, operation::KDF_X963>::callModule(std::shared_ptr<Module> module, operation::KDF_X963& op) const {\n    RETURN_IF_DISABLED(options.digests, op.digestType.Get());\n\n    return module->OpKDF_X963(op);\n}\n\n\ntemplate class ExecutorBase<component::Key, operation::KDF_X963>;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_BCRYPT code for executor.cpp"}, {"role": "assistant", "content": "/* Specialization for operation::KDF_BCRYPT */template<> void ExecutorBase<component::Key, operation::KDF_BCRYPT>::postprocess(std::shared_ptr<Module> module, operation::KDF_BCRYPT& op, const ExecutorBase<component::Key, operation::KDF_BCRYPT>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n\n    if ( result.second != std::nullopt ) {\n        fuzzing::memory::memory_test_msan(result.second->GetPtr(), result.second->GetSize());\n    }\n}\n\ntemplate<> std::optional<component::Key> ExecutorBase<component::Key, operation::KDF_BCRYPT>::callModule(std::shared_ptr<Module> module, operation::KDF_BCRYPT& op) const {\n    RETURN_IF_DISABLED(options.digests, op.digestType.Get());\n\n    return module->OpKDF_BCRYPT(op);\n}\n\n\ntemplate class ExecutorBase<component::Key, operation::KDF_BCRYPT>;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_SP_800_108 code for executor.cpp"}, {"role": "assistant", "content": "/* Specialization for operation::KDF_SP_800_108 */template<> void ExecutorBase<component::Key, operation::KDF_SP_800_108>::postprocess(std::shared_ptr<Module> module, operation::KDF_SP_800_108& op, const ExecutorBase<component::Key, operation::KDF_SP_800_108>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n\n    if ( result.second != std::nullopt ) {\n        fuzzing::memory::memory_test_msan(result.second->GetPtr(), result.second->GetSize());\n    }\n}\n\ntemplate<> std::optional<component::Key> ExecutorBase<component::Key, operation::KDF_SP_800_108>::callModule(std::shared_ptr<Module> module, operation::KDF_SP_800_108& op) const {\n    if ( op.mech.mode == true ) {\n        RETURN_IF_DISABLED(options.digests, op.mech.type.Get());\n    }\n\n    return module->OpKDF_SP_800_108(op);\n}\n\n\ntemplate class ExecutorBase<component::Key, operation::KDF_SP_800_108>;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_SRTP code for executor.cpp"}, {"role": "assistant", "content": "/* Specialization for operation::KDF_SRTP */template<> void ExecutorBase<component::Key3, operation::KDF_SRTP>::postprocess(std::shared_ptr<Module> module, operation::KDF_SRTP& op, const ExecutorBase<component::Key3, operation::KDF_SRTP>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n    (void)result;\n}\n\ntemplate<> std::optional<component::Key3> ExecutorBase<component::Key3, operation::KDF_SRTP>::callModule(std::shared_ptr<Module> module, operation::KDF_SRTP& op) const {\n    return module->OpKDF_SRTP(op);\n}\n\n\ntemplate class ExecutorBase<component::Key3, operation::KDF_SRTP>;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_SRTCP code for executor.cpp"}, {"role": "assistant", "content": "/* Specialization for operation::KDF_SRTCP */template<> void ExecutorBase<component::Key3, operation::KDF_SRTCP>::postprocess(std::shared_ptr<Module> module, operation::KDF_SRTCP& op, const ExecutorBase<component::Key3, operation::KDF_SRTCP>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n    (void)result;\n}\n\ntemplate<> std::optional<component::Key3> ExecutorBase<component::Key3, operation::KDF_SRTCP>::callModule(std::shared_ptr<Module> module, operation::KDF_SRTCP& op) const {\n    return module->OpKDF_SRTCP(op);\n}\n\n\ntemplate class ExecutorBase<component::Key3, operation::KDF_SRTCP>;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_PrivateToPublic code for executor.cpp"}, {"role": "assistant", "content": "/* Specialization for operation::ECC_PrivateToPublic */template<> void ExecutorBase<component::ECC_PublicKey, operation::ECC_PrivateToPublic>::postprocess(std::shared_ptr<Module> module, operation::ECC_PrivateToPublic& op, const ExecutorBase<component::ECC_PublicKey, operation::ECC_PrivateToPublic>::ResultPair& result) const {\n    (void)module;\n\n    if ( result.second != std::nullopt  ) {\n        const auto curveID = op.curveType.Get();\n        const auto privkey = op.priv.ToTrimmedString();\n        const auto pub_x = result.second->first.ToTrimmedString();\n        const auto pub_y = result.second->second.ToTrimmedString();\n\n        Pool_CurvePrivkey.Set({ curveID, privkey });\n        Pool_CurveKeypair.Set({ curveID, privkey, pub_x, pub_y });\n        Pool_CurveECC_Point.Set({ curveID, pub_x, pub_y });\n\n        if ( pub_x.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(pub_x); }\n        if ( pub_y.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(pub_y); }\n    }\n}\n\ntemplate<> std::optional<component::ECC_PublicKey> ExecutorBase<component::ECC_PublicKey, operation::ECC_PrivateToPublic>::callModule(std::shared_ptr<Module> module, operation::ECC_PrivateToPublic& op) const {\n    RETURN_IF_DISABLED(options.curves, op.curveType.Get());\n\n    const size_t size = op.priv.ToTrimmedString().size();\n\n    if ( size == 0 || size > 4096 ) {\n        return std::nullopt;\n    }\n\n    return module->OpECC_PrivateToPublic(op);\n}\n\n\ntemplate class ExecutorBase<component::ECC_PublicKey, operation::ECC_PrivateToPublic>;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_ValidatePubkey code for executor.cpp"}, {"role": "assistant", "content": "/* Specialization for operation::ECC_ValidatePubkey */template<> void ExecutorBase<bool, operation::ECC_ValidatePubkey>::postprocess(std::shared_ptr<Module> module, operation::ECC_ValidatePubkey& op, const ExecutorBase<bool, operation::ECC_ValidatePubkey>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n    (void)result;\n}\n\ntemplate<> std::optional<bool> ExecutorBase<bool, operation::ECC_ValidatePubkey>::callModule(std::shared_ptr<Module> module, operation::ECC_ValidatePubkey& op) const {\n    RETURN_IF_DISABLED(options.curves, op.curveType.Get());\n\n    return module->OpECC_ValidatePubkey(op);\n}\n\n\ntemplate class ExecutorBase<bool, operation::ECC_ValidatePubkey>;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_GenerateKeyPair code for executor.cpp"}, {"role": "assistant", "content": "/* Specialization for operation::ECC_GenerateKeyPair */\n/* Do not compare DH_GenerateKeyPair results, because the result can be produced indeterministically */\ntemplate <>\nvoid ExecutorBase<component::DH_KeyPair, operation::DH_GenerateKeyPair>::compare(const std::vector< std::pair<std::shared_ptr<Module>, operation::DH_GenerateKeyPair> >& operations, const ResultSet& results, const uint8_t* data, const size_t size) const {\n    (void)operations;\n    (void)results;\n    (void)data;\n    (void)size;\n}\n\ntemplate<> void ExecutorBase<component::ECC_KeyPair, operation::ECC_GenerateKeyPair>::postprocess(std::shared_ptr<Module> module, operation::ECC_GenerateKeyPair& op, const ExecutorBase<component::ECC_KeyPair, operation::ECC_GenerateKeyPair>::ResultPair& result) const {\n    (void)module;\n\n    if ( result.second != std::nullopt  ) {\n        const auto curveID = op.curveType.Get();\n        const auto privkey = result.second->priv.ToTrimmedString();\n        const auto pub_x = result.second->pub.first.ToTrimmedString();\n        const auto pub_y = result.second->pub.second.ToTrimmedString();\n\n        Pool_CurvePrivkey.Set({ curveID, privkey });\n        Pool_CurveKeypair.Set({ curveID, privkey, pub_x, pub_y });\n        Pool_CurveECC_Point.Set({ curveID, pub_x, pub_y });\n\n        {\n            auto opValidate = operation::ECC_ValidatePubkey(\n                    op.curveType,\n                    result.second->pub,\n                    op.modifier);\n\n            const auto validateResult = module->OpECC_ValidatePubkey(opValidate);\n            CF_ASSERT(\n                    validateResult == std::nullopt ||\n                    *validateResult == true,\n                    \"Cannot validate generated public key\");\n        }\n    }\n}\n\ntemplate<> std::optional<component::ECC_KeyPair> ExecutorBase<component::ECC_KeyPair, operation::ECC_GenerateKeyPair>::callModule(std::shared_ptr<Module> module, operation::ECC_GenerateKeyPair& op) const {\n    RETURN_IF_DISABLED(options.curves, op.curveType.Get());\n\n    return module->OpECC_GenerateKeyPair(op);\n}\n\n/* Do not compare ECC_GenerateKeyPair results, because the result can be produced indeterministically */\ntemplate <>\nvoid ExecutorBase<component::ECC_KeyPair, operation::ECC_GenerateKeyPair>::compare(const std::vector< std::pair<std::shared_ptr<Module>, operation::ECC_GenerateKeyPair> >& operations, const ResultSet& results, const uint8_t* data, const size_t size) const {\n    (void)operations;\n    (void)results;\n    (void)data;\n    (void)size;\n}\n\n\ntemplate class ExecutorBase<component::ECC_KeyPair, operation::ECC_GenerateKeyPair>;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECCSI_Sign code for executor.cpp"}, {"role": "assistant", "content": "/* Specialization for operation::ECCSI_Sign */template<> void ExecutorBase<component::ECCSI_Signature, operation::ECCSI_Sign>::postprocess(std::shared_ptr<Module> module, operation::ECCSI_Sign& op, const ExecutorBase<component::ECCSI_Signature, operation::ECCSI_Sign>::ResultPair& result) const {\n    (void)module;\n\n    if ( result.second != std::nullopt  ) {\n        const auto curveID = op.curveType.Get();\n        const auto cleartext = op.cleartext.ToHex();\n        const auto id = op.id.ToHex();\n        const auto pub_x = result.second->pub.first.ToTrimmedString();\n        const auto pub_y = result.second->pub.second.ToTrimmedString();\n        const auto pvt_x = result.second->pvt.first.ToTrimmedString();\n        const auto pvt_y = result.second->pvt.second.ToTrimmedString();\n        const auto sig_r = result.second->signature.first.ToTrimmedString();\n        const auto sig_s = result.second->signature.second.ToTrimmedString();\n\n        Pool_CurveECCSISignature.Set({\n                curveID,\n                cleartext,\n                id,\n                pub_x, pub_y,\n                pvt_x, pvt_y,\n                sig_r, sig_s});\n        Pool_CurveECC_Point.Set({ curveID, pub_x, pub_y });\n        Pool_CurveECC_Point.Set({ curveID, pvt_x, pvt_y });\n        Pool_CurveECC_Point.Set({ curveID, sig_r, sig_s });\n\n        if ( pub_x.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(pub_x); }\n        if ( pub_y.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(pub_y); }\n        if ( pvt_x.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(pvt_x); }\n        if ( pvt_y.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(pvt_y); }\n        if ( sig_r.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(sig_r); }\n        if ( sig_s.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(sig_s); }\n\n        {\n            auto opVerify = operation::ECCSI_Verify(\n                    op,\n                    *(result.second),\n                    op.modifier);\n\n            const auto verifyResult = module->OpECCSI_Verify(opVerify);\n            CF_ASSERT(\n                    verifyResult == std::nullopt ||\n                    *verifyResult == true,\n                    \"Cannot verify generated signature\");\n        }\n    }\n}\n\ntemplate<> std::optional<component::ECCSI_Signature> ExecutorBase<component::ECCSI_Signature, operation::ECCSI_Sign>::callModule(std::shared_ptr<Module> module, operation::ECCSI_Sign& op) const {\n    RETURN_IF_DISABLED(options.curves, op.curveType.Get());\n    RETURN_IF_DISABLED(options.digests, op.digestType.Get());\n\n    const size_t size = op.priv.ToTrimmedString().size();\n\n    if ( size == 0 || size > 4096 ) {\n        return std::nullopt;\n    }\n\n    return module->OpECCSI_Sign(op);\n}\n\n\ntemplate <>\nbool ExecutorBase<component::ECCSI_Signature, operation::ECCSI_Sign>::dontCompare(const operation::ECCSI_Sign& operation) const {\n    (void)operation;\n    return true;\n}\n\n\ntemplate class ExecutorBase<component::ECCSI_Signature, operation::ECCSI_Sign>;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECDSA_Sign code for executor.cpp"}, {"role": "assistant", "content": "/* Specialization for operation::ECDSA_Sign */template<> void ExecutorBase<component::ECDSA_Signature, operation::ECDSA_Sign>::postprocess(std::shared_ptr<Module> module, operation::ECDSA_Sign& op, const ExecutorBase<component::ECDSA_Signature, operation::ECDSA_Sign>::ResultPair& result) const {\n    (void)module;\n\n    if ( result.second != std::nullopt  ) {\n        const auto curveID = op.curveType.Get();\n        const auto cleartext = op.cleartext.ToHex();\n        const auto pub_x = result.second->pub.first.ToTrimmedString();\n        const auto pub_y = result.second->pub.second.ToTrimmedString();\n        const auto sig_r = result.second->signature.first.ToTrimmedString();\n        const auto sig_s = result.second->signature.second.ToTrimmedString();\n\n        Pool_CurveECDSASignature.Set({ curveID, cleartext, pub_x, pub_y, sig_r, sig_s});\n        Pool_CurveECC_Point.Set({ curveID, pub_x, pub_y });\n        Pool_CurveECC_Point.Set({ curveID, sig_r, sig_s });\n\n        if ( pub_x.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(pub_x); }\n        if ( pub_y.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(pub_y); }\n        if ( sig_r.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(sig_r); }\n        if ( sig_s.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(sig_s); }\n\n        {\n            auto opVerify = operation::ECDSA_Verify(\n                    op,\n                    *(result.second),\n                    op.modifier);\n\n            const auto verifyResult = module->OpECDSA_Verify(opVerify);\n            CF_ASSERT(\n                    verifyResult == std::nullopt ||\n                    *verifyResult == true,\n                    \"Cannot verify generated signature\");\n        }\n    }\n}\n\ntemplate<> std::optional<component::ECDSA_Signature> ExecutorBase<component::ECDSA_Signature, operation::ECDSA_Sign>::callModule(std::shared_ptr<Module> module, operation::ECDSA_Sign& op) const {\n    RETURN_IF_DISABLED(options.curves, op.curveType.Get());\n    RETURN_IF_DISABLED(options.digests, op.digestType.Get());\n\n    const size_t size = op.priv.ToTrimmedString().size();\n\n    if ( size == 0 || size > 4096 ) {\n        return std::nullopt;\n    }\n\n    return module->OpECDSA_Sign(op);\n}\n\ntemplate <>\nbool ExecutorBase<component::ECDSA_Signature, operation::ECDSA_Sign>::dontCompare(const operation::ECDSA_Sign& operation) const {\n    if (\n            operation.curveType.Get() != CF_ECC_CURVE(\"ed25519\") &&\n            operation.curveType.Get() != CF_ECC_CURVE(\"ed448\") ) {\n        if ( operation.UseRandomNonce() ) {\n            /* Don't compare ECDSA signatures comptued from a randomly generated nonce */\n            return true;\n        }\n    }\n\n    return false;\n}\n\n\ntemplate class ExecutorBase<component::ECDSA_Signature, operation::ECDSA_Sign>;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECGDSA_Sign code for executor.cpp"}, {"role": "assistant", "content": "/* Specialization for operation::ECGDSA_Sign */template<> void ExecutorBase<component::ECGDSA_Signature, operation::ECGDSA_Sign>::postprocess(std::shared_ptr<Module> module, operation::ECGDSA_Sign& op, const ExecutorBase<component::ECGDSA_Signature, operation::ECGDSA_Sign>::ResultPair& result) const {\n    (void)module;\n\n    if ( result.second != std::nullopt  ) {\n        const auto curveID = op.curveType.Get();\n        const auto cleartext = op.cleartext.ToHex();\n        const auto pub_x = result.second->pub.first.ToTrimmedString();\n        const auto pub_y = result.second->pub.second.ToTrimmedString();\n        const auto sig_r = result.second->signature.first.ToTrimmedString();\n        const auto sig_s = result.second->signature.second.ToTrimmedString();\n\n        Pool_CurveECDSASignature.Set({ curveID, cleartext, pub_x, pub_y, sig_r, sig_s});\n        Pool_CurveECC_Point.Set({ curveID, pub_x, pub_y });\n        Pool_CurveECC_Point.Set({ curveID, sig_r, sig_s });\n\n        if ( pub_x.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(pub_x); }\n        if ( pub_y.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(pub_y); }\n        if ( sig_r.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(sig_r); }\n        if ( sig_s.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(sig_s); }\n    }\n}\n\ntemplate<> std::optional<component::ECGDSA_Signature> ExecutorBase<component::ECGDSA_Signature, operation::ECGDSA_Sign>::callModule(std::shared_ptr<Module> module, operation::ECGDSA_Sign& op) const {\n    RETURN_IF_DISABLED(options.curves, op.curveType.Get());\n    RETURN_IF_DISABLED(options.digests, op.digestType.Get());\n\n    const size_t size = op.priv.ToTrimmedString().size();\n\n    if ( size == 0 || size > 4096 ) {\n        return std::nullopt;\n    }\n\n    return module->OpECGDSA_Sign(op);\n}\n\ntemplate <>\nbool ExecutorBase<component::ECGDSA_Signature, operation::ECGDSA_Sign>::dontCompare(const operation::ECGDSA_Sign& operation) const {\n    if (\n            operation.curveType.Get() != CF_ECC_CURVE(\"ed25519\") &&\n            operation.curveType.Get() != CF_ECC_CURVE(\"ed448\") ) {\n        if ( operation.UseRandomNonce() ) {\n            /* Don't compare ECGDSA signatures comptued from a randomly generated nonce */\n            return true;\n        }\n    }\n\n    return false;\n}\n\n\ntemplate class ExecutorBase<component::ECGDSA_Signature, operation::ECGDSA_Sign>;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECRDSA_Sign code for executor.cpp"}, {"role": "assistant", "content": "/* Specialization for operation::ECRDSA_Sign */template<> void ExecutorBase<component::ECRDSA_Signature, operation::ECRDSA_Sign>::postprocess(std::shared_ptr<Module> module, operation::ECRDSA_Sign& op, const ExecutorBase<component::ECRDSA_Signature, operation::ECRDSA_Sign>::ResultPair& result) const {\n    (void)module;\n\n    if ( result.second != std::nullopt  ) {\n        const auto curveID = op.curveType.Get();\n        const auto cleartext = op.cleartext.ToHex();\n        const auto pub_x = result.second->pub.first.ToTrimmedString();\n        const auto pub_y = result.second->pub.second.ToTrimmedString();\n        const auto sig_r = result.second->signature.first.ToTrimmedString();\n        const auto sig_s = result.second->signature.second.ToTrimmedString();\n\n        Pool_CurveECDSASignature.Set({ curveID, cleartext, pub_x, pub_y, sig_r, sig_s});\n        Pool_CurveECC_Point.Set({ curveID, pub_x, pub_y });\n        Pool_CurveECC_Point.Set({ curveID, sig_r, sig_s });\n\n        if ( pub_x.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(pub_x); }\n        if ( pub_y.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(pub_y); }\n        if ( sig_r.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(sig_r); }\n        if ( sig_s.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(sig_s); }\n    }\n}\n\ntemplate<> std::optional<component::ECRDSA_Signature> ExecutorBase<component::ECRDSA_Signature, operation::ECRDSA_Sign>::callModule(std::shared_ptr<Module> module, operation::ECRDSA_Sign& op) const {\n    RETURN_IF_DISABLED(options.curves, op.curveType.Get());\n    RETURN_IF_DISABLED(options.digests, op.digestType.Get());\n\n    const size_t size = op.priv.ToTrimmedString().size();\n\n    if ( size == 0 || size > 4096 ) {\n        return std::nullopt;\n    }\n\n    return module->OpECRDSA_Sign(op);\n}\n\ntemplate <>\nbool ExecutorBase<component::ECRDSA_Signature, operation::ECRDSA_Sign>::dontCompare(const operation::ECRDSA_Sign& operation) const {\n    if (\n            operation.curveType.Get() != CF_ECC_CURVE(\"ed25519\") &&\n            operation.curveType.Get() != CF_ECC_CURVE(\"ed448\") ) {\n        if ( operation.UseRandomNonce() ) {\n            /* Don't compare ECRDSA signatures comptued from a randomly generated nonce */\n            return true;\n        }\n    }\n\n    return false;\n}\n\n\ntemplate class ExecutorBase<component::ECRDSA_Signature, operation::ECRDSA_Sign>;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate Schnorr_Sign code for executor.cpp"}, {"role": "assistant", "content": "/* Specialization for operation::Schnorr_Sign */template<> void ExecutorBase<component::Schnorr_Signature, operation::Schnorr_Sign>::postprocess(std::shared_ptr<Module> module, operation::Schnorr_Sign& op, const ExecutorBase<component::Schnorr_Signature, operation::Schnorr_Sign>::ResultPair& result) const {\n    (void)module;\n\n    if ( result.second != std::nullopt  ) {\n        const auto curveID = op.curveType.Get();\n        const auto cleartext = op.cleartext.ToHex();\n        const auto pub_x = result.second->pub.first.ToTrimmedString();\n        const auto pub_y = result.second->pub.second.ToTrimmedString();\n        const auto sig_r = result.second->signature.first.ToTrimmedString();\n        const auto sig_s = result.second->signature.second.ToTrimmedString();\n\n        Pool_CurveECDSASignature.Set({ curveID, cleartext, pub_x, pub_y, sig_r, sig_s});\n        Pool_CurveECC_Point.Set({ curveID, pub_x, pub_y });\n        Pool_CurveECC_Point.Set({ curveID, sig_r, sig_s });\n\n        if ( pub_x.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(pub_x); }\n        if ( pub_y.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(pub_y); }\n        if ( sig_r.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(sig_r); }\n        if ( sig_s.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(sig_s); }\n    }\n}\n\ntemplate<> std::optional<component::Schnorr_Signature> ExecutorBase<component::Schnorr_Signature, operation::Schnorr_Sign>::callModule(std::shared_ptr<Module> module, operation::Schnorr_Sign& op) const {\n    RETURN_IF_DISABLED(options.curves, op.curveType.Get());\n    RETURN_IF_DISABLED(options.digests, op.digestType.Get());\n\n    const size_t size = op.priv.ToTrimmedString().size();\n\n    if ( size == 0 || size > 4096 ) {\n        return std::nullopt;\n    }\n\n    return module->OpSchnorr_Sign(op);\n}\n\n\ntemplate class ExecutorBase<component::Schnorr_Signature, operation::Schnorr_Sign>;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECCSI_Verify code for executor.cpp"}, {"role": "assistant", "content": "/* Specialization for operation::ECCSI_Verify */template<> void ExecutorBase<bool, operation::ECCSI_Verify>::postprocess(std::shared_ptr<Module> module, operation::ECCSI_Verify& op, const ExecutorBase<bool, operation::ECCSI_Verify>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n    (void)result;\n}\n\ntemplate<> std::optional<bool> ExecutorBase<bool, operation::ECCSI_Verify>::callModule(std::shared_ptr<Module> module, operation::ECCSI_Verify& op) const {\n    RETURN_IF_DISABLED(options.curves, op.curveType.Get());\n    RETURN_IF_DISABLED(options.digests, op.digestType.Get());\n\n    return module->OpECCSI_Verify(op);\n}\n\n\ntemplate class ExecutorBase<bool, operation::ECCSI_Verify>;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECDSA_Verify code for executor.cpp"}, {"role": "assistant", "content": "/* Specialization for operation::ECDSA_Verify */template<> void ExecutorBase<bool, operation::ECDSA_Verify>::postprocess(std::shared_ptr<Module> module, operation::ECDSA_Verify& op, const ExecutorBase<bool, operation::ECDSA_Verify>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n    (void)result;\n}\n\ntemplate<> std::optional<bool> ExecutorBase<bool, operation::ECDSA_Verify>::callModule(std::shared_ptr<Module> module, operation::ECDSA_Verify& op) const {\n    RETURN_IF_DISABLED(options.curves, op.curveType.Get());\n    RETURN_IF_DISABLED(options.digests, op.digestType.Get());\n\n    /* Intentionally do not constrain the size of the public key or\n     * signature (like we do for BignumCalc).\n     *\n     * If any large public key or signature causes a time-out (or\n     * worse), this is something that needs attention;\n     * because verifiers sometimes process untrusted public keys,\n     * signatures or both, they should be resistant to bugs\n     * arising from large inputs.\n     */\n\n    return module->OpECDSA_Verify(op);\n}\n\n\ntemplate class ExecutorBase<bool, operation::ECDSA_Verify>;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECGDSA_Verify code for executor.cpp"}, {"role": "assistant", "content": "/* Specialization for operation::ECGDSA_Verify */template<> void ExecutorBase<bool, operation::ECGDSA_Verify>::postprocess(std::shared_ptr<Module> module, operation::ECGDSA_Verify& op, const ExecutorBase<bool, operation::ECGDSA_Verify>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n    (void)result;\n}\n\ntemplate<> std::optional<bool> ExecutorBase<bool, operation::ECGDSA_Verify>::callModule(std::shared_ptr<Module> module, operation::ECGDSA_Verify& op) const {\n    RETURN_IF_DISABLED(options.curves, op.curveType.Get());\n    RETURN_IF_DISABLED(options.digests, op.digestType.Get());\n\n    /* Intentionally do not constrain the size of the public key or\n     * signature (like we do for BignumCalc).\n     *\n     * If any large public key or signature causes a time-out (or\n     * worse), this is something that needs attention;\n     * because verifiers sometimes process untrusted public keys,\n     * signatures or both, they should be resistant to bugs\n     * arising from large inputs.\n     */\n\n    return module->OpECGDSA_Verify(op);\n}\n\n\ntemplate class ExecutorBase<bool, operation::ECGDSA_Verify>;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECRDSA_Verify code for executor.cpp"}, {"role": "assistant", "content": "/* Specialization for operation::ECRDSA_Verify */template<> void ExecutorBase<bool, operation::ECRDSA_Verify>::postprocess(std::shared_ptr<Module> module, operation::ECRDSA_Verify& op, const ExecutorBase<bool, operation::ECRDSA_Verify>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n    (void)result;\n}\n\ntemplate<> std::optional<bool> ExecutorBase<bool, operation::ECRDSA_Verify>::callModule(std::shared_ptr<Module> module, operation::ECRDSA_Verify& op) const {\n    RETURN_IF_DISABLED(options.curves, op.curveType.Get());\n    RETURN_IF_DISABLED(options.digests, op.digestType.Get());\n\n    /* Intentionally do not constrain the size of the public key or\n     * signature (like we do for BignumCalc).\n     *\n     * If any large public key or signature causes a time-out (or\n     * worse), this is something that needs attention;\n     * because verifiers sometimes process untrusted public keys,\n     * signatures or both, they should be resistant to bugs\n     * arising from large inputs.\n     */\n\n    return module->OpECRDSA_Verify(op);\n}\n\n\ntemplate class ExecutorBase<bool, operation::ECRDSA_Verify>;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate Schnorr_Verify code for executor.cpp"}, {"role": "assistant", "content": "/* Specialization for operation::Schnorr_Verify */template<> void ExecutorBase<bool, operation::Schnorr_Verify>::postprocess(std::shared_ptr<Module> module, operation::Schnorr_Verify& op, const ExecutorBase<bool, operation::Schnorr_Verify>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n    (void)result;\n}\n\ntemplate<> std::optional<bool> ExecutorBase<bool, operation::Schnorr_Verify>::callModule(std::shared_ptr<Module> module, operation::Schnorr_Verify& op) const {\n    RETURN_IF_DISABLED(options.curves, op.curveType.Get());\n    RETURN_IF_DISABLED(options.digests, op.digestType.Get());\n\n    /* Intentionally do not constrain the size of the public key or\n     * signature (like we do for BignumCalc).\n     *\n     * If any large public key or signature causes a time-out (or\n     * worse), this is something that needs attention;\n     * because verifiers sometimes process untrusted public keys,\n     * signatures or both, they should be resistant to bugs\n     * arising from large inputs.\n     */\n\n    return module->OpSchnorr_Verify(op);\n}\n\n\n\ntemplate class ExecutorBase<bool, operation::Schnorr_Verify>;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECDSA_Recover code for executor.cpp"}, {"role": "assistant", "content": "/* Specialization for operation::ECDSA_Recover */template<> void ExecutorBase<component::ECC_PublicKey, operation::ECDSA_Recover>::postprocess(std::shared_ptr<Module> module, operation::ECDSA_Recover& op, const ExecutorBase<component::ECC_PublicKey, operation::ECDSA_Recover>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n    (void)result;\n}\n\ntemplate<> std::optional<component::ECC_PublicKey> ExecutorBase<component::ECC_PublicKey, operation::ECDSA_Recover>::callModule(std::shared_ptr<Module> module, operation::ECDSA_Recover& op) const {\n    RETURN_IF_DISABLED(options.curves, op.curveType.Get());\n    RETURN_IF_DISABLED(options.digests, op.digestType.Get());\n\n    return module->OpECDSA_Recover(op);\n}\n\n\ntemplate class ExecutorBase<component::ECC_PublicKey, operation::ECDSA_Recover>;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate DSA_Verify code for executor.cpp"}, {"role": "assistant", "content": "/* Specialization for operation::DSA_Verify */template<> void ExecutorBase<bool, operation::DSA_Verify>::updateExtraCounters(const uint64_t moduleID, operation::DSA_Verify& op) const {\n    (void)moduleID;\n    (void)op;\n\n    /* TODO */\n}\n\ntemplate<> void ExecutorBase<bool, operation::DSA_Verify>::postprocess(std::shared_ptr<Module> module, operation::DSA_Verify& op, const ExecutorBase<bool, operation::DSA_Verify>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n    (void)result;\n}\n\ntemplate<> std::optional<bool> ExecutorBase<bool, operation::DSA_Verify>::callModule(std::shared_ptr<Module> module, operation::DSA_Verify& op) const {\n    const std::vector<size_t> sizes = {\n        op.parameters.p.ToTrimmedString().size(),\n        op.parameters.q.ToTrimmedString().size(),\n        op.parameters.g.ToTrimmedString().size(),\n        op.pub.ToTrimmedString().size(),\n        op.signature.first.ToTrimmedString().size(),\n        op.signature.second.ToTrimmedString().size(),\n    };\n\n    for (const auto& size : sizes) {\n        if ( size == 0 || size > 4096 ) {\n            return std::nullopt;\n        }\n    }\n\n    return module->OpDSA_Verify(op);\n}\n\n\ntemplate class ExecutorBase<bool, operation::DSA_Verify>;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate DSA_Sign code for executor.cpp"}, {"role": "assistant", "content": "/* Specialization for operation::DSA_Sign *//* Do not compare DSA_Sign results, because the result can be produced indeterministically */\ntemplate <>\nvoid ExecutorBase<component::DSA_Signature, operation::DSA_Sign>::compare(const std::vector< std::pair<std::shared_ptr<Module>, operation::DSA_Sign> >& operations, const ResultSet& results, const uint8_t* data, const size_t size) const {\n    (void)operations;\n    (void)results;\n    (void)data;\n    (void)size;\n}\ntemplate<> void ExecutorBase<component::DSA_Signature, operation::DSA_Sign>::updateExtraCounters(const uint64_t moduleID, operation::DSA_Sign& op) const {\n    (void)moduleID;\n    (void)op;\n\n    /* TODO */\n}\n\ntemplate<> void ExecutorBase<component::DSA_Signature, operation::DSA_Sign>::postprocess(std::shared_ptr<Module> module, operation::DSA_Sign& op, const ExecutorBase<component::DSA_Signature, operation::DSA_Sign>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n    if ( result.second != std::nullopt ) {\n        const auto cleartext = op.cleartext.ToHex();\n        const auto p = op.parameters.p.ToTrimmedString();\n        const auto q = op.parameters.q.ToTrimmedString();\n        const auto g = op.parameters.g.ToTrimmedString();\n        const auto r = result.second->signature.first.ToTrimmedString();\n        const auto s = result.second->signature.second.ToTrimmedString();\n        const auto pub = result.second->pub.ToTrimmedString();\n\n        Pool_DSASignature.Set({\n                cleartext,\n                p,\n                q,\n                g,\n                pub,\n                r,\n                s\n        });\n\n        if ( r.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(r); }\n        if ( s.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(s); }\n    }\n}\n\ntemplate<> std::optional<component::DSA_Signature> ExecutorBase<component::DSA_Signature, operation::DSA_Sign>::callModule(std::shared_ptr<Module> module, operation::DSA_Sign& op) const {\n    const std::vector<size_t> sizes = {\n        op.parameters.p.ToTrimmedString().size(),\n        op.parameters.q.ToTrimmedString().size(),\n        op.parameters.g.ToTrimmedString().size(),\n        op.priv.ToTrimmedString().size(),\n    };\n\n    for (const auto& size : sizes) {\n        if ( size == 0 || size > 4096 ) {\n            return std::nullopt;\n        }\n    }\n\n    return module->OpDSA_Sign(op);\n}\n\n\ntemplate class ExecutorBase<component::DSA_Signature, operation::DSA_Sign>;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate DSA_PrivateToPublic code for executor.cpp"}, {"role": "assistant", "content": "/* Specialization for operation::DSA_PrivateToPublic */\ntemplate<> void ExecutorBase<component::Bignum, operation::DSA_PrivateToPublic>::updateExtraCounters(const uint64_t moduleID, operation::DSA_PrivateToPublic& op) const {\n    (void)moduleID;\n    (void)op;\n\n    /* TODO */\n}\n\ntemplate<> void ExecutorBase<component::Bignum, operation::DSA_PrivateToPublic>::postprocess(std::shared_ptr<Module> module, operation::DSA_PrivateToPublic& op, const ExecutorBase<component::Bignum, operation::DSA_PrivateToPublic>::ResultPair& result) const {\n    (void)result;\n    (void)module;\n    (void)op;\n    if ( result.second != std::nullopt ) {\n        //Pool_DSA_PubPriv.Set({pub, priv});\n    }\n}\n\ntemplate<> std::optional<component::Bignum> ExecutorBase<component::Bignum, operation::DSA_PrivateToPublic>::callModule(std::shared_ptr<Module> module, operation::DSA_PrivateToPublic& op) const {\n    return module->OpDSA_PrivateToPublic(op);\n}\n\n\ntemplate class ExecutorBase<component::Bignum, operation::DSA_PrivateToPublic>;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate DSA_GenerateKeyPair code for executor.cpp"}, {"role": "assistant", "content": "/* Specialization for operation::DSA_GenerateKeyPair */\n/* Do not compare DSA_GenerateKeyPair results, because the result can be produced indeterministically */\ntemplate <>\nvoid ExecutorBase<component::DSA_KeyPair, operation::DSA_GenerateKeyPair>::compare(const std::vector< std::pair<std::shared_ptr<Module>, operation::DSA_GenerateKeyPair> >& operations, const ResultSet& results, const uint8_t* data, const size_t size) const {\n    (void)operations;\n    (void)results;\n    (void)data;\n    (void)size;\n}\n\ntemplate<> void ExecutorBase<component::DSA_KeyPair, operation::DSA_GenerateKeyPair>::updateExtraCounters(const uint64_t moduleID, operation::DSA_GenerateKeyPair& op) const {\n    (void)moduleID;\n    (void)op;\n\n    /* TODO */\n}\n\ntemplate<> void ExecutorBase<component::DSA_KeyPair, operation::DSA_GenerateKeyPair>::postprocess(std::shared_ptr<Module> module, operation::DSA_GenerateKeyPair& op, const ExecutorBase<component::DSA_KeyPair, operation::DSA_GenerateKeyPair>::ResultPair& result) const {\n    (void)result;\n    (void)module;\n    (void)op;\n    if ( result.second != std::nullopt && (PRNG() % 4) == 0 ) {\n        const auto priv = result.second->first.ToTrimmedString();\n        const auto pub = result.second->second.ToTrimmedString();\n\n        Pool_DSA_PubPriv.Set({pub, priv});\n    }\n}\n\ntemplate<> std::optional<component::DSA_KeyPair> ExecutorBase<component::DSA_KeyPair, operation::DSA_GenerateKeyPair>::callModule(std::shared_ptr<Module> module, operation::DSA_GenerateKeyPair& op) const {\n    const std::vector<size_t> sizes = {\n        op.p.ToTrimmedString().size(),\n        op.q.ToTrimmedString().size(),\n        op.g.ToTrimmedString().size(),\n    };\n\n    for (const auto& size : sizes) {\n        if ( size == 0 || size > 4096 ) {\n            return std::nullopt;\n        }\n    }\n\n    return module->OpDSA_GenerateKeyPair(op);\n}\n\n\ntemplate class ExecutorBase<component::DSA_KeyPair, operation::DSA_GenerateKeyPair>;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate DSA_GenerateParameters code for executor.cpp"}, {"role": "assistant", "content": "/* Specialization for operation::DSA_GenerateParameters */\ntemplate <>\nvoid ExecutorBase<component::DSA_Parameters, operation::DSA_GenerateParameters>::compare(const std::vector< std::pair<std::shared_ptr<Module>, operation::DSA_GenerateParameters> >& operations, const ResultSet& results, const uint8_t* data, const size_t size) const {\n    (void)operations;\n    (void)results;\n    (void)data;\n    (void)size;\n}\n\ntemplate<> void ExecutorBase<component::DSA_Parameters, operation::DSA_GenerateParameters>::updateExtraCounters(const uint64_t moduleID, operation::DSA_GenerateParameters& op) const {\n    (void)moduleID;\n    (void)op;\n\n    /* TODO */\n}\n\ntemplate<> void ExecutorBase<component::DSA_Parameters, operation::DSA_GenerateParameters>::postprocess(std::shared_ptr<Module> module, operation::DSA_GenerateParameters& op, const ExecutorBase<component::DSA_Parameters, operation::DSA_GenerateParameters>::ResultPair& result) const {\n    (void)result;\n    (void)module;\n    (void)op;\n    if ( result.second != std::nullopt && (PRNG() % 4) == 0 ) {\n        const auto P = result.second->p.ToTrimmedString();\n        const auto Q = result.second->q.ToTrimmedString();\n        const auto G = result.second->g.ToTrimmedString();\n\n        Pool_DSA_PQG.Set({P, Q, G});\n\n        if ( P.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(P); }\n        if ( Q.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(Q); }\n        if ( G.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(G); }\n    }\n}\n\ntemplate<> std::optional<component::DSA_Parameters> ExecutorBase<component::DSA_Parameters, operation::DSA_GenerateParameters>::callModule(std::shared_ptr<Module> module, operation::DSA_GenerateParameters& op) const {\n    return module->OpDSA_GenerateParameters(op);\n}\n\n\ntemplate class ExecutorBase<component::DSA_Parameters, operation::DSA_GenerateParameters>;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECDH_Derive code for executor.cpp"}, {"role": "assistant", "content": "/* Specialization for operation::ECDH_Derive */template<> void ExecutorBase<component::Secret, operation::ECDH_Derive>::postprocess(std::shared_ptr<Module> module, operation::ECDH_Derive& op, const ExecutorBase<component::Secret, operation::ECDH_Derive>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n    (void)result;\n}\n\ntemplate<> std::optional<component::Secret> ExecutorBase<component::Secret, operation::ECDH_Derive>::callModule(std::shared_ptr<Module> module, operation::ECDH_Derive& op) const {\n    RETURN_IF_DISABLED(options.curves, op.curveType.Get());\n\n    return module->OpECDH_Derive(op);\n}\n\n\ntemplate class ExecutorBase<component::Secret, operation::ECDH_Derive>;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECIES_Encrypt code for executor.cpp"}, {"role": "assistant", "content": "/* Specialization for operation::ECIES_Encrypt */template <>\nvoid ExecutorBase<component::Ciphertext, operation::ECIES_Encrypt>::compare(const std::vector< std::pair<std::shared_ptr<Module>, operation::ECIES_Encrypt> >& operations, const ResultSet& results, const uint8_t* data, const size_t size) const {\n    (void)operations;\n    (void)results;\n    (void)data;\n    (void)size;\n}\ntemplate<> void ExecutorBase<component::Ciphertext, operation::ECIES_Encrypt>::postprocess(std::shared_ptr<Module> module, operation::ECIES_Encrypt& op, const ExecutorBase<component::Ciphertext, operation::ECIES_Encrypt>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n    (void)result;\n}\n\ntemplate<> std::optional<component::Ciphertext> ExecutorBase<component::Ciphertext, operation::ECIES_Encrypt>::callModule(std::shared_ptr<Module> module, operation::ECIES_Encrypt& op) const {\n    RETURN_IF_DISABLED(options.curves, op.curveType.Get());\n\n    return module->OpECIES_Encrypt(op);\n}\n\n\ntemplate class ExecutorBase<component::Ciphertext, operation::ECIES_Encrypt>;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECIES_Decrypt code for executor.cpp"}, {"role": "assistant", "content": "/* Specialization for operation::ECIES_Decrypt */template<> void ExecutorBase<component::Cleartext, operation::ECIES_Decrypt>::postprocess(std::shared_ptr<Module> module, operation::ECIES_Decrypt& op, const ExecutorBase<component::Cleartext, operation::ECIES_Decrypt>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n    (void)result;\n}\n\ntemplate<> std::optional<component::Cleartext> ExecutorBase<component::Cleartext, operation::ECIES_Decrypt>::callModule(std::shared_ptr<Module> module, operation::ECIES_Decrypt& op) const {\n    RETURN_IF_DISABLED(options.curves, op.curveType.Get());\n\n    return module->OpECIES_Decrypt(op);\n}\n\n\ntemplate class ExecutorBase<component::Cleartext, operation::ECIES_Decrypt>;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_Point_Add code for executor.cpp"}, {"role": "assistant", "content": "/* Specialization for operation::ECC_Point_Add */template<> void ExecutorBase<component::ECC_Point, operation::ECC_Point_Add>::postprocess(std::shared_ptr<Module> module, operation::ECC_Point_Add& op, const ExecutorBase<component::ECC_Point, operation::ECC_Point_Add>::ResultPair& result) const {\n    (void)module;\n\n    if ( result.second != std::nullopt  ) {\n        const auto curveID = op.curveType.Get();\n        const auto x = result.second->first.ToTrimmedString();\n        const auto y = result.second->second.ToTrimmedString();\n\n        Pool_CurveECC_Point.Set({ curveID, x, y });\n\n        if ( x.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(x); }\n        if ( y.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(y); }\n    }\n}\n\ntemplate<> std::optional<component::ECC_Point> ExecutorBase<component::ECC_Point, operation::ECC_Point_Add>::callModule(std::shared_ptr<Module> module, operation::ECC_Point_Add& op) const {\n    RETURN_IF_DISABLED(options.curves, op.curveType.Get());\n\n    return module->OpECC_Point_Add(op);\n}\n\n\ntemplate class ExecutorBase<component::ECC_Point, operation::ECC_Point_Add>;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_Point_Sub code for executor.cpp"}, {"role": "assistant", "content": "/* Specialization for operation::ECC_Point_Sub */template<> void ExecutorBase<component::ECC_Point, operation::ECC_Point_Sub>::postprocess(std::shared_ptr<Module> module, operation::ECC_Point_Sub& op, const ExecutorBase<component::ECC_Point, operation::ECC_Point_Sub>::ResultPair& result) const {\n    (void)module;\n\n    if ( result.second != std::nullopt  ) {\n        const auto curveID = op.curveType.Get();\n        const auto x = result.second->first.ToTrimmedString();\n        const auto y = result.second->second.ToTrimmedString();\n\n        Pool_CurveECC_Point.Set({ curveID, x, y });\n\n        if ( x.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(x); }\n        if ( y.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(y); }\n    }\n}\n\ntemplate<> std::optional<component::ECC_Point> ExecutorBase<component::ECC_Point, operation::ECC_Point_Sub>::callModule(std::shared_ptr<Module> module, operation::ECC_Point_Sub& op) const {\n    RETURN_IF_DISABLED(options.curves, op.curveType.Get());\n\n    return module->OpECC_Point_Sub(op);\n}\n\n\ntemplate class ExecutorBase<component::ECC_Point, operation::ECC_Point_Sub>;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_Point_Mul code for executor.cpp"}, {"role": "assistant", "content": "/* Specialization for operation::ECC_Point_Mul */template<> void ExecutorBase<component::ECC_Point, operation::ECC_Point_Mul>::postprocess(std::shared_ptr<Module> module, operation::ECC_Point_Mul& op, const ExecutorBase<component::ECC_Point, operation::ECC_Point_Mul>::ResultPair& result) const {\n    (void)module;\n\n    if ( result.second != std::nullopt  ) {\n        const auto curveID = op.curveType.Get();\n        const auto x = result.second->first.ToTrimmedString();\n        const auto y = result.second->second.ToTrimmedString();\n\n        Pool_CurveECC_Point.Set({ curveID, x, y });\n\n        if ( x.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(x); }\n        if ( y.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(y); }\n    }\n}\n\ntemplate<> std::optional<component::ECC_Point> ExecutorBase<component::ECC_Point, operation::ECC_Point_Mul>::callModule(std::shared_ptr<Module> module, operation::ECC_Point_Mul& op) const {\n    RETURN_IF_DISABLED(options.curves, op.curveType.Get());\n\n    return module->OpECC_Point_Mul(op);\n}\n\n\ntemplate class ExecutorBase<component::ECC_Point, operation::ECC_Point_Mul>;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_Point_Neg code for executor.cpp"}, {"role": "assistant", "content": "/* Specialization for operation::ECC_Point_Neg */template<> void ExecutorBase<component::ECC_Point, operation::ECC_Point_Neg>::postprocess(std::shared_ptr<Module> module, operation::ECC_Point_Neg& op, const ExecutorBase<component::ECC_Point, operation::ECC_Point_Neg>::ResultPair& result) const {\n    (void)module;\n\n    if ( result.second != std::nullopt  ) {\n        const auto curveID = op.curveType.Get();\n        const auto x = result.second->first.ToTrimmedString();\n        const auto y = result.second->second.ToTrimmedString();\n\n        Pool_CurveECC_Point.Set({ curveID, x, y });\n\n        if ( x.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(x); }\n        if ( y.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(y); }\n    }\n}\n\ntemplate<> std::optional<component::ECC_Point> ExecutorBase<component::ECC_Point, operation::ECC_Point_Neg>::callModule(std::shared_ptr<Module> module, operation::ECC_Point_Neg& op) const {\n    RETURN_IF_DISABLED(options.curves, op.curveType.Get());\n\n    return module->OpECC_Point_Neg(op);\n}\n\n\ntemplate class ExecutorBase<component::ECC_Point, operation::ECC_Point_Neg>;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_Point_Dbl code for executor.cpp"}, {"role": "assistant", "content": "/* Specialization for operation::ECC_Point_Dbl */template<> void ExecutorBase<component::ECC_Point, operation::ECC_Point_Dbl>::postprocess(std::shared_ptr<Module> module, operation::ECC_Point_Dbl& op, const ExecutorBase<component::ECC_Point, operation::ECC_Point_Dbl>::ResultPair& result) const {\n    (void)module;\n\n    if ( result.second != std::nullopt  ) {\n        const auto curveID = op.curveType.Get();\n        const auto x = result.second->first.ToTrimmedString();\n        const auto y = result.second->second.ToTrimmedString();\n\n        Pool_CurveECC_Point.Set({ curveID, x, y });\n\n        if ( x.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(x); }\n        if ( y.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(y); }\n    }\n}\n\ntemplate<> std::optional<component::ECC_Point> ExecutorBase<component::ECC_Point, operation::ECC_Point_Dbl>::callModule(std::shared_ptr<Module> module, operation::ECC_Point_Dbl& op) const {\n    RETURN_IF_DISABLED(options.curves, op.curveType.Get());\n\n    return module->OpECC_Point_Dbl(op);\n}\n\n\ntemplate class ExecutorBase<component::ECC_Point, operation::ECC_Point_Dbl>;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_Point_Cmp code for executor.cpp"}, {"role": "assistant", "content": "/* Specialization for operation::ECC_Point_Cmp */template<> void ExecutorBase<bool, operation::ECC_Point_Cmp>::postprocess(std::shared_ptr<Module> module, operation::ECC_Point_Cmp& op, const ExecutorBase<bool, operation::ECC_Point_Cmp>::ResultPair& result) const {\n    (void)module;\n    (void)result;\n    (void)op;\n}\n\ntemplate<> std::optional<bool> ExecutorBase<bool, operation::ECC_Point_Cmp>::callModule(std::shared_ptr<Module> module, operation::ECC_Point_Cmp& op) const {\n    RETURN_IF_DISABLED(options.curves, op.curveType.Get());\n\n    return module->OpECC_Point_Cmp(op);\n}\n\n\ntemplate class ExecutorBase<bool, operation::ECC_Point_Cmp>;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate DH_Derive code for executor.cpp"}, {"role": "assistant", "content": "/* Specialization for operation::DH_Derive */template<> void ExecutorBase<component::Bignum, operation::DH_Derive>::postprocess(std::shared_ptr<Module> module, operation::DH_Derive& op, const ExecutorBase<component::Bignum, operation::DH_Derive>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n    (void)result;\n}\n\ntemplate<> std::optional<component::Bignum> ExecutorBase<component::Bignum, operation::DH_Derive>::callModule(std::shared_ptr<Module> module, operation::DH_Derive& op) const {\n    if ( op.prime.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.base.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.pub.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.priv.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n\n    return module->OpDH_Derive(op);\n}\n\n\ntemplate class ExecutorBase<component::Bignum, operation::DH_Derive>;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate DH_GenerateKeyPair code for executor.cpp"}, {"role": "assistant", "content": "/* Specialization for operation::DH_GenerateKeyPair */template<> void ExecutorBase<component::DH_KeyPair, operation::DH_GenerateKeyPair>::postprocess(std::shared_ptr<Module> module, operation::DH_GenerateKeyPair& op, const ExecutorBase<component::DH_KeyPair, operation::DH_GenerateKeyPair>::ResultPair& result) const {\n    (void)result;\n    (void)op;\n    (void)module;\n\n    if ( result.second != std::nullopt && (PRNG() % 4) == 0 ) {\n        const auto priv = result.second->first.ToTrimmedString();\n        const auto pub = result.second->second.ToTrimmedString();\n\n        Pool_DH_PrivateKey.Set(priv);\n        Pool_DH_PublicKey.Set(pub);\n    }\n}\n\ntemplate<> std::optional<component::DH_KeyPair> ExecutorBase<component::DH_KeyPair, operation::DH_GenerateKeyPair>::callModule(std::shared_ptr<Module> module, operation::DH_GenerateKeyPair& op) const {\n    if ( op.prime.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.base.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n\n    return module->OpDH_GenerateKeyPair(op);\n}\n\n\ntemplate class ExecutorBase<component::DH_KeyPair, operation::DH_GenerateKeyPair>;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc code for executor.cpp"}, {"role": "assistant", "content": "/* Specialization for operation::BignumCalc */template<> void ExecutorBase<component::Bignum, operation::BignumCalc>::postprocess(std::shared_ptr<Module> module, operation::BignumCalc& op, const ExecutorBase<component::Bignum, operation::BignumCalc>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n\n    if ( result.second != std::nullopt  ) {\n        const auto bignum = result.second->ToTrimmedString();\n\n        if ( bignum.size() <= config::kMaxBignumSize ) {\n            Pool_Bignum.Set(bignum);\n            if ( op.calcOp.Is(CF_CALCOP(\"Prime()\")) ) {\n                Pool_Bignum_Primes.Set(bignum);\n            }\n        }\n        if ( op.calcOp.Is(CF_CALCOP(\"IsPrime(A)\")) ) {\n            if ( bignum == \"1\" ) {\n                Pool_Bignum_Primes.Set(op.bn0.ToTrimmedString());\n            }\n        }\n    }\n}\n\nstd::optional<component::Bignum> ExecutorBignumCalc::callModule(std::shared_ptr<Module> module, operation::BignumCalc& op) const {\n    RETURN_IF_DISABLED(options.calcOps, op.calcOp.Get());\n\n    /* Prevent timeouts */\n    if ( op.bn0.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn1.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn2.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn3.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n\n    if ( op.modulo != std::nullopt && !module->SupportsModularBignumCalc() ) {\n        return std::nullopt;\n    }\n\n    switch ( op.calcOp.Get() ) {\n        case    CF_CALCOP(\"SetBit(A,B)\"):\n            /* Don't allow setting very high bit positions (risk of memory exhaustion) */\n            if ( op.bn1.GetSize() > 4 ) {\n                return std::nullopt;\n            }\n            break;\n        case    CF_CALCOP(\"Exp(A,B)\"):\n            if ( op.bn0.GetSize() > 5 || op.bn1.GetSize() > 2 ) {\n                return std::nullopt;\n            }\n            break;\n        case    CF_CALCOP(\"ModLShift(A,B,C)\"):\n            if ( op.bn1.GetSize() > 4 ) {\n                return std::nullopt;\n            }\n            break;\n        case    CF_CALCOP(\"Exp2(A)\"):\n            if ( op.bn0.GetSize() > 4 ) {\n                return std::nullopt;\n            }\n            break;\n    }\n\n    return module->OpBignumCalc(op);\n}\n\n\ntemplate class ExecutorBase<component::Bignum, operation::BignumCalc>;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Fp2 code for executor.cpp"}, {"role": "assistant", "content": "/* Specialization for operation::BignumCalc_Fp2 */template<> void ExecutorBase<component::Fp2, operation::BignumCalc_Fp2>::postprocess(std::shared_ptr<Module> module, operation::BignumCalc_Fp2& op, const ExecutorBase<component::Fp2, operation::BignumCalc_Fp2>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n\n    if ( result.second != std::nullopt  ) {\n        const auto bignum_first = result.second->first.ToTrimmedString();\n        const auto bignum_second = result.second->second.ToTrimmedString();\n\n        if ( bignum_first.size() <= config::kMaxBignumSize ) {\n            Pool_Bignum.Set(bignum_first);\n        }\n        if ( bignum_second.size() <= config::kMaxBignumSize ) {\n            Pool_Bignum.Set(bignum_second);\n        }\n    }\n}\n\nstd::optional<component::Fp2> ExecutorBignumCalc_Fp2::callModule(std::shared_ptr<Module> module, operation::BignumCalc_Fp2& op) const {\n    RETURN_IF_DISABLED(options.calcOps, op.calcOp.Get());\n\n    /* Prevent timeouts */\n    if ( op.bn0.first.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn0.second.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn1.first.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn1.second.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn2.first.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn2.second.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn3.first.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn3.second.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n\n    if ( op.modulo != std::nullopt && !module->SupportsModularBignumCalc() ) {\n        return std::nullopt;\n    }\n\n    return module->OpBignumCalc_Fp2(op);\n}\n\n\ntemplate class ExecutorBase<component::Fp2, operation::BignumCalc_Fp2>;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Fp12 code for executor.cpp"}, {"role": "assistant", "content": "/* Specialization for operation::BignumCalc_Fp12 */template<> void ExecutorBase<component::Fp12, operation::BignumCalc_Fp12>::postprocess(std::shared_ptr<Module> module, operation::BignumCalc_Fp12& op, const ExecutorBase<component::Fp12, operation::BignumCalc_Fp12>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n\n    if ( result.second != std::nullopt  ) {\n        Pool_Fp12.Set({\n                result.second->bn1.ToTrimmedString(),\n                result.second->bn2.ToTrimmedString(),\n                result.second->bn3.ToTrimmedString(),\n                result.second->bn4.ToTrimmedString(),\n                result.second->bn5.ToTrimmedString(),\n                result.second->bn6.ToTrimmedString(),\n                result.second->bn7.ToTrimmedString(),\n                result.second->bn8.ToTrimmedString(),\n                result.second->bn9.ToTrimmedString(),\n                result.second->bn10.ToTrimmedString(),\n                result.second->bn11.ToTrimmedString(),\n                result.second->bn12.ToTrimmedString()\n        });\n        /* TODO */\n#if 0\n        const auto bignum_first = result.second->first.ToTrimmedString();\n        const auto bignum_second = result.second->second.ToTrimmedString();\n\n        if ( bignum_first.size() <= config::kMaxBignumSize ) {\n            Pool_Bignum.Set(bignum_first);\n        }\n        if ( bignum_second.size() <= config::kMaxBignumSize ) {\n            Pool_Bignum.Set(bignum_second);\n        }\n#endif\n    }\n}\n\nstd::optional<component::Fp12> ExecutorBignumCalc_Fp12::callModule(std::shared_ptr<Module> module, operation::BignumCalc_Fp12& op) const {\n    RETURN_IF_DISABLED(options.calcOps, op.calcOp.Get());\n\n    /* Prevent timeouts */\n    if ( op.bn0.bn1.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn0.bn2.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn0.bn3.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn0.bn4.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn0.bn5.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn0.bn6.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn0.bn7.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn0.bn8.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn0.bn9.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn0.bn10.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn0.bn11.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn0.bn12.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n\n    if ( op.bn1.bn1.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn1.bn2.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn1.bn3.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn1.bn4.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn1.bn5.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn1.bn6.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn1.bn7.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn1.bn8.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn1.bn9.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn1.bn10.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn1.bn11.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn1.bn12.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n\n    if ( op.bn2.bn1.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn2.bn2.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn2.bn3.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn2.bn4.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn2.bn5.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn2.bn6.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn2.bn7.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn2.bn8.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn2.bn9.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn2.bn10.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn2.bn11.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn2.bn12.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n\n    if ( op.bn3.bn1.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn3.bn2.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn3.bn3.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn3.bn4.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn3.bn5.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn3.bn6.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn3.bn7.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn3.bn8.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn3.bn9.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn3.bn10.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn3.bn11.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.bn3.bn12.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n\n    if ( op.modulo != std::nullopt && !module->SupportsModularBignumCalc() ) {\n        return std::nullopt;\n    }\n\n    return module->OpBignumCalc_Fp12(op);\n}\n\n\ntemplate class ExecutorBase<component::Fp12, operation::BignumCalc_Fp12>;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_PrivateToPublic code for executor.cpp"}, {"role": "assistant", "content": "/* Specialization for operation::BLS_PrivateToPublic */template<> void ExecutorBase<component::BLS_PublicKey, operation::BLS_PrivateToPublic>::postprocess(std::shared_ptr<Module> module, operation::BLS_PrivateToPublic& op, const ExecutorBase<component::BLS_PublicKey, operation::BLS_PrivateToPublic>::ResultPair& result) const {\n    (void)module;\n\n    if ( result.second != std::nullopt  ) {\n        const auto curveID = op.curveType.Get();\n        const auto g1_x = result.second->first.ToTrimmedString();\n        const auto g1_y = result.second->second.ToTrimmedString();\n\n        G1AddToPool(curveID, g1_x, g1_y);\n\n        if ( g1_x.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(g1_x); }\n        if ( g1_y.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(g1_y); }\n    }\n}\n\ntemplate<> std::optional<component::BLS_PublicKey> ExecutorBase<component::BLS_PublicKey, operation::BLS_PrivateToPublic>::callModule(std::shared_ptr<Module> module, operation::BLS_PrivateToPublic& op) const {\n    RETURN_IF_DISABLED(options.curves, op.curveType.Get());\n\n    const size_t size = op.priv.ToTrimmedString().size();\n\n    if ( size == 0 || size > 4096 ) {\n        return std::nullopt;\n    }\n\n    return module->OpBLS_PrivateToPublic(op);\n}\n\n\ntemplate class ExecutorBase<component::BLS_PublicKey, operation::BLS_PrivateToPublic>;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_PrivateToPublic_G2 code for executor.cpp"}, {"role": "assistant", "content": "/* Specialization for operation::BLS_PrivateToPublic_G2 */template<> void ExecutorBase<component::G2, operation::BLS_PrivateToPublic_G2>::postprocess(std::shared_ptr<Module> module, operation::BLS_PrivateToPublic_G2& op, const ExecutorBase<component::G2, operation::BLS_PrivateToPublic_G2>::ResultPair& result) const {\n    (void)module;\n    if ( result.second != std::nullopt  ) {\n        const auto curveID = op.curveType.Get();\n        const auto g2_v = result.second->first.first.ToTrimmedString();\n        const auto g2_w = result.second->first.second.ToTrimmedString();\n        const auto g2_x = result.second->second.first.ToTrimmedString();\n        const auto g2_y = result.second->second.second.ToTrimmedString();\n\n        G2AddToPool(curveID, g2_v, g2_w, g2_x, g2_y);\n\n        if ( g2_v.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(g2_v); }\n        if ( g2_w.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(g2_w); }\n        if ( g2_x.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(g2_x); }\n        if ( g2_y.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(g2_y); }\n    }\n}\n\ntemplate<> std::optional<component::G2> ExecutorBase<component::G2, operation::BLS_PrivateToPublic_G2>::callModule(std::shared_ptr<Module> module, operation::BLS_PrivateToPublic_G2& op) const {\n    const size_t size = op.priv.ToTrimmedString().size();\n\n    if ( size == 0 || size > 4096 ) {\n        return std::nullopt;\n    }\n\n    return module->OpBLS_PrivateToPublic_G2(op);\n}\n\n\ntemplate class ExecutorBase<component::G2, operation::BLS_PrivateToPublic_G2>;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_Sign code for executor.cpp"}, {"role": "assistant", "content": "/* Specialization for operation::BLS_Sign */template<> void ExecutorBase<component::BLS_Signature, operation::BLS_Sign>::postprocess(std::shared_ptr<Module> module, operation::BLS_Sign& op, const ExecutorBase<component::BLS_Signature, operation::BLS_Sign>::ResultPair& result) const {\n    (void)module;\n\n    if ( result.second != std::nullopt  ) {\n        const auto curveID = op.curveType.Get();\n        const auto point_v = op.hashOrPoint ? op.point.first.first.ToTrimmedString() : \"\";\n        const auto point_w = op.hashOrPoint ? op.point.first.second.ToTrimmedString() : \"\";\n        const auto point_x = op.hashOrPoint ? op.point.second.first.ToTrimmedString() : \"\";\n        const auto point_y = op.hashOrPoint ? op.point.second.second.ToTrimmedString() : \"\";\n        const auto cleartext = op.hashOrPoint ? op.cleartext.ToHex() : \"\";\n        const auto dest = op.dest.ToHex();\n        const auto aug = op.aug.ToHex();\n        const auto pub_x = result.second->pub.first.ToTrimmedString();\n        const auto pub_y = result.second->pub.second.ToTrimmedString();\n        const auto sig_v = result.second->signature.first.first.ToTrimmedString();\n        const auto sig_w = result.second->signature.first.second.ToTrimmedString();\n        const auto sig_x = result.second->signature.second.first.ToTrimmedString();\n        const auto sig_y = result.second->signature.second.second.ToTrimmedString();\n\n        G1AddToPool(curveID, pub_x, pub_y);\n        G2AddToPool(curveID, sig_v, sig_w, sig_x, sig_y);\n        Pool_CurveBLSSignature.Set({ curveID, op.hashOrPoint, point_v, point_w, point_x, point_y, cleartext, dest, aug, pub_x, pub_y, sig_v, sig_w, sig_x, sig_y});\n\n        if ( pub_x.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(pub_x); }\n        if ( pub_y.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(pub_y); }\n        if ( sig_v.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(sig_v); }\n        if ( sig_w.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(sig_w); }\n        if ( sig_x.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(sig_x); }\n        if ( sig_y.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(sig_y); }\n    }\n}\n\ntemplate<> std::optional<component::BLS_Signature> ExecutorBase<component::BLS_Signature, operation::BLS_Sign>::callModule(std::shared_ptr<Module> module, operation::BLS_Sign& op) const {\n    const size_t size = op.priv.ToTrimmedString().size();\n\n    if ( size == 0 || size > 4096 ) {\n        return std::nullopt;\n    }\n\n    return module->OpBLS_Sign(op);\n}\n\n\ntemplate class ExecutorBase<component::BLS_Signature, operation::BLS_Sign>;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_Verify code for executor.cpp"}, {"role": "assistant", "content": "/* Specialization for operation::BLS_Verify */template<> void ExecutorBase<bool, operation::BLS_Verify>::postprocess(std::shared_ptr<Module> module, operation::BLS_Verify& op, const ExecutorBase<bool, operation::BLS_Verify>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n    (void)result;\n}\n\ntemplate<> std::optional<bool> ExecutorBase<bool, operation::BLS_Verify>::callModule(std::shared_ptr<Module> module, operation::BLS_Verify& op) const {\n#if 0\n    const std::vector<size_t> sizes = {\n        op.pub.first.ToTrimmedString().size(),\n        op.pub.second.ToTrimmedString().size(),\n        op.signature.first.ToTrimmedString().size(),\n        op.signature.second.ToTrimmedString().size(),\n    };\n\n    for (const auto& size : sizes) {\n        if ( size == 0 || size > 4096 ) {\n            return std::nullopt;\n        }\n    }\n#endif\n\n    return module->OpBLS_Verify(op);\n}\n\n\ntemplate class ExecutorBase<bool, operation::BLS_Verify>;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_BatchSign code for executor.cpp"}, {"role": "assistant", "content": "/* Specialization for operation::BLS_BatchSign */template<> void ExecutorBase<component::BLS_BatchSignature, operation::BLS_BatchSign>::postprocess(std::shared_ptr<Module> module, operation::BLS_BatchSign& op, const ExecutorBase<component::BLS_BatchSignature, operation::BLS_BatchSign>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n\n    if ( result.second != std::nullopt  ) {\n        std::vector< std::pair<BLS_BatchSignature_::G1, BLS_BatchSignature_::G2> > msgpub;\n        for (const auto& mp : result.second->msgpub) {\n            msgpub.push_back(\n                    std::pair<BLS_BatchSignature_::G1, BLS_BatchSignature_::G2>{\n                        {\n                            mp.first.first.ToTrimmedString(),\n                            mp.first.second.ToTrimmedString()\n                        },\n                        {\n                            mp.second.first.first.ToTrimmedString(),\n                            mp.second.first.second.ToTrimmedString(),\n                            mp.second.second.first.ToTrimmedString(),\n                            mp.second.second.second.ToTrimmedString()\n                        }\n                    }\n            );\n            G1AddToPool(CF_ECC_CURVE(\"BLS12_381\"), mp.first.first.ToTrimmedString(), mp.first.second.ToTrimmedString());\n            Pool_CurveBLSG2.Set({\n                    CF_ECC_CURVE(\"BLS12_381\"),\n                    mp.second.first.first.ToTrimmedString(),\n                    mp.second.first.second.ToTrimmedString(),\n                    mp.second.second.first.ToTrimmedString(),\n                    mp.second.second.second.ToTrimmedString()\n            });\n        }\n        Pool_BLS_BatchSignature.Set({msgpub});\n    }\n}\n\ntemplate<> std::optional<component::BLS_BatchSignature> ExecutorBase<component::BLS_BatchSignature, operation::BLS_BatchSign>::callModule(std::shared_ptr<Module> module, operation::BLS_BatchSign& op) const {\n    return module->OpBLS_BatchSign(op);\n}\n\n\ntemplate class ExecutorBase<component::BLS_BatchSignature, operation::BLS_BatchSign>;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_BatchVerify code for executor.cpp"}, {"role": "assistant", "content": "/* Specialization for operation::BLS_BatchVerify */template<> void ExecutorBase<bool, operation::BLS_BatchVerify>::postprocess(std::shared_ptr<Module> module, operation::BLS_BatchVerify& op, const ExecutorBase<bool, operation::BLS_BatchVerify>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n    (void)result;\n}\n\ntemplate<> std::optional<bool> ExecutorBase<bool, operation::BLS_BatchVerify>::callModule(std::shared_ptr<Module> module, operation::BLS_BatchVerify& op) const {\n    return module->OpBLS_BatchVerify(op);\n}\n\n\ntemplate class ExecutorBase<bool, operation::BLS_BatchVerify>;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_Aggregate_G1 code for executor.cpp"}, {"role": "assistant", "content": "/* Specialization for operation::BLS_Aggregate_G1 */template<> void ExecutorBase<component::G1, operation::BLS_Aggregate_G1>::postprocess(std::shared_ptr<Module> module, operation::BLS_Aggregate_G1& op, const ExecutorBase<component::G1, operation::BLS_Aggregate_G1>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n    (void)result;\n}\n\ntemplate<> std::optional<component::G1> ExecutorBase<component::G1, operation::BLS_Aggregate_G1>::callModule(std::shared_ptr<Module> module, operation::BLS_Aggregate_G1& op) const {\n    return module->OpBLS_Aggregate_G1(op);\n}\n\n\ntemplate class ExecutorBase<component::G1, operation::BLS_Aggregate_G1>;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_Aggregate_G2 code for executor.cpp"}, {"role": "assistant", "content": "/* Specialization for operation::BLS_Aggregate_G2 */template<> void ExecutorBase<component::G2, operation::BLS_Aggregate_G2>::postprocess(std::shared_ptr<Module> module, operation::BLS_Aggregate_G2& op, const ExecutorBase<component::G2, operation::BLS_Aggregate_G2>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n    (void)result;\n}\n\ntemplate<> std::optional<component::G2> ExecutorBase<component::G2, operation::BLS_Aggregate_G2>::callModule(std::shared_ptr<Module> module, operation::BLS_Aggregate_G2& op) const {\n    return module->OpBLS_Aggregate_G2(op);\n}\n\n\ntemplate class ExecutorBase<component::G2, operation::BLS_Aggregate_G2>;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_Pairing code for executor.cpp"}, {"role": "assistant", "content": "/* Specialization for operation::BLS_Pairing */template<> void ExecutorBase<component::Fp12, operation::BLS_Pairing>::postprocess(std::shared_ptr<Module> module, operation::BLS_Pairing& op, const ExecutorBase<component::Fp12, operation::BLS_Pairing>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n\n    if ( result.second != std::nullopt  ) {\n        Pool_Fp12.Set({\n                result.second->bn1.ToTrimmedString(),\n                result.second->bn2.ToTrimmedString(),\n                result.second->bn3.ToTrimmedString(),\n                result.second->bn4.ToTrimmedString(),\n                result.second->bn5.ToTrimmedString(),\n                result.second->bn6.ToTrimmedString(),\n                result.second->bn7.ToTrimmedString(),\n                result.second->bn8.ToTrimmedString(),\n                result.second->bn9.ToTrimmedString(),\n                result.second->bn10.ToTrimmedString(),\n                result.second->bn11.ToTrimmedString(),\n                result.second->bn12.ToTrimmedString()\n        });\n    }\n}\n\ntemplate<> std::optional<component::Fp12> ExecutorBase<component::Fp12, operation::BLS_Pairing>::callModule(std::shared_ptr<Module> module, operation::BLS_Pairing& op) const {\n    return module->OpBLS_Pairing(op);\n}\n\n\ntemplate class ExecutorBase<component::Fp12, operation::BLS_Pairing>;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_MillerLoop code for executor.cpp"}, {"role": "assistant", "content": "/* Specialization for operation::BLS_MillerLoop */template<> void ExecutorBase<component::Fp12, operation::BLS_MillerLoop>::postprocess(std::shared_ptr<Module> module, operation::BLS_MillerLoop& op, const ExecutorBase<component::Fp12, operation::BLS_MillerLoop>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n\n    if ( result.second != std::nullopt  ) {\n        Pool_Fp12.Set({\n                result.second->bn1.ToTrimmedString(),\n                result.second->bn2.ToTrimmedString(),\n                result.second->bn3.ToTrimmedString(),\n                result.second->bn4.ToTrimmedString(),\n                result.second->bn5.ToTrimmedString(),\n                result.second->bn6.ToTrimmedString(),\n                result.second->bn7.ToTrimmedString(),\n                result.second->bn8.ToTrimmedString(),\n                result.second->bn9.ToTrimmedString(),\n                result.second->bn10.ToTrimmedString(),\n                result.second->bn11.ToTrimmedString(),\n                result.second->bn12.ToTrimmedString()\n        });\n    }\n}\n\ntemplate<> std::optional<component::Fp12> ExecutorBase<component::Fp12, operation::BLS_MillerLoop>::callModule(std::shared_ptr<Module> module, operation::BLS_MillerLoop& op) const {\n    return module->OpBLS_MillerLoop(op);\n}\n\n\ntemplate class ExecutorBase<component::Fp12, operation::BLS_MillerLoop>;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_FinalExp code for executor.cpp"}, {"role": "assistant", "content": "/* Specialization for operation::BLS_FinalExp */template<> void ExecutorBase<component::Fp12, operation::BLS_FinalExp>::postprocess(std::shared_ptr<Module> module, operation::BLS_FinalExp& op, const ExecutorBase<component::Fp12, operation::BLS_FinalExp>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n\n    if ( result.second != std::nullopt  ) {\n        Pool_Fp12.Set({\n                result.second->bn1.ToTrimmedString(),\n                result.second->bn2.ToTrimmedString(),\n                result.second->bn3.ToTrimmedString(),\n                result.second->bn4.ToTrimmedString(),\n                result.second->bn5.ToTrimmedString(),\n                result.second->bn6.ToTrimmedString(),\n                result.second->bn7.ToTrimmedString(),\n                result.second->bn8.ToTrimmedString(),\n                result.second->bn9.ToTrimmedString(),\n                result.second->bn10.ToTrimmedString(),\n                result.second->bn11.ToTrimmedString(),\n                result.second->bn12.ToTrimmedString()\n        });\n    }\n}\n\ntemplate<> std::optional<component::Fp12> ExecutorBase<component::Fp12, operation::BLS_FinalExp>::callModule(std::shared_ptr<Module> module, operation::BLS_FinalExp& op) const {\n    RETURN_IF_DISABLED(options.curves, op.curveType.Get());\n    return module->OpBLS_FinalExp(op);\n}\n\n\ntemplate class ExecutorBase<component::Fp12, operation::BLS_FinalExp>;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_HashToG1 code for executor.cpp"}, {"role": "assistant", "content": "/* Specialization for operation::BLS_HashToG1 */template<> void ExecutorBase<component::G1, operation::BLS_HashToG1>::postprocess(std::shared_ptr<Module> module, operation::BLS_HashToG1& op, const ExecutorBase<component::G1, operation::BLS_HashToG1>::ResultPair& result) const {\n    (void)module;\n\n    if ( result.second != std::nullopt  ) {\n        const auto curveID = op.curveType.Get();\n        const auto g1_x = result.second->first.ToTrimmedString();\n        const auto g1_y = result.second->second.ToTrimmedString();\n\n        G1AddToPool(curveID, g1_x, g1_y);\n\n        if ( g1_x.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(g1_x); }\n        if ( g1_y.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(g1_y); }\n    }\n}\n\ntemplate<> std::optional<component::G1> ExecutorBase<component::G1, operation::BLS_HashToG1>::callModule(std::shared_ptr<Module> module, operation::BLS_HashToG1& op) const {\n    RETURN_IF_DISABLED(options.curves, op.curveType.Get());\n    return module->OpBLS_HashToG1(op);\n}\n\n\ntemplate class ExecutorBase<component::G1, operation::BLS_HashToG1>;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_MapToG1 code for executor.cpp"}, {"role": "assistant", "content": "/* Specialization for operation::BLS_MapToG1 */template<> void ExecutorBase<component::G1, operation::BLS_MapToG1>::postprocess(std::shared_ptr<Module> module, operation::BLS_MapToG1& op, const ExecutorBase<component::G1, operation::BLS_MapToG1>::ResultPair& result) const {\n    (void)module;\n\n    if ( result.second != std::nullopt  ) {\n        const auto curveID = op.curveType.Get();\n        const auto g1_x = result.second->first.ToTrimmedString();\n        const auto g1_y = result.second->second.ToTrimmedString();\n\n        G1AddToPool(curveID, g1_x, g1_y);\n\n        if ( g1_x.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(g1_x); }\n        if ( g1_y.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(g1_y); }\n    }\n}\n\ntemplate<> std::optional<component::G1> ExecutorBase<component::G1, operation::BLS_MapToG1>::callModule(std::shared_ptr<Module> module, operation::BLS_MapToG1& op) const {\n    return module->OpBLS_MapToG1(op);\n}\n\n\ntemplate class ExecutorBase<component::G1, operation::BLS_MapToG1>;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_MapToG2 code for executor.cpp"}, {"role": "assistant", "content": "/* Specialization for operation::BLS_MapToG2 */template<> void ExecutorBase<component::G2, operation::BLS_MapToG2>::postprocess(std::shared_ptr<Module> module, operation::BLS_MapToG2& op, const ExecutorBase<component::G2, operation::BLS_MapToG2>::ResultPair& result) const {\n    (void)module;\n\n    if ( result.second != std::nullopt  ) {\n        const auto curveID = op.curveType.Get();\n        const auto g2_v = result.second->first.first.ToTrimmedString();\n        const auto g2_w = result.second->first.second.ToTrimmedString();\n        const auto g2_x = result.second->second.first.ToTrimmedString();\n        const auto g2_y = result.second->second.second.ToTrimmedString();\n\n        G2AddToPool(curveID, g2_v, g2_w, g2_x, g2_y);\n\n        if ( g2_v.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(g2_v); }\n        if ( g2_w.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(g2_w); }\n        if ( g2_x.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(g2_x); }\n        if ( g2_y.size() <= config::kMaxBignumSize ) { Pool_Bignum.Set(g2_y); }\n    }\n}\n\ntemplate<> std::optional<component::G2> ExecutorBase<component::G2, operation::BLS_MapToG2>::callModule(std::shared_ptr<Module> module, operation::BLS_MapToG2& op) const {\n    return module->OpBLS_MapToG2(op);\n}\n\n\ntemplate class ExecutorBase<component::G2, operation::BLS_MapToG2>;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_IsG1OnCurve code for executor.cpp"}, {"role": "assistant", "content": "/* Specialization for operation::BLS_IsG1OnCurve */template<> void ExecutorBase<bool, operation::BLS_IsG1OnCurve>::postprocess(std::shared_ptr<Module> module, operation::BLS_IsG1OnCurve& op, const ExecutorBase<bool, operation::BLS_IsG1OnCurve>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n    (void)result;\n}\n\ntemplate<> std::optional<bool> ExecutorBase<bool, operation::BLS_IsG1OnCurve>::callModule(std::shared_ptr<Module> module, operation::BLS_IsG1OnCurve& op) const {\n    RETURN_IF_DISABLED(options.curves, op.curveType.Get());\n    if ( op.g1.first.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.g1.second.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n\n    return module->OpBLS_IsG1OnCurve(op);\n}\n\n\ntemplate class ExecutorBase<bool, operation::BLS_IsG1OnCurve>;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_IsG2OnCurve code for executor.cpp"}, {"role": "assistant", "content": "/* Specialization for operation::BLS_IsG2OnCurve */template<> void ExecutorBase<bool, operation::BLS_IsG2OnCurve>::postprocess(std::shared_ptr<Module> module, operation::BLS_IsG2OnCurve& op, const ExecutorBase<bool, operation::BLS_IsG2OnCurve>::ResultPair& result) const {\n    (void)module;\n    (void)op;\n    (void)result;\n}\n\ntemplate<> std::optional<bool> ExecutorBase<bool, operation::BLS_IsG2OnCurve>::callModule(std::shared_ptr<Module> module, operation::BLS_IsG2OnCurve& op) const {\n    if ( op.g2.first.first.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.g2.first.second.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.g2.second.first.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n    if ( op.g2.second.second.GetSize() > config::kMaxBignumSize ) return std::nullopt;\n\n    return module->OpBLS_IsG2OnCurve(op);\n}\n\n\ntemplate class ExecutorBase<bool, operation::BLS_IsG2OnCurve>;"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate Digest code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorDigest executorDigest(CF_OPERATION(\"Digest\"), modules, options);\n            case CF_OPERATION(\"Digest\"):                executorDigest.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate HMAC code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorHMAC executorHMAC(CF_OPERATION(\"HMAC\"), modules, options);\n            case CF_OPERATION(\"HMAC\"):                executorHMAC.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate UMAC code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorUMAC executorUMAC(CF_OPERATION(\"UMAC\"), modules, options);\n            case CF_OPERATION(\"UMAC\"):                executorUMAC.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate CMAC code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorCMAC executorCMAC(CF_OPERATION(\"CMAC\"), modules, options);\n            case CF_OPERATION(\"CMAC\"):                executorCMAC.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate SymmetricEncrypt code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorSymmetricEncrypt executorSymmetricEncrypt(CF_OPERATION(\"SymmetricEncrypt\"), modules, options);\n            case CF_OPERATION(\"SymmetricEncrypt\"):                executorSymmetricEncrypt.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate SymmetricDecrypt code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorSymmetricDecrypt executorSymmetricDecrypt(CF_OPERATION(\"SymmetricDecrypt\"), modules, options);\n            case CF_OPERATION(\"SymmetricDecrypt\"):                executorSymmetricDecrypt.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_SCRYPT code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorKDF_SCRYPT executorKDF_SCRYPT(CF_OPERATION(\"KDF_SCRYPT\"), modules, options);\n            case CF_OPERATION(\"KDF_SCRYPT\"):                executorKDF_SCRYPT.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_HKDF code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorKDF_HKDF executorKDF_HKDF(CF_OPERATION(\"KDF_HKDF\"), modules, options);\n            case CF_OPERATION(\"KDF_HKDF\"):                executorKDF_HKDF.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_TLS1_PRF code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorKDF_TLS1_PRF executorKDF_TLS1_PRF(CF_OPERATION(\"KDF_TLS1_PRF\"), modules, options);\n            case CF_OPERATION(\"KDF_TLS1_PRF\"):                executorKDF_TLS1_PRF.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_PBKDF code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorKDF_PBKDF executorKDF_PBKDF(CF_OPERATION(\"KDF_PBKDF\"), modules, options);\n            case CF_OPERATION(\"KDF_PBKDF\"):                executorKDF_PBKDF.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_PBKDF1 code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorKDF_PBKDF1 executorKDF_PBKDF1(CF_OPERATION(\"KDF_PBKDF1\"), modules, options);\n            case CF_OPERATION(\"KDF_PBKDF1\"):                executorKDF_PBKDF1.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_PBKDF2 code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorKDF_PBKDF2 executorKDF_PBKDF2(CF_OPERATION(\"KDF_PBKDF2\"), modules, options);\n            case CF_OPERATION(\"KDF_PBKDF2\"):                executorKDF_PBKDF2.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_ARGON2 code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorKDF_ARGON2 executorKDF_ARGON2(CF_OPERATION(\"KDF_ARGON2\"), modules, options);\n            case CF_OPERATION(\"KDF_ARGON2\"):                executorKDF_ARGON2.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_SSH code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorKDF_SSH executorKDF_SSH(ID(\"KDF_SSH\"), modules, options);\n            case CF_OPERATION(\"KDF_SSH\"):                executorKDF_SSH.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_X963 code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorKDF_X963 executorKDF_X963(CF_OPERATION(\"KDF_X963\"), modules, options);\n            case CF_OPERATION(\"KDF_X963\"):                executorKDF_X963.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_BCRYPT code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorKDF_BCRYPT executorKDF_BCRYPT(CF_OPERATION(\"KDF_BCRYPT\"), modules, options);\n            case CF_OPERATION(\"KDF_BCRYPT\"):                executorKDF_BCRYPT.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_SP_800_108 code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorKDF_SP_800_108 executorKDF_SP_800_108(CF_OPERATION(\"KDF_SP_800_108\"), modules, options);\n            case CF_OPERATION(\"KDF_SP_800_108\"):                executorKDF_SP_800_108.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_SRTP code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorKDF_SRTP executorKDF_SRTP(CF_OPERATION(\"KDF_SRTP\"), modules, options);\n            case CF_OPERATION(\"KDF_SRTP\"):                executorKDF_SRTP.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_SRTCP code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorKDF_SRTCP executorKDF_SRTCP(CF_OPERATION(\"KDF_SRTCP\"), modules, options);\n            case CF_OPERATION(\"KDF_SRTCP\"):                executorKDF_SRTCP.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_PrivateToPublic code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorECC_PrivateToPublic executorECC_PrivateToPublic(CF_OPERATION(\"ECC_PrivateToPublic\"), modules, options);\n            case CF_OPERATION(\"ECC_PrivateToPublic\"):                executorECC_PrivateToPublic.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_ValidatePubkey code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorECC_ValidatePubkey executorECC_ValidatePubkey(CF_OPERATION(\"ECC_ValidatePubkey\"), modules, options);\n            case CF_OPERATION(\"ECC_ValidatePubkey\"):                executorECC_ValidatePubkey.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_GenerateKeyPair code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorECC_GenerateKeyPair executorECC_GenerateKeyPair(CF_OPERATION(\"ECC_GenerateKeyPair\"), modules, options);\n            case CF_OPERATION(\"ECC_GenerateKeyPair\"):                executorECC_GenerateKeyPair.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECCSI_Sign code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorECCSI_Sign executorECCSI_Sign(CF_OPERATION(\"ECCSI_Sign\"), modules, options);\n            case CF_OPERATION(\"ECCSI_Sign\"):                executorECCSI_Sign.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECDSA_Sign code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorECDSA_Sign executorECDSA_Sign(CF_OPERATION(\"ECDSA_Sign\"), modules, options);\n            case CF_OPERATION(\"ECDSA_Sign\"):                executorECDSA_Sign.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECGDSA_Sign code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorECGDSA_Sign executorECGDSA_Sign(CF_OPERATION(\"ECGDSA_Sign\"), modules, options);\n            case CF_OPERATION(\"ECGDSA_Sign\"):                executorECGDSA_Sign.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECRDSA_Sign code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorECRDSA_Sign executorECRDSA_Sign(CF_OPERATION(\"ECRDSA_Sign\"), modules, options);\n            case CF_OPERATION(\"ECRDSA_Sign\"):                executorECRDSA_Sign.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate Schnorr_Sign code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorSchnorr_Sign executorSchnorr_Sign(CF_OPERATION(\"Schnorr_Sign\"), modules, options);\n            case CF_OPERATION(\"Schnorr_Sign\"):                executorSchnorr_Sign.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECCSI_Verify code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorECCSI_Verify executorECCSI_Verify(CF_OPERATION(\"ECCSI_Verify\"), modules, options);\n            case CF_OPERATION(\"ECCSI_Verify\"):                executorECCSI_Verify.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECDSA_Verify code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorECDSA_Verify executorECDSA_Verify(CF_OPERATION(\"ECDSA_Verify\"), modules, options);\n            case CF_OPERATION(\"ECDSA_Verify\"):                executorECDSA_Verify.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECGDSA_Verify code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorECGDSA_Verify executorECGDSA_Verify(CF_OPERATION(\"ECGDSA_Verify\"), modules, options);\n            case CF_OPERATION(\"ECGDSA_Verify\"):                executorECGDSA_Verify.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECRDSA_Verify code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorECRDSA_Verify executorECRDSA_Verify(CF_OPERATION(\"ECRDSA_Verify\"), modules, options);\n            case CF_OPERATION(\"ECRDSA_Verify\"):                executorECRDSA_Verify.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate Schnorr_Verify code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorSchnorr_Verify executorSchnorr_Verify(CF_OPERATION(\"Schnorr_Verify\"), modules, options);\n            case CF_OPERATION(\"Schnorr_Verify\"):                executorSchnorr_Verify.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECDSA_Recover code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorECDSA_Recover executorECDSA_Recover(CF_OPERATION(\"ECDSA_Recover\"), modules, options);\n            case CF_OPERATION(\"ECDSA_Recover\"):                executorECDSA_Recover.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate DSA_Verify code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorDSA_Verify executorDSA_Verify(CF_OPERATION(\"DSA_Verify\"), modules, options);\n            case CF_OPERATION(\"DSA_Verify\"):                executorDSA_Verify.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate DSA_Sign code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorDSA_Sign executorDSA_Sign(CF_OPERATION(\"DSA_Sign\"), modules, options);\n            case CF_OPERATION(\"DSA_Sign\"):                executorDSA_Sign.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate DSA_GenerateParameters code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorDSA_GenerateParameters executorDSA_GenerateParameters(CF_OPERATION(\"DSA_GenerateParameters\"), modules, options);\n            case CF_OPERATION(\"DSA_GenerateParameters\"):                executorDSA_GenerateParameters.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate DSA_PrivateToPublic code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorDSA_PrivateToPublic executorDSA_PrivateToPublic(CF_OPERATION(\"DSA_PrivateToPublic\"), modules, options);\n            case CF_OPERATION(\"DSA_PrivateToPublic\"):                executorDSA_PrivateToPublic.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate DSA_GenerateKeyPair code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorDSA_GenerateKeyPair executorDSA_GenerateKeyPair(CF_OPERATION(\"DSA_GenerateKeyPair\"), modules, options);\n            case CF_OPERATION(\"DSA_GenerateKeyPair\"):                executorDSA_GenerateKeyPair.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECDH_Derive code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorECDH_Derive executorECDH_Derive(CF_OPERATION(\"ECDH_Derive\"), modules, options);\n            case CF_OPERATION(\"ECDH_Derive\"):                executorECDH_Derive.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECIES_Encrypt code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorECIES_Encrypt executorECIES_Encrypt(CF_OPERATION(\"ECIES_Encrypt\"), modules, options);\n            case CF_OPERATION(\"ECIES_Encrypt\"):                executorECIES_Encrypt.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECIES_Decrypt code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorECIES_Decrypt executorECIES_Decrypt(CF_OPERATION(\"ECIES_Decrypt\"), modules, options);\n            case CF_OPERATION(\"ECIES_Decrypt\"):                executorECIES_Decrypt.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_Point_Add code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorECC_Point_Add executorECC_Point_Add(CF_OPERATION(\"ECC_Point_Add\"), modules, options);\n            case CF_OPERATION(\"ECC_Point_Add\"):                executorECC_Point_Add.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_Point_Sub code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorECC_Point_Sub executorECC_Point_Sub(CF_OPERATION(\"ECC_Point_Sub\"), modules, options);\n            case CF_OPERATION(\"ECC_Point_Sub\"):                executorECC_Point_Sub.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_Point_Mul code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorECC_Point_Mul executorECC_Point_Mul(CF_OPERATION(\"ECC_Point_Mul\"), modules, options);\n            case CF_OPERATION(\"ECC_Point_Mul\"):                executorECC_Point_Mul.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_Point_Neg code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorECC_Point_Neg executorECC_Point_Neg(CF_OPERATION(\"ECC_Point_Neg\"), modules, options);\n            case CF_OPERATION(\"ECC_Point_Neg\"):                executorECC_Point_Neg.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_Point_Dbl code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorECC_Point_Dbl executorECC_Point_Dbl(CF_OPERATION(\"ECC_Point_Dbl\"), modules, options);\n            case CF_OPERATION(\"ECC_Point_Dbl\"):                executorECC_Point_Dbl.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_Point_Cmp code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorECC_Point_Cmp executorECC_Point_Cmp(CF_OPERATION(\"ECC_Point_Cmp\"), modules, options);\n            case CF_OPERATION(\"ECC_Point_Cmp\"):                executorECC_Point_Cmp.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate DH_GenerateKeyPair code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorDH_GenerateKeyPair executorDH_GenerateKeyPair(CF_OPERATION(\"DH_GenerateKeyPair\"), modules, options);\n            case CF_OPERATION(\"DH_GenerateKeyPair\"):                executorDH_GenerateKeyPair.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate DH_Derive code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorDH_Derive executorDH_Derive(CF_OPERATION(\"DH_Derive\"), modules, options);\n            case CF_OPERATION(\"DH_Derive\"):                executorDH_Derive.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorBignumCalc executorBignumCalc(CF_OPERATION(\"BignumCalc\"), modules, options);\n            case CF_OPERATION(\"BignumCalc\"):                executorBignumCalc.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Fp2 code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorBignumCalc_Fp2 executorBignumCalc_Fp2(CF_OPERATION(\"BignumCalc_Fp2\"), modules, options);\n            case CF_OPERATION(\"BignumCalc_Fp2\"):                executorBignumCalc_Fp2.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Fp12 code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorBignumCalc_Fp12 executorBignumCalc_Fp12(CF_OPERATION(\"BignumCalc_Fp12\"), modules, options);\n            case CF_OPERATION(\"BignumCalc_Fp12\"):                executorBignumCalc_Fp12.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_BLS12_381_R code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorBignumCalc_Mod_BLS12_381_R executorBignumCalc_mod_bls12_381_r(CF_OPERATION(\"BignumCalc_Mod_BLS12_381_R\"), modules, options);\n            case CF_OPERATION(\"BignumCalc_Mod_BLS12_381_R\"):                executorBignumCalc_mod_bls12_381_r.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_BLS12_381_P code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorBignumCalc_Mod_BLS12_381_P executorBignumCalc_mod_bls12_381_p(CF_OPERATION(\"BignumCalc_Mod_BLS12_381_P\"), modules, options);\n            case CF_OPERATION(\"BignumCalc_Mod_BLS12_381_P\"):                executorBignumCalc_mod_bls12_381_p.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_BLS12_377_R code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorBignumCalc_Mod_BLS12_377_R executorBignumCalc_mod_bls12_377_r(CF_OPERATION(\"BignumCalc_Mod_BLS12_377_R\"), modules, options);\n            case CF_OPERATION(\"BignumCalc_Mod_BLS12_377_R\"):                executorBignumCalc_mod_bls12_377_r.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_BLS12_377_P code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorBignumCalc_Mod_BLS12_377_P executorBignumCalc_mod_bls12_377_p(CF_OPERATION(\"BignumCalc_Mod_BLS12_377_P\"), modules, options);\n            case CF_OPERATION(\"BignumCalc_Mod_BLS12_377_P\"):                executorBignumCalc_mod_bls12_377_p.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_BN128_R code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorBignumCalc_Mod_BN128_R executorBignumCalc_mod_bn128_r(CF_OPERATION(\"BignumCalc_Mod_BN128_R\"), modules, options);\n            case CF_OPERATION(\"BignumCalc_Mod_BN128_R\"):                executorBignumCalc_mod_bn128_r.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_BN128_P code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorBignumCalc_Mod_BN128_P executorBignumCalc_mod_bn128_p(CF_OPERATION(\"BignumCalc_Mod_BN128_P\"), modules, options);\n            case CF_OPERATION(\"BignumCalc_Mod_BN128_P\"):                executorBignumCalc_mod_bn128_p.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_Vesta_R code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorBignumCalc_Mod_Vesta_R executorBignumCalc_mod_vesta_r(CF_OPERATION(\"BignumCalc_Mod_Vesta_R\"), modules, options);\n            case CF_OPERATION(\"BignumCalc_Mod_Vesta_R\"):                executorBignumCalc_mod_vesta_r.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_Vesta_P code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorBignumCalc_Mod_Vesta_P executorBignumCalc_mod_vesta_p(CF_OPERATION(\"BignumCalc_Mod_Vesta_P\"), modules, options);\n            case CF_OPERATION(\"BignumCalc_Mod_Vesta_P\"):                executorBignumCalc_mod_vesta_p.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_ED25519 code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorBignumCalc_Mod_ED25519 executorBignumCalc_mod_ed25519(CF_OPERATION(\"BignumCalc_Mod_ED25519\"), modules, options);\n            case CF_OPERATION(\"BignumCalc_Mod_ED25519\"):                executorBignumCalc_mod_ed25519.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_Edwards_R code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorBignumCalc_Mod_Edwards_R executorBignumCalc_mod_edwards_r(CF_OPERATION(\"BignumCalc_Mod_Edwards_R\"), modules, options);\n            case CF_OPERATION(\"BignumCalc_Mod_Edwards_R\"):                executorBignumCalc_mod_edwards_r.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_Edwards_P code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorBignumCalc_Mod_Edwards_P executorBignumCalc_mod_edwards_p(CF_OPERATION(\"BignumCalc_Mod_Edwards_P\"), modules, options);\n            case CF_OPERATION(\"BignumCalc_Mod_Edwards_P\"):                executorBignumCalc_mod_edwards_p.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_Goldilocks code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorBignumCalc_Mod_Goldilocks executorBignumCalc_mod_goldilocks(CF_OPERATION(\"BignumCalc_Mod_Goldilocks\"), modules, options);\n            case CF_OPERATION(\"BignumCalc_Mod_Goldilocks\"):                executorBignumCalc_mod_goldilocks.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_MNT4_R code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorBignumCalc_Mod_MNT4_R executorBignumCalc_mod_mnt4_r(CF_OPERATION(\"BignumCalc_Mod_MNT4_R\"), modules, options);\n            case CF_OPERATION(\"BignumCalc_Mod_MNT4_R\"):                executorBignumCalc_mod_mnt4_r.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_MNT4_P code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorBignumCalc_Mod_MNT4_P executorBignumCalc_mod_mnt4_p(CF_OPERATION(\"BignumCalc_Mod_MNT4_P\"), modules, options);\n            case CF_OPERATION(\"BignumCalc_Mod_MNT4_P\"):                executorBignumCalc_mod_mnt4_p.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_MNT6_R code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorBignumCalc_Mod_MNT6_R executorBignumCalc_mod_mnt6_r(CF_OPERATION(\"BignumCalc_Mod_MNT6_R\"), modules, options);\n            case CF_OPERATION(\"BignumCalc_Mod_MNT6_R\"):                executorBignumCalc_mod_mnt6_r.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_MNT6_P code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorBignumCalc_Mod_MNT6_P executorBignumCalc_mod_mnt6_p(CF_OPERATION(\"BignumCalc_Mod_MNT6_P\"), modules, options);\n            case CF_OPERATION(\"BignumCalc_Mod_MNT6_P\"):                executorBignumCalc_mod_mnt6_p.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_2Exp64 code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorBignumCalc_Mod_2Exp64 executorBignumCalc_mod_2exp64(CF_OPERATION(\"BignumCalc_Mod_2Exp64\"), modules, options);\n            case CF_OPERATION(\"BignumCalc_Mod_2Exp64\"):                executorBignumCalc_mod_2exp64.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_2Exp128 code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorBignumCalc_Mod_2Exp128 executorBignumCalc_mod_2exp128(CF_OPERATION(\"BignumCalc_Mod_2Exp128\"), modules, options);\n            case CF_OPERATION(\"BignumCalc_Mod_2Exp128\"):                executorBignumCalc_mod_2exp128.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_2Exp256 code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorBignumCalc_Mod_2Exp256 executorBignumCalc_mod_2exp256(CF_OPERATION(\"BignumCalc_Mod_2Exp256\"), modules, options);\n            case CF_OPERATION(\"BignumCalc_Mod_2Exp256\"):                executorBignumCalc_mod_2exp256.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_2Exp512 code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorBignumCalc_Mod_2Exp512 executorBignumCalc_mod_2exp512(CF_OPERATION(\"BignumCalc_Mod_2Exp512\"), modules, options);\n            case CF_OPERATION(\"BignumCalc_Mod_2Exp512\"):                executorBignumCalc_mod_2exp512.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_SECP256K1 code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorBignumCalc_Mod_SECP256K1 executorBignumCalc_mod_secp256k1(CF_OPERATION(\"BignumCalc_Mod_SECP256K1\"), modules, options);\n            case CF_OPERATION(\"BignumCalc_Mod_SECP256K1\"):                executorBignumCalc_mod_secp256k1.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_SECP256K1_P code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorBignumCalc_Mod_SECP256K1_P executorBignumCalc_mod_secp256k1_p(CF_OPERATION(\"BignumCalc_Mod_SECP256K1_P\"), modules, options);\n            case CF_OPERATION(\"BignumCalc_Mod_SECP256K1_P\"):                executorBignumCalc_mod_secp256k1_p.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_PrivateToPublic code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorBLS_PrivateToPublic executorBLS_PrivateToPublic(CF_OPERATION(\"BLS_PrivateToPublic\"), modules, options);\n            case CF_OPERATION(\"BLS_PrivateToPublic\"):                executorBLS_PrivateToPublic.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_PrivateToPublic_G2 code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorBLS_PrivateToPublic_G2 executorBLS_PrivateToPublic_G2(CF_OPERATION(\"BLS_PrivateToPublic_G2\"), modules, options);\n            case CF_OPERATION(\"BLS_PrivateToPublic_G2\"):                executorBLS_PrivateToPublic_G2.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_Sign code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorBLS_Sign executorBLS_Sign(CF_OPERATION(\"BLS_Sign\"), modules, options);\n            case CF_OPERATION(\"BLS_Sign\"):                executorBLS_Sign.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_Verify code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorBLS_Verify executorBLS_Verify(CF_OPERATION(\"BLS_Verify\"), modules, options);\n            case CF_OPERATION(\"BLS_Verify\"):                executorBLS_Verify.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_BatchSign code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorBLS_BatchSign executorBLS_BatchSign(CF_OPERATION(\"BLS_BatchSign\"), modules, options);\n            case CF_OPERATION(\"BLS_BatchSign\"):                executorBLS_BatchSign.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_BatchVerify code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorBLS_BatchVerify executorBLS_BatchVerify(CF_OPERATION(\"BLS_BatchVerify\"), modules, options);\n            case CF_OPERATION(\"BLS_BatchVerify\"):                executorBLS_BatchVerify.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_Aggregate_G1 code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorBLS_Aggregate_G1 executorBLS_Aggregate_G1(CF_OPERATION(\"BLS_Aggregate_G1\"), modules, options);\n            case CF_OPERATION(\"BLS_Aggregate_G1\"):                executorBLS_Aggregate_G1.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_Aggregate_G2 code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorBLS_Aggregate_G2 executorBLS_Aggregate_G2(CF_OPERATION(\"BLS_Aggregate_G2\"), modules, options);\n            case CF_OPERATION(\"BLS_Aggregate_G2\"):                executorBLS_Aggregate_G2.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_Pairing code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorBLS_Pairing executorBLS_Pairing(CF_OPERATION(\"BLS_Pairing\"), modules, options);\n            case CF_OPERATION(\"BLS_Pairing\"):                executorBLS_Pairing.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_MillerLoop code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorBLS_MillerLoop executorBLS_MillerLoop(CF_OPERATION(\"BLS_MillerLoop\"), modules, options);\n            case CF_OPERATION(\"BLS_MillerLoop\"):                executorBLS_MillerLoop.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_FinalExp code for driver.cpp"}, {"role": "assistant", "content": "    static ExecutorBLS_FinalExp executorBLS_FinalExp(CF_OPERATION(\"BLS_FinalExp\"), modules, options);\n            case CF_OPERATION(\"BLS_FinalExp\"):                executorBLS_FinalExp.Run(ds, payload.data(), payload.size());\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate Digest code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"Digest\"):                {\n                    parameters[\"modifier\"] = \"\";\n                    parameters[\"cleartext\"] = getBuffer(PRNG64() % maxSize);\n                    parameters[\"digestType\"] = getRandomDigest();\n\n                    cryptofuzz::operation::Digest op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate HMAC code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"HMAC\"):                {\n                    size_t numParts = 0;\n\n                    numParts++; /* modifier */\n                    numParts++; /* cleartext */\n                    numParts++; /* iv */\n                    numParts++; /* key */\n\n                    const auto lengths = SplitLength(maxSize - 64, numParts);\n\n                    parameters[\"modifier\"] = getBuffer(lengths[0]);\n                    parameters[\"cleartext\"] = getBuffer(lengths[1]);\n                    parameters[\"cipher\"][\"iv\"] = getBuffer(lengths[2], true);\n                    parameters[\"cipher\"][\"key\"] = getBuffer(lengths[3], true);\n                    parameters[\"cipher\"][\"cipherType\"] = getRandomCipher();\n                    parameters[\"digestType\"] = getRandomDigest();\n\n                    cryptofuzz::operation::HMAC op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate UMAC code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"UMAC\"):                {\n                    parameters[\"modifier\"] = \"\";\n                    parameters[\"cleartext\"] = getBuffer(PRNG64() % maxSize);\n                    parameters[\"key\"] = getBuffer(16);\n                    parameters[\"iv\"] = getBuffer(PRNG() % 17);\n                    parameters[\"type\"] = PRNG() % 4;\n                    parameters[\"outSize\"] = PRNG() % 1024;\n\n                    cryptofuzz::operation::UMAC op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate CMAC code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"CMAC\"):                {\n                    size_t numParts = 0;\n\n                    numParts++; /* modifier */\n                    numParts++; /* cleartext */\n                    numParts++; /* iv */\n                    numParts++; /* key */\n\n                    const auto lengths = SplitLength(maxSize - 64, numParts);\n\n                    parameters[\"modifier\"] = getBuffer(lengths[0]);\n                    parameters[\"cleartext\"] = getBuffer(lengths[1]);\n                    parameters[\"cipher\"][\"iv\"] = getBuffer(lengths[2], true);\n                    parameters[\"cipher\"][\"key\"] = getBuffer(lengths[3], true);\n                    parameters[\"cipher\"][\"cipherType\"] = getRandomCipher();\n\n                    cryptofuzz::operation::CMAC op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate SymmetricEncrypt code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"SymmetricEncrypt\"):                {\n                    const bool aad_enabled = PRNG() % 2;\n                    const bool tagSize_enabled = PRNG() % 2;\n                    size_t numParts = 0;\n\n                    numParts++; /* modifier */\n                    numParts++; /* cleartext */\n                    numParts++; /* iv */\n                    numParts++; /* key */\n\n                    if ( aad_enabled ) {\n                        numParts++; /* aad */\n                    }\n\n                    auto lengths = SplitLength(maxSize - 64, numParts);\n\n                    parameters[\"modifier\"] = getBuffer(lengths[0]);\n                    if ( getBool() ) {\n                        if ( 16 < lengths[1] ) {\n                            lengths[1] = 16;\n                        }\n                    }\n                    parameters[\"cleartext\"] = getBuffer(lengths[1]);\n\n                    parameters[\"cipher\"][\"iv\"] = getBuffer(lengths[2], true);\n                    parameters[\"cipher\"][\"key\"] = getBuffer(lengths[3], true);\n\n                    if ( aad_enabled ) {\n                        parameters[\"aad_enabled\"] = true;\n                        if ( getBool() ) {\n                            lengths[4] = 0;\n                        }\n                        parameters[\"aad\"] = getBuffer(lengths[4]);\n                    } else {\n                        parameters[\"aad_enabled\"] = false;\n                    }\n\n                    if ( tagSize_enabled ) {\n                        parameters[\"tagSize_enabled\"] = true;\n                        if ( getBool() ) {\n                            parameters[\"tagSize\"] = getDefaultSize();\n                        } else {\n                            parameters[\"tagSize\"] = PRNG() % 102400;\n                        }\n                    } else {\n                        parameters[\"tagSize_enabled\"] = false;\n                    }\n\n                    parameters[\"cipher\"][\"cipherType\"] = getRandomCipher();\n                    parameters[\"ciphertextSize\"] = PRNG() % (lengths[1] + 9);\n\n                    cryptofuzz::operation::SymmetricEncrypt op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate SymmetricDecrypt code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"SymmetricDecrypt\"):                {\n                    const bool aad_enabled = PRNG() % 2;\n                    const bool tag_enabled = PRNG() % 2;\n                    size_t numParts = 0;\n\n                    numParts++; /* modifier */\n                    numParts++; /* cleartext */\n                    numParts++; /* iv */\n                    numParts++; /* key */\n\n                    if ( aad_enabled ) {\n                        numParts++; /* aad */\n                    }\n                    if ( tag_enabled ) {\n                        numParts++; /* tag */\n                    }\n\n                    auto lengths = SplitLength(maxSize - 64, numParts);\n\n                    parameters[\"modifier\"] = getBuffer(lengths[0]);\n                    if ( getBool() ) {\n                        if ( 16 < lengths[1] ) {\n                            lengths[1] = 16;\n                        }\n                    }\n                    parameters[\"ciphertext\"] = getBuffer(lengths[1]);\n\n                    parameters[\"cipher\"][\"iv\"] = getBuffer(lengths[2], true);\n                    parameters[\"cipher\"][\"key\"] = getBuffer(lengths[3], true);\n\n                    if ( aad_enabled ) {\n                        parameters[\"aad_enabled\"] = true;\n                        if ( getBool() ) {\n                            lengths[4] = 0;\n                        }\n                        parameters[\"aad\"] = getBuffer(lengths[4]);\n                    } else {\n                        parameters[\"aad_enabled\"] = false;\n                    }\n\n                    if ( tag_enabled ) {\n                        parameters[\"tag_enabled\"] = true;\n                        parameters[\"tag\"] = getBuffer(lengths[aad_enabled ? 5 : 4], true);\n                    } else {\n                        parameters[\"tag_enabled\"] = false;\n                    }\n\n                    parameters[\"cipher\"][\"cipherType\"] = getRandomCipher();\n                    parameters[\"cleartextSize\"] = PRNG() % (lengths[1] + 9);\n\n                    cryptofuzz::operation::SymmetricDecrypt op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"BignumCalc\"):"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_BLS12_381_R code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"BignumCalc_Mod_BLS12_381_R\"):"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_BLS12_381_P code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"BignumCalc_Mod_BLS12_381_P\"):"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_BN128_R code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"BignumCalc_Mod_BN128_R\"):"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_BN128_P code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"BignumCalc_Mod_BN128_P\"):"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_Vesta_R code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"BignumCalc_Mod_Vesta_R\"):"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_Vesta_P code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"BignumCalc_Mod_Vesta_P\"):"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_ED25519 code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"BignumCalc_Mod_ED25519\"):"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_Edwards_R code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"BignumCalc_Mod_Edwards_R\"):"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_Edwards_P code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"BignumCalc_Mod_Edwards_P\"):"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_Goldilocks code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"BignumCalc_Mod_Goldilocks\"):"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_MNT4_R code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"BignumCalc_Mod_MNT4_R\"):"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_MNT4_P code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"BignumCalc_Mod_MNT4_P\"):"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_MNT6_R code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"BignumCalc_Mod_MNT6_R\"):"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_MNT6_P code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"BignumCalc_Mod_MNT6_P\"):"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_2Exp64 code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"BignumCalc_Mod_2Exp64\"):"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_2Exp128 code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"BignumCalc_Mod_2Exp128\"):"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_2Exp256 code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"BignumCalc_Mod_2Exp256\"):"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_2Exp512 code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"BignumCalc_Mod_2Exp512\"):"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_SECP256K1 code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"BignumCalc_Mod_SECP256K1\"):"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_SECP256K1_P code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"BignumCalc_Mod_SECP256K1_P\"):"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_BLS12_377_R code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"BignumCalc_Mod_BLS12_377_R\"):"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Mod_BLS12_377_P code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"BignumCalc_Mod_BLS12_377_P\"):                {\n                    parameters[\"modifier\"] = \"\";\n\n                    const auto calcop = getRandomCalcOp();\n                    parameters[\"calcOp\"] = calcop;\n\n                    auto bn1 = getBignum();\n                    const auto bn2 = getBignum();\n                    const auto bn3 = getBignum();\n\n                    if ( calcop == CF_CALCOP(\"InvMod(A,B)\") || calcop == CF_CALCOP(\"ExpMod(A,B,C)\") ) {\n                        std::optional<std::string> mod = get_op_mod(operation);\n\n                        if ( mod == std::nullopt ) {\n                            if ( calcop == CF_CALCOP(\"InvMod(A,B)\") ) {\n                                mod = bn2;\n                            } else if ( CF_CALCOP(\"ExpMod(A,B,C)\") ) {\n                                mod = bn3;\n                            } else {\n                                abort();\n                            }\n                        }\n\n                        const auto mont = from_mont(mutateBinary(getBignum()), *mod);\n                        Pool_Bignum.Set(mont);\n\n                        if ( getBool() ) {\n                            bn1 = mont;\n                        }\n                    }\n\n                    parameters[\"bn1\"] = bn1;\n                    parameters[\"bn2\"] = bn2;\n                    parameters[\"bn3\"] = bn3;\n                    parameters[\"bn4\"] = \"\";\n\n                    if ( calcop == CF_CALCOP(\"ExpMod(A,B,C)\") && operation == CF_OPERATION(\"BignumCalc\") ) {\n                        if ( PRNG() % 100 == 0 ) {\n                            const auto p = cryptofuzz::mutator::ExpModGenerator::generate_exp_mod(getBignum(true));\n\n                            if ( p != std::nullopt ) {\n                                parameters = *p;\n                            }\n                        }\n                    }\n#if defined(CRYPTOFUZZ_HAVE_Z3)\n                    else if ( (PRNG() % 1000) == 0 ) {\n                        const auto p = cryptofuzz::Z3::Generate(calcop);\n                        if ( p != std::nullopt ) {\n                            parameters = *p;\n                        }\n                    }\n#endif\n                    cryptofuzz::operation::BignumCalc op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Fp2 code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"BignumCalc_Fp2\"):                {\n                    parameters[\"modifier\"] = getBuffer(PRNG() % 1000);\n                    parameters[\"calcOp\"] = getRandomCalcOp();\n                    parameters[\"bn1\"][0] = getBignum();\n                    parameters[\"bn1\"][1] = getBignum();\n                    parameters[\"bn2\"][0] = getBignum();\n                    parameters[\"bn2\"][1] = getBignum();\n                    parameters[\"bn3\"][0] = \"\";\n                    parameters[\"bn3\"][1] = \"\";\n                    parameters[\"bn4\"][0] = \"\";\n                    parameters[\"bn4\"][1] = \"\";\n\n                    cryptofuzz::operation::BignumCalc_Fp2 op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BignumCalc_Fp12 code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"BignumCalc_Fp12\"):                {\n                    parameters[\"modifier\"] = getBuffer(PRNG() % 1000);\n                    parameters[\"calcOp\"] = getRandomCalcOp();\n\n                    if ( Pool_Fp12.Have() && getBool() == true ) {\n                        const auto Fp12 = Pool_Fp12.Get();\n#if 0\n                        parameters[\"bn1\"][0] = GET_OR_BIGNUM(Fp12.bn1);\n                        parameters[\"bn1\"][1] = GET_OR_BIGNUM(Fp12.bn2);\n                        parameters[\"bn1\"][2] = GET_OR_BIGNUM(Fp12.bn3);\n                        parameters[\"bn1\"][3] = GET_OR_BIGNUM(Fp12.bn4);\n                        parameters[\"bn1\"][4] = GET_OR_BIGNUM(Fp12.bn5);\n                        parameters[\"bn1\"][5] = GET_OR_BIGNUM(Fp12.bn6);\n                        parameters[\"bn1\"][6] = GET_OR_BIGNUM(Fp12.bn7);\n                        parameters[\"bn1\"][7] = GET_OR_BIGNUM(Fp12.bn8);\n                        parameters[\"bn1\"][8] = GET_OR_BIGNUM(Fp12.bn9);\n                        parameters[\"bn1\"][9] = GET_OR_BIGNUM(Fp12.bn10);\n                        parameters[\"bn1\"][10] = GET_OR_BIGNUM(Fp12.bn11);\n                        parameters[\"bn1\"][11] = GET_OR_BIGNUM(Fp12.bn12);\n#endif\n                        parameters[\"bn1\"][0] = Fp12.bn1;\n                        parameters[\"bn1\"][1] = Fp12.bn2;\n                        parameters[\"bn1\"][2] = Fp12.bn3;\n                        parameters[\"bn1\"][3] = Fp12.bn4;\n                        parameters[\"bn1\"][4] = Fp12.bn5;\n                        parameters[\"bn1\"][5] = Fp12.bn6;\n                        parameters[\"bn1\"][6] = Fp12.bn7;\n                        parameters[\"bn1\"][7] = Fp12.bn8;\n                        parameters[\"bn1\"][8] = Fp12.bn9;\n                        parameters[\"bn1\"][9] = Fp12.bn10;\n                        parameters[\"bn1\"][10] = Fp12.bn11;\n                        parameters[\"bn1\"][11] = Fp12.bn12;\n                    } else {\n                        parameters[\"bn1\"][0] = getBignum();\n                        parameters[\"bn1\"][1] = getBignum();\n                        parameters[\"bn1\"][2] = getBignum();\n                        parameters[\"bn1\"][3] = getBignum();\n                        parameters[\"bn1\"][4] = getBignum();\n                        parameters[\"bn1\"][5] = getBignum();\n                        parameters[\"bn1\"][6] = getBignum();\n                        parameters[\"bn1\"][7] = getBignum();\n                        parameters[\"bn1\"][8] = getBignum();\n                        parameters[\"bn1\"][9] = getBignum();\n                        parameters[\"bn1\"][10] = getBignum();\n                        parameters[\"bn1\"][11] = getBignum();\n\n                        parameters[\"bn2\"][0] = getBignum();\n                        parameters[\"bn2\"][1] = getBignum();\n                        parameters[\"bn2\"][2] = getBignum();\n                        parameters[\"bn2\"][3] = getBignum();\n                        parameters[\"bn2\"][4] = getBignum();\n                        parameters[\"bn2\"][5] = getBignum();\n                        parameters[\"bn2\"][6] = getBignum();\n                        parameters[\"bn2\"][7] = getBignum();\n                        parameters[\"bn2\"][8] = getBignum();\n                        parameters[\"bn2\"][9] = getBignum();\n                        parameters[\"bn2\"][10] = getBignum();\n                        parameters[\"bn2\"][11] = getBignum();\n                    }\n\n                    if ( Pool_Fp12.Have() && getBool() == true ) {\n                        const auto Fp12 = Pool_Fp12.Get();\n#if 0\n                        parameters[\"bn2\"][0] = GET_OR_BIGNUM(Fp12.bn1);\n                        parameters[\"bn2\"][1] = GET_OR_BIGNUM(Fp12.bn2);\n                        parameters[\"bn2\"][2] = GET_OR_BIGNUM(Fp12.bn3);\n                        parameters[\"bn2\"][3] = GET_OR_BIGNUM(Fp12.bn4);\n                        parameters[\"bn2\"][4] = GET_OR_BIGNUM(Fp12.bn5);\n                        parameters[\"bn2\"][5] = GET_OR_BIGNUM(Fp12.bn6);\n                        parameters[\"bn2\"][6] = GET_OR_BIGNUM(Fp12.bn7);\n                        parameters[\"bn2\"][7] = GET_OR_BIGNUM(Fp12.bn8);\n                        parameters[\"bn2\"][8] = GET_OR_BIGNUM(Fp12.bn9);\n                        parameters[\"bn2\"][9] = GET_OR_BIGNUM(Fp12.bn10);\n                        parameters[\"bn2\"][10] = GET_OR_BIGNUM(Fp12.bn11);\n                        parameters[\"bn2\"][11] = GET_OR_BIGNUM(Fp12.bn12);\n#endif\n                        parameters[\"bn2\"][0] = Fp12.bn1;\n                        parameters[\"bn2\"][1] = Fp12.bn2;\n                        parameters[\"bn2\"][2] = Fp12.bn3;\n                        parameters[\"bn2\"][3] = Fp12.bn4;\n                        parameters[\"bn2\"][4] = Fp12.bn5;\n                        parameters[\"bn2\"][5] = Fp12.bn6;\n                        parameters[\"bn2\"][6] = Fp12.bn7;\n                        parameters[\"bn2\"][7] = Fp12.bn8;\n                        parameters[\"bn2\"][8] = Fp12.bn9;\n                        parameters[\"bn2\"][9] = Fp12.bn10;\n                        parameters[\"bn2\"][10] = Fp12.bn11;\n                        parameters[\"bn2\"][11] = Fp12.bn12;\n                    } else {\n                        parameters[\"bn2\"][0] = getBignum();\n                        parameters[\"bn2\"][1] = getBignum();\n                        parameters[\"bn2\"][2] = getBignum();\n                        parameters[\"bn2\"][3] = getBignum();\n                        parameters[\"bn2\"][4] = getBignum();\n                        parameters[\"bn2\"][5] = getBignum();\n                        parameters[\"bn2\"][6] = getBignum();\n                        parameters[\"bn2\"][7] = getBignum();\n                        parameters[\"bn2\"][8] = getBignum();\n                        parameters[\"bn2\"][9] = getBignum();\n                        parameters[\"bn2\"][10] = getBignum();\n                        parameters[\"bn2\"][11] = getBignum();\n                    }\n\n                    parameters[\"bn3\"][0] = \"\";\n                    parameters[\"bn3\"][1] = \"\";\n                    parameters[\"bn3\"][2] = \"\";\n                    parameters[\"bn3\"][3] = \"\";\n                    parameters[\"bn3\"][4] = \"\";\n                    parameters[\"bn3\"][5] = \"\";\n                    parameters[\"bn3\"][6] = \"\";\n                    parameters[\"bn3\"][7] = \"\";\n                    parameters[\"bn3\"][8] = \"\";\n                    parameters[\"bn3\"][9] = \"\";\n                    parameters[\"bn3\"][10] = \"\";\n                    parameters[\"bn3\"][11] = \"\";\n\n                    parameters[\"bn4\"][0] = \"\";\n                    parameters[\"bn4\"][1] = \"\";\n                    parameters[\"bn4\"][2] = \"\";\n                    parameters[\"bn4\"][3] = \"\";\n                    parameters[\"bn4\"][4] = \"\";\n                    parameters[\"bn4\"][5] = \"\";\n                    parameters[\"bn4\"][6] = \"\";\n                    parameters[\"bn4\"][7] = \"\";\n                    parameters[\"bn4\"][8] = \"\";\n                    parameters[\"bn4\"][9] = \"\";\n                    parameters[\"bn4\"][10] = \"\";\n                    parameters[\"bn4\"][11] = \"\";\n                    cryptofuzz::operation::BignumCalc_Fp12 op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_PrivateToPublic code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"ECC_PrivateToPublic\"):                {\n                    parameters[\"modifier\"] = getBuffer(PRNG() % 1000);\n\n                    if ( Pool_CurvePrivkey.Have() && getBool() == true ) {\n                        const auto P1 = Pool_CurvePrivkey.Get();\n\n                        parameters[\"curveType\"] = hint_ecc_mont(P1.curveID);\n                        parameters[\"priv\"] = P1.priv;\n                    } else {\n                        const auto curveID = getRandomCurve();\n                        parameters[\"curveType\"] = hint_ecc_mont(curveID);\n\n                        if ( getBool() ) {\n                            const auto order = cryptofuzz::repository::ECC_CurveToOrder(curveID);\n                            if ( order != std::nullopt ) {\n                                const auto o = boost::multiprecision::cpp_int(*order);\n                                parameters[\"priv\"] = boost::lexical_cast<std::string>(o-1);\n                            } else {\n                                parameters[\"priv\"] = getBignum();\n                            }\n                        } else {\n                            parameters[\"priv\"] = getBignum();\n                        }\n\n                    }\n\n                    cryptofuzz::operation::ECC_PrivateToPublic op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_ValidatePubkey code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"ECC_ValidatePubkey\"):                {\n                    parameters[\"modifier\"] = getBuffer(PRNG() % 1000);\n\n                    if ( getBool() && Pool_CurveKeypair.Have() ) {\n                        const auto P = Pool_CurveKeypair.Get();\n\n                        parameters[\"curveType\"] = hint_ecc_mont(P.curveID);\n\n                        parameters[\"pub_x\"] = getBool() ? getBignum() : P.pub_x;\n                        parameters[\"pub_y\"] = getBool() ? getBignum() : P.pub_y;\n                    } else if ( getBool() && Pool_CurveECC_Point.Have() == true ) {\n                        const auto P = Pool_CurveECC_Point.Get();\n                        parameters[\"curveType\"] = hint_ecc_mont(P.curveID);\n\n                        parameters[\"pub_x\"] = getBool() ? getBignum() : P.x;\n                        parameters[\"pub_y\"] = getBool() ? getBignum() : P.y;\n                    } else {\n                        parameters[\"curveType\"] = hint_ecc_mont(getRandomCurve());\n                        parameters[\"pub_x\"] = getBignum();\n                        parameters[\"pub_y\"] = getBignum();\n                    }\n\n                    cryptofuzz::operation::ECC_ValidatePubkey op(parameters);\n                    op.Serialize(dsOut2);\n\n                    generateECCPoint();\n                }\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate DSA_GenerateParameters code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"DSA_GenerateParameters\"):                {\n                    parameters[\"modifier\"] = getBuffer(PRNG() % 1000);\n                    cryptofuzz::operation::DSA_GenerateParameters op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate DSA_PrivateToPublic code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"DSA_PrivateToPublic\"):                {\n                    parameters[\"modifier\"] = \"\";\n\n                    if ( Pool_DSA_PQG.Have() && getBool() == true ) {\n                        const auto PQG = Pool_DSA_PQG.Get();\n                        parameters[\"p\"] = PQG.p;\n                        parameters[\"g\"] = PQG.g;\n                    } else {\n                        parameters[\"p\"] = getBignum();\n                        parameters[\"g\"] = getBignum();\n                    }\n\n                    parameters[\"priv\"] = getBignum();\n\n                    cryptofuzz::operation::DSA_PrivateToPublic op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate DSA_GenerateKeyPair code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"DSA_GenerateKeyPair\"):                {\n                    parameters[\"modifier\"] = getBuffer(PRNG() % 1000);\n\n                    if ( Pool_DSA_PQG.Have() && getBool() == true ) {\n                        const auto PQG = Pool_DSA_PQG.Get();\n                        parameters[\"p\"] = PQG.p;\n                        parameters[\"q\"] = PQG.q;\n                        parameters[\"g\"] = PQG.g;\n                    } else {\n                        parameters[\"p\"] = getBignum();\n                        parameters[\"q\"] = getBignum();\n                        parameters[\"g\"] = getBignum();\n                    }\n\n                    cryptofuzz::operation::DSA_GenerateKeyPair op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate DSA_Verify code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"DSA_Verify\"):                {\n                    parameters[\"modifier\"] = getBuffer(PRNG() % 1000);\n\n                    if ( Pool_DSASignature.Have() && getBool() == true ) {\n                        const auto sig = Pool_DSASignature.Get();\n\n                        nlohmann::json parameters_;\n                        parameters_[\"p\"] = sig.p;\n                        parameters_[\"q\"] = sig.q;\n                        parameters_[\"g\"] = sig.g;\n\n                        parameters[\"parameters\"] = parameters_;\n\n                        parameters[\"signature\"][0] = getBool() ? getBignum() : sig.r;\n                        parameters[\"signature\"][1] = getBool() ? getBignum() : sig.s;\n                        parameters[\"pub\"] = sig.pub;\n                        parameters[\"cleartext\"] = sig.cleartext;\n                    } else {\n                        nlohmann::json parameters_;\n                        parameters_[\"p\"] = getBignum();\n                        parameters_[\"q\"] = getBignum();\n                        parameters_[\"g\"] = getBignum();\n\n                        parameters[\"parameters\"] = parameters_;\n\n                        parameters[\"signature\"][0] = getBignum();\n                        parameters[\"signature\"][1] = getBignum();\n                        parameters[\"pub\"] = getBignum();\n                        parameters[\"cleartext\"] = getBuffer(PRNG() % 8);\n                    }\n\n\n                    cryptofuzz::operation::DSA_Verify op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate DSA_Sign code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"DSA_Sign\"):                {\n                    parameters[\"modifier\"] = getBuffer(PRNG() % 1000);\n\n                    if ( Pool_DSA_PQG.Have() && getBool() == true ) {\n                        const auto PQG = Pool_DSA_PQG.Get();\n\n                        nlohmann::json parameters_;\n                        parameters_[\"p\"] = PQG.p;\n                        parameters_[\"q\"] = PQG.q;\n                        parameters_[\"g\"] = PQG.g;\n\n                        parameters[\"parameters\"] = parameters_;\n                    } else {\n                        nlohmann::json parameters_;\n                        parameters_[\"p\"] = getBignum();\n                        parameters_[\"q\"] = getBignum();\n                        parameters_[\"g\"] = getBignum();\n\n                        parameters[\"parameters\"] = parameters_;\n                    }\n\n                    parameters[\"priv\"] = getBignum();\n\n                    parameters[\"cleartext\"] = getBuffer(PRNG() % 8);\n\n                    cryptofuzz::operation::DSA_Sign op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECDH_Derive code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"ECDH_Derive\"):                {\n                    parameters[\"modifier\"] = getBuffer(PRNG() % 1000);\n\n                    if ( Pool_CurvePrivkey.Have() && getBool() == true ) {\n                        const auto P1 = Pool_CurveKeypair.Get();\n                        const auto P2 = Pool_CurveKeypair.Get();\n\n                        CF_CHECK_EQ(P1.curveID, P2.curveID);\n\n                        parameters[\"curveType\"] = hint_ecc_mont(P1.curveID);\n\n                        parameters[\"priv\"] = P1.privkey;\n\n                        parameters[\"pub_x\"] = P1.pub_x;\n                        parameters[\"pub_y\"] = P1.pub_y;\n                    } else {\n                        parameters[\"curveType\"] = hint_ecc_mont(getRandomCurve());\n\n                        parameters[\"priv\"] = getBignum();\n\n                        parameters[\"pub_x\"] = getBignum();\n                        parameters[\"pub_y\"] = getBignum();\n                    }\n\n                    cryptofuzz::operation::ECDH_Derive op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECCSI_Sign code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"ECCSI_Sign\"):                {\n                    parameters[\"modifier\"] = getBuffer(PRNG() % 1000);\n\n                    const auto P1 = Pool_CurvePrivkey.Get();\n\n                    parameters[\"curveType\"] = hint_ecc_mont(P1.curveID);\n                    parameters[\"priv\"] = P1.priv;\n\n                    if ( getBool() ) {\n                        parameters[\"cleartext\"] = cryptofuzz::util::DecToHex(getBignum(true), (PRNG() % 64) * 2);\n                    } else {\n                        parameters[\"cleartext\"] = getBuffer(PRNG() % 32);\n                    }\n                    parameters[\"digestType\"] = getRandomDigest();\n                    parameters[\"id\"] = getBuffer(PRNG() % 1024);\n\n                    cryptofuzz::operation::ECCSI_Sign op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECDSA_Sign code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"ECDSA_Sign\"):                {\n                    parameters[\"modifier\"] = getBuffer(PRNG() % 1000);\n\n\t\t            // Was broken: empty string is not valid priv key (copy-paste from getPublicKey)\n                    if ( Pool_CurvePrivkey.Have() && getBool() == true ) {\n                        const auto P1 = Pool_CurvePrivkey.Get();\n\n                        parameters[\"curveType\"] = hint_ecc_mont(P1.curveID);\n                        parameters[\"priv\"] = P1.priv;\n                    } else {\n                        const auto curveID = getRandomCurve();\n                        parameters[\"curveType\"] = hint_ecc_mont(curveID);\n\n                        if ( getBool() ) {\n                            const auto order = cryptofuzz::repository::ECC_CurveToOrder(curveID);\n                            if ( order != std::nullopt ) {\n                                const auto o = boost::multiprecision::cpp_int(*order);\n                                parameters[\"priv\"] = boost::lexical_cast<std::string>(o-1);\n                            } else {\n                                parameters[\"priv\"] = getBignum();\n                            }\n                        } else {\n                            parameters[\"priv\"] = getBignum();\n                        }\n\n                    }\n                    parameters[\"nonce\"] = getBignum();\n\n                    if ( getBool() ) {\n                        parameters[\"cleartext\"] = cryptofuzz::util::DecToHex(getBignum(true), (PRNG() % 64) * 2);\n                    } else {\n                        parameters[\"cleartext\"] = getBuffer(PRNG() % 32);\n                    }\n\n                    parameters[\"nonceSource\"] = PRNG() % 3;\n                    parameters[\"digestType\"] = getRandomDigest();\n\n                    cryptofuzz::operation::ECDSA_Sign op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECGDSA_Sign code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"ECGDSA_Sign\"):                {\n                    parameters[\"modifier\"] = getBuffer(PRNG() % 1000);\n\n                    const auto P1 = Pool_CurvePrivkey.Get();\n\n                    parameters[\"curveType\"] = hint_ecc_mont(P1.curveID);\n                    parameters[\"priv\"] = P1.priv;\n                    parameters[\"nonce\"] = getBignum();\n\n                    if ( getBool() ) {\n                        parameters[\"cleartext\"] = cryptofuzz::util::DecToHex(getBignum(true), (PRNG() % 64) * 2);\n                    } else {\n                        parameters[\"cleartext\"] = getBuffer(PRNG() % 32);\n                    }\n                    parameters[\"nonceSource\"] = PRNG() % 3;\n                    parameters[\"digestType\"] = getRandomDigest();\n\n                    cryptofuzz::operation::ECGDSA_Sign op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECRDSA_Sign code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"ECRDSA_Sign\"):                {\n                    parameters[\"modifier\"] = getBuffer(PRNG() % 1000);\n\n                    const auto P1 = Pool_CurvePrivkey.Get();\n\n                    parameters[\"curveType\"] = hint_ecc_mont(P1.curveID);\n                    parameters[\"priv\"] = P1.priv;\n                    parameters[\"nonce\"] = getBignum();\n\n                    if ( getBool() ) {\n                        parameters[\"cleartext\"] = cryptofuzz::util::DecToHex(getBignum(true), (PRNG() % 64) * 2);\n                    } else {\n                        parameters[\"cleartext\"] = getBuffer(PRNG() % 32);\n                    }\n                    parameters[\"nonceSource\"] = PRNG() % 3;\n                    parameters[\"digestType\"] = getRandomDigest();\n\n                    cryptofuzz::operation::ECRDSA_Sign op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate Schnorr_Sign code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"Schnorr_Sign\"):                {\n                    parameters[\"modifier\"] = getBuffer(PRNG() % 1000);\n\n                    const auto P1 = Pool_CurvePrivkey.Get();\n\n                    parameters[\"curveType\"] = hint_ecc_mont(P1.curveID);\n                    parameters[\"priv\"] = P1.priv;\n                    parameters[\"nonce\"] = getBignum();\n\n                    if ( getBool() ) {\n                        parameters[\"cleartext\"] = cryptofuzz::util::DecToHex(getBignum(true), (PRNG() % 64) * 2);\n                    } else {\n                        parameters[\"cleartext\"] = getBuffer(PRNG() % 32);\n                    }\n                    parameters[\"nonceSource\"] = PRNG() % 3;\n                    parameters[\"digestType\"] = getRandomDigest();\n\n                    cryptofuzz::operation::Schnorr_Sign op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECCSI_Verify code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"ECCSI_Verify\"):                {\n                    parameters[\"modifier\"] = getBuffer(PRNG() % 1024);\n\n                    if ( Pool_CurveECCSISignature.Have() == true ) {\n                        const auto P = Pool_CurveECCSISignature.Get();\n#if 0\n                        parameters[\"curveType\"] = hint_ecc_mont(P.curveID);\n\n                        parameters[\"signature\"][\"pub\"][0] = getBool() ? getBignum() : P.pub_x;\n                        parameters[\"signature\"][\"pub\"][1] = getBool() ? getBignum() : P.pub_y;\n\n                        parameters[\"signature\"][\"pvt\"][0] = getBool() ? getBignum() : P.pvt_x;\n                        parameters[\"signature\"][\"pvt\"][1] = getBool() ? getBignum() : P.pvt_y;\n\n                        parameters[\"signature\"][\"signature\"][0] = getBool() ? getBignum() : P.sig_r;\n                        parameters[\"signature\"][\"signature\"][1] = getBool() ? getBignum() : P.sig_s;\n\n                        parameters[\"cleartext\"] = P.cleartext;\n                        parameters[\"id\"] = P.id;\n#endif\n                        parameters[\"curveType\"] = hint_ecc_mont(P.curveID);\n\n                        parameters[\"signature\"][\"pub\"][0] = P.pub_x;\n                        parameters[\"signature\"][\"pub\"][1] = P.pub_y;\n\n                        parameters[\"signature\"][\"pvt\"][0] = P.pvt_x;\n                        parameters[\"signature\"][\"pvt\"][1] = P.pvt_y;\n\n                        parameters[\"signature\"][\"signature\"][0] = P.sig_r;\n                        parameters[\"signature\"][\"signature\"][1] = P.sig_s;\n\n                        parameters[\"cleartext\"] = P.cleartext;\n                        parameters[\"id\"] = P.id;\n                    } else {\n                        parameters[\"curveType\"] = hint_ecc_mont(getRandomCurve());\n\n                        parameters[\"signature\"][\"pub\"][0] = getBignum();\n                        parameters[\"signature\"][\"pub\"][1] = getBignum();\n\n                        parameters[\"signature\"][\"pvt\"][0] = getBignum();\n                        parameters[\"signature\"][\"pvt\"][1] = getBignum();\n\n                        parameters[\"signature\"][\"signature\"][0] = getBignum();\n                        parameters[\"signature\"][\"signature\"][1] = getBignum();\n\n                        parameters[\"cleartext\"] = cryptofuzz::util::DecToHex(getBignum(true), (PRNG() % 64) * 2);\n                        parameters[\"id\"] = cryptofuzz::util::DecToHex(getBignum(true), (PRNG() % 64) * 2);\n                    }\n\n                    parameters[\"digestType\"] = getRandomDigest();\n\n                    cryptofuzz::operation::ECCSI_Verify op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECDSA_Verify code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"ECDSA_Verify\"):                {\n                    parameters[\"modifier\"] = getBuffer(PRNG() % 1024);\n\n                    if ( Pool_CurveECDSASignature.Have() == true ) {\n                        const auto P = Pool_CurveECDSASignature.Get();\n                        parameters[\"curveType\"] = hint_ecc_mont(P.curveID);\n\n                        parameters[\"signature\"][\"pub\"][0] = getBool() ? getBignum() : P.pub_x;\n                        parameters[\"signature\"][\"pub\"][1] = getBool() ? getBignum() : P.pub_y;\n\n                        parameters[\"signature\"][\"signature\"][0] = getBool() ? getBignum() : P.sig_r;\n                        auto sigS = getBool() ? getBignum() : P.sig_y;\n\n                        if ( getBool() ) {\n                            /* Test ECDSA signature malleability */\n\n                            const auto order = cryptofuzz::repository::ECC_CurveToOrder(P.curveID);\n                            if ( order != std::nullopt ) {\n                                const auto o = boost::multiprecision::cpp_int(*order);\n                                const auto s = boost::multiprecision::cpp_int(sigS);\n                                if ( o > s ) {\n                                    sigS = boost::lexical_cast<std::string>(o - s);\n                                }\n                            }\n                        }\n\n                        parameters[\"signature\"][\"signature\"][1] = sigS;\n                        parameters[\"cleartext\"] = P.cleartext;\n                    } else {\n                        parameters[\"curveType\"] = hint_ecc_mont(getRandomCurve());\n\n                        parameters[\"signature\"][\"pub\"][0] = getBignum();\n                        parameters[\"signature\"][\"pub\"][1] = getBignum();\n\n                        parameters[\"signature\"][\"signature\"][0] = getBignum();\n                        parameters[\"signature\"][\"signature\"][1] = getBignum();\n\n                        parameters[\"cleartext\"] = cryptofuzz::util::DecToHex(getBignum(true), (PRNG() % 64) * 2);\n                    }\n\n                    parameters[\"digestType\"] = getRandomDigest();\n\n                    cryptofuzz::operation::ECDSA_Verify op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECGDSA_Verify code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"ECGDSA_Verify\"):                {\n                    parameters[\"modifier\"] = getBuffer(PRNG() % 1024);\n\n                    if ( Pool_CurveECDSASignature.Have() == true ) {\n                        const auto P = Pool_CurveECDSASignature.Get();\n                        parameters[\"curveType\"] = hint_ecc_mont(P.curveID);\n\n                        parameters[\"signature\"][\"pub\"][0] = getBool() ? getBignum() : P.pub_x;\n                        parameters[\"signature\"][\"pub\"][1] = getBool() ? getBignum() : P.pub_y;\n\n                        parameters[\"signature\"][\"signature\"][0] = getBool() ? getBignum() : P.sig_r;\n                        auto sigS = getBool() ? getBignum() : P.sig_y;\n\n                        if ( getBool() ) {\n                            /* Test ECGDSA signature malleability */\n\n                            const auto order = cryptofuzz::repository::ECC_CurveToOrder(P.curveID);\n                            if ( order != std::nullopt ) {\n                                const auto o = boost::multiprecision::cpp_int(*order);\n                                const auto s = boost::multiprecision::cpp_int(sigS);\n                                if ( o > s ) {\n                                    sigS = boost::lexical_cast<std::string>(o - s);\n                                }\n                            }\n                        }\n\n                        parameters[\"signature\"][\"signature\"][1] = sigS;\n                        parameters[\"cleartext\"] = P.cleartext;\n                    } else {\n                        parameters[\"curveType\"] = hint_ecc_mont(getRandomCurve());\n\n                        parameters[\"signature\"][\"pub\"][0] = getBignum();\n                        parameters[\"signature\"][\"pub\"][1] = getBignum();\n\n                        parameters[\"signature\"][\"signature\"][0] = getBignum();\n                        parameters[\"signature\"][\"signature\"][1] = getBignum();\n\n                        parameters[\"cleartext\"] = cryptofuzz::util::DecToHex(getBignum(true), (PRNG() % 64) * 2);\n                    }\n\n                    parameters[\"digestType\"] = getRandomDigest();\n\n                    cryptofuzz::operation::ECGDSA_Verify op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECRDSA_Verify code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"ECRDSA_Verify\"):                {\n                    parameters[\"modifier\"] = getBuffer(PRNG() % 1024);\n\n                    if ( Pool_CurveECDSASignature.Have() == true ) {\n                        const auto P = Pool_CurveECDSASignature.Get();\n                        parameters[\"curveType\"] = hint_ecc_mont(P.curveID);\n\n                        parameters[\"signature\"][\"pub\"][0] = getBool() ? getBignum() : P.pub_x;\n                        parameters[\"signature\"][\"pub\"][1] = getBool() ? getBignum() : P.pub_y;\n\n                        parameters[\"signature\"][\"signature\"][0] = getBool() ? getBignum() : P.sig_r;\n                        auto sigS = getBool() ? getBignum() : P.sig_y;\n\n                        if ( getBool() ) {\n                            /* Test ECRDSA signature malleability */\n\n                            const auto order = cryptofuzz::repository::ECC_CurveToOrder(P.curveID);\n                            if ( order != std::nullopt ) {\n                                const auto o = boost::multiprecision::cpp_int(*order);\n                                const auto s = boost::multiprecision::cpp_int(sigS);\n                                if ( o > s ) {\n                                    sigS = boost::lexical_cast<std::string>(o - s);\n                                }\n                            }\n                        }\n\n                        parameters[\"signature\"][\"signature\"][1] = sigS;\n                        parameters[\"cleartext\"] = P.cleartext;\n                    } else {\n                        parameters[\"curveType\"] = hint_ecc_mont(getRandomCurve());\n\n                        parameters[\"signature\"][\"pub\"][0] = getBignum();\n                        parameters[\"signature\"][\"pub\"][1] = getBignum();\n\n                        parameters[\"signature\"][\"signature\"][0] = getBignum();\n                        parameters[\"signature\"][\"signature\"][1] = getBignum();\n\n                        parameters[\"cleartext\"] = cryptofuzz::util::DecToHex(getBignum(true), (PRNG() % 64) * 2);\n                    }\n\n                    parameters[\"digestType\"] = getRandomDigest();\n\n                    cryptofuzz::operation::ECRDSA_Verify op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate Schnorr_Verify code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"Schnorr_Verify\"):                {\n                    parameters[\"modifier\"] = getBuffer(PRNG() % 1024);\n\n                    if ( Pool_CurveECDSASignature.Have() == true ) {\n                        const auto P = Pool_CurveECDSASignature.Get();\n                        parameters[\"curveType\"] = hint_ecc_mont(P.curveID);\n\n                        parameters[\"signature\"][\"pub\"][0] = getBool() ? getBignum() : P.pub_x;\n                        parameters[\"signature\"][\"pub\"][1] = getBool() ? getBignum() : P.pub_y;\n\n                        parameters[\"signature\"][\"signature\"][0] = getBool() ? getBignum() : P.sig_r;\n                        auto sigS = getBool() ? getBignum() : P.sig_y;\n\n                        if ( getBool() ) {\n                            /* Test Schnorr signature malleability */\n\n                            const auto order = cryptofuzz::repository::ECC_CurveToOrder(P.curveID);\n                            if ( order != std::nullopt ) {\n                                const auto o = boost::multiprecision::cpp_int(*order);\n                                const auto s = boost::multiprecision::cpp_int(sigS);\n                                if ( o > s ) {\n                                    sigS = boost::lexical_cast<std::string>(o - s);\n                                }\n                            }\n                        }\n\n                        parameters[\"signature\"][\"signature\"][1] = sigS;\n                        parameters[\"cleartext\"] = P.cleartext;\n                    } else {\n                        parameters[\"curveType\"] = hint_ecc_mont(getRandomCurve());\n\n                        parameters[\"signature\"][\"pub\"][0] = getBignum();\n                        parameters[\"signature\"][\"pub\"][1] = getBignum();\n\n                        parameters[\"signature\"][\"signature\"][0] = getBignum();\n                        parameters[\"signature\"][\"signature\"][1] = getBignum();\n\n                        parameters[\"cleartext\"] = cryptofuzz::util::DecToHex(getBignum(true), (PRNG() % 64) * 2);\n                    }\n\n                    parameters[\"digestType\"] = getRandomDigest();\n\n                    cryptofuzz::operation::Schnorr_Verify op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECDSA_Recover code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"ECDSA_Recover\"):                {\n                    parameters[\"modifier\"] = getBuffer(PRNG() % 1024);\n\n                    if ( getBool() && Pool_CurveECDSASignature.Have() == true ) {\n                        const auto P = Pool_CurveECDSASignature.Get();\n                        parameters[\"curveType\"] = hint_ecc_mont(P.curveID);\n\n                        parameters[\"signature\"][0] = getBool() ? getBignum() : P.sig_r;\n                        parameters[\"signature\"][1] = getBool() ? getBignum() : P.sig_y;\n\n                        if ( getBool() ) {\n                            parameters[\"cleartext\"] = P.cleartext;\n                        } else {\n                            parameters[\"cleartext\"] = cryptofuzz::util::DecToHex(getBignum(true), (PRNG() % 64) * 2);\n                        }\n                    } else if ( getBool() && Pool_CurveECC_Point.Have() == true ) {\n                        const auto P = Pool_CurveECC_Point.Get();\n                        parameters[\"curveType\"] = hint_ecc_mont(P.curveID);\n\n                        parameters[\"signature\"][0] = getBool() ? getBignum() : P.x;\n                        parameters[\"signature\"][1] = getBool() ? getBignum() : P.y;\n\n                        parameters[\"cleartext\"] = cryptofuzz::util::DecToHex(getBignum(true), (PRNG() % 64) * 2);\n                    } else {\n                        parameters[\"curveType\"] = hint_ecc_mont(getRandomCurve());\n\n                        parameters[\"signature\"][0] = getBignum();\n                        parameters[\"signature\"][1] = getBignum();\n\n                        parameters[\"cleartext\"] = cryptofuzz::util::DecToHex(getBignum(true), (PRNG() % 64) * 2);\n                    }\n\n                    parameters[\"id\"] = PRNG() % 4;\n                    parameters[\"digestType\"] = getRandomDigest();\n\n                    cryptofuzz::operation::ECDSA_Recover op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_GenerateKeyPair code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"ECC_GenerateKeyPair\"):                {\n                    parameters[\"modifier\"] = getBuffer(PRNG() % 128);\n                    parameters[\"curveType\"] = hint_ecc_mont(getRandomCurve());\n\n                    cryptofuzz::operation::ECC_GenerateKeyPair op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECIES_Encrypt code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"ECIES_Encrypt\"):"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECIES_Decrypt code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"ECIES_Decrypt\"):                {\n                    parameters[\"modifier\"] = getBuffer(PRNG() % 128);\n                    if ( operation == CF_OPERATION(\"ECIES_Encrypt\") ) {\n                        parameters[\"cleartext\"] = getBuffer(PRNG() % 1024);\n                    } else {\n                        parameters[\"ciphertext\"] = getBuffer(PRNG() % 1024);\n                    }\n                    //parameters[\"cipherType\"] = getRandomCipher();\n                    parameters[\"cipherType\"] = CF_CIPHER(\"AES_128_CBC\");\n                    parameters[\"iv_enabled\"] = false;\n\n                    parameters[\"priv\"] = getBignum();\n\n                    if ( Pool_CurveKeypair.Have() && getBool() == true ) {\n                        const auto P = Pool_CurveKeypair.Get();\n\n                        parameters[\"curveType\"] = hint_ecc_mont(P.curveID);\n                        parameters[\"pub_x\"] = P.pub_x;\n                        parameters[\"pub_y\"] = P.pub_y;\n\n                        if ( Pool_CurvePrivkey.Have() && getBool() == true ) {\n                            const auto P2 = Pool_CurvePrivkey.Get();\n                            if ( P2.curveID == P.curveID ) {\n                                parameters[\"priv\"] = P2.priv;\n                            }\n                        }\n                    } else {\n                        parameters[\"curveType\"] = hint_ecc_mont(getRandomCurve());\n                        parameters[\"pub_x\"] = getBignum();\n                        parameters[\"pub_y\"] = getBignum();\n                    }\n\n                    if ( operation == CF_OPERATION(\"ECIES_Encrypt\") ) {\n                        cryptofuzz::operation::ECIES_Encrypt op(parameters);\n                        op.Serialize(dsOut2);\n                    } else {\n                        cryptofuzz::operation::ECIES_Decrypt op(parameters);\n                        op.Serialize(dsOut2);\n                    }\n                }\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_Point_Add code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"ECC_Point_Add\"):                {\n                    parameters[\"modifier\"] = \"\";\n\n                    if ( Pool_CurveECC_Point.Have() == true ) {\n                        const auto P = Pool_CurveECC_Point.Get();\n                        parameters[\"curveType\"] = hint_ecc_mont(P.curveID);\n\n                        parameters[\"a_x\"] = getBool() ? getBignum() : P.x;\n                        parameters[\"a_y\"] = getBool() ? getBignum() : P.y;\n                    } else {\n                        parameters[\"curveType\"] = hint_ecc_mont(getRandomCurve());\n\n                        parameters[\"a_x\"] = getBignum();\n                        parameters[\"a_y\"] = getBignum();\n                    }\n\n                    if ( Pool_CurveECC_Point.Have() == true ) {\n                        const auto P = Pool_CurveECC_Point.Get();\n                        parameters[\"curveType\"] = hint_ecc_mont(P.curveID);\n\n                        parameters[\"b_x\"] = getBool() ? getBignum() : P.x;\n                        parameters[\"b_y\"] = getBool() ? getBignum() : P.y;\n                    } else {\n                        parameters[\"curveType\"] = hint_ecc_mont(getRandomCurve());\n\n                        parameters[\"b_x\"] = getBignum();\n                        parameters[\"b_y\"] = getBignum();\n                    }\n\n                    cryptofuzz::operation::ECC_Point_Add op(parameters);\n                    op.Serialize(dsOut2);\n\n                    generateECCPoint();\n                }\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_Point_Sub code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"ECC_Point_Sub\"):                {\n                    parameters[\"modifier\"] = \"\";\n\n                    if ( Pool_CurveECC_Point.Have() == true ) {\n                        const auto P = Pool_CurveECC_Point.Get();\n                        parameters[\"curveType\"] = hint_ecc_mont(P.curveID);\n\n                        parameters[\"a_x\"] = getBool() ? getBignum() : P.x;\n                        parameters[\"a_y\"] = getBool() ? getBignum() : P.y;\n                    } else {\n                        parameters[\"curveType\"] = hint_ecc_mont(getRandomCurve());\n\n                        parameters[\"a_x\"] = getBignum();\n                        parameters[\"a_y\"] = getBignum();\n                    }\n\n                    if ( Pool_CurveECC_Point.Have() == true ) {\n                        const auto P = Pool_CurveECC_Point.Get();\n                        parameters[\"curveType\"] = hint_ecc_mont(P.curveID);\n\n                        parameters[\"b_x\"] = getBool() ? getBignum() : P.x;\n                        parameters[\"b_y\"] = getBool() ? getBignum() : P.y;\n                    } else {\n                        parameters[\"curveType\"] = hint_ecc_mont(getRandomCurve());\n\n                        parameters[\"b_x\"] = getBignum();\n                        parameters[\"b_y\"] = getBignum();\n                    }\n\n                    cryptofuzz::operation::ECC_Point_Sub op(parameters);\n                    op.Serialize(dsOut2);\n\n                    generateECCPoint();\n                }\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_Point_Mul code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"ECC_Point_Mul\"):                {\n                    parameters[\"modifier\"] = \"\";\n\n                    if ( Pool_CurveECC_Point.Have() == true ) {\n                        const auto P = Pool_CurveECC_Point.Get();\n                        parameters[\"curveType\"] = hint_ecc_mont(P.curveID);\n\n                        parameters[\"a_x\"] = getBool() ? getBignum() : P.x;\n                        parameters[\"a_y\"] = getBool() ? getBignum() : P.y;\n                    } else {\n                        parameters[\"curveType\"] = hint_ecc_mont(getRandomCurve());\n\n                        parameters[\"a_x\"] = getBignum();\n                        parameters[\"a_y\"] = getBignum();\n                    }\n\n                    parameters[\"b\"] = getBignum();\n\n                    cryptofuzz::operation::ECC_Point_Mul op(parameters);\n                    op.Serialize(dsOut2);\n\n                    generateECCPoint();\n                }\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_Point_Neg code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"ECC_Point_Neg\"):                {\n                    parameters[\"modifier\"] = \"\";\n\n                    if ( Pool_CurveECC_Point.Have() == true ) {\n                        const auto P = Pool_CurveECC_Point.Get();\n                        parameters[\"curveType\"] = hint_ecc_mont(P.curveID);\n\n                        parameters[\"a_x\"] = getBool() ? getBignum() : P.x;\n                        parameters[\"a_y\"] = getBool() ? getBignum() : P.y;\n                    } else {\n                        parameters[\"curveType\"] = hint_ecc_mont(getRandomCurve());\n\n                        parameters[\"a_x\"] = getBignum();\n                        parameters[\"a_y\"] = getBignum();\n                    }\n\n                    cryptofuzz::operation::ECC_Point_Neg op(parameters);\n                    op.Serialize(dsOut2);\n\n                    generateECCPoint();\n                }\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_Point_Dbl code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"ECC_Point_Dbl\"):                {\n                    parameters[\"modifier\"] = \"\";\n\n                    if ( Pool_CurveECC_Point.Have() == true ) {\n                        const auto P = Pool_CurveECC_Point.Get();\n                        parameters[\"curveType\"] = hint_ecc_mont(P.curveID);\n\n                        parameters[\"a_x\"] = getBool() ? getBignum() : P.x;\n                        parameters[\"a_y\"] = getBool() ? getBignum() : P.y;\n                    } else {\n                        parameters[\"curveType\"] = hint_ecc_mont(getRandomCurve());\n\n                        parameters[\"a_x\"] = getBignum();\n                        parameters[\"a_y\"] = getBignum();\n                    }\n\n                    cryptofuzz::operation::ECC_Point_Dbl op(parameters);\n                    op.Serialize(dsOut2);\n\n                    generateECCPoint();\n                }\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate ECC_Point_Cmp code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"ECC_Point_Cmp\"):                {\n                    parameters[\"modifier\"] = \"\";\n\n                    if ( Pool_CurveECC_Point.Have() == true ) {\n                        const auto P = Pool_CurveECC_Point.Get();\n                        parameters[\"curveType\"] = hint_ecc_mont(P.curveID);\n\n                        parameters[\"a_x\"] = getBool() ? getBignum() : P.x;\n                        parameters[\"a_y\"] = getBool() ? getBignum() : P.y;\n                    } else {\n                        parameters[\"curveType\"] = hint_ecc_mont(getRandomCurve());\n\n                        parameters[\"a_x\"] = getBignum();\n                        parameters[\"a_y\"] = getBignum();\n                    }\n\n                    if ( Pool_CurveECC_Point.Have() == true ) {\n                        const auto P = Pool_CurveECC_Point.Get();\n                        parameters[\"curveType\"] = hint_ecc_mont(P.curveID);\n\n                        parameters[\"b_x\"] = getBool() ? getBignum() : P.x;\n                        parameters[\"b_y\"] = getBool() ? getBignum() : P.y;\n                    } else {\n                        parameters[\"curveType\"] = hint_ecc_mont(getRandomCurve());\n\n                        parameters[\"b_x\"] = getBignum();\n                        parameters[\"b_y\"] = getBignum();\n                    }\n\n                    cryptofuzz::operation::ECC_Point_Cmp op(parameters);\n                    op.Serialize(dsOut2);\n\n                    generateECCPoint();\n                }\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_SCRYPT code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"KDF_SCRYPT\"):                {\n                    size_t numParts = 0;\n\n                    numParts++; /* modifier */\n                    numParts++; /* password */\n                    numParts++; /* salt */\n\n                    const auto lengths = SplitLength(maxSize - 64, numParts);\n\n                    parameters[\"modifier\"] = getBuffer(lengths[0]);\n                    parameters[\"password\"] = getBuffer(lengths[1]);\n                    parameters[\"salt\"] = getBuffer(lengths[2]);\n                    parameters[\"N\"] = PRNG() % 5;\n                    parameters[\"r\"] = PRNG() % 9;\n                    parameters[\"p\"] = PRNG() % 5;\n                    parameters[\"keySize\"] = PRNG() % 1024;\n\n                    cryptofuzz::operation::KDF_SCRYPT op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_HKDF code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"KDF_HKDF\"):                {\n                    size_t numParts = 0;\n\n                    numParts++; /* modifier */\n                    numParts++; /* password */\n                    numParts++; /* salt */\n                    numParts++; /* info */\n\n                    const auto lengths = SplitLength(maxSize - 64, numParts);\n\n                    parameters[\"modifier\"] = getBuffer(lengths[0]);\n                    parameters[\"password\"] = getBuffer(lengths[1]);\n                    parameters[\"salt\"] = getBuffer(lengths[2]);\n                    parameters[\"info\"] = getBuffer(lengths[3]);\n                    parameters[\"keySize\"] = PRNG() % 17000;\n                    parameters[\"digestType\"] = getRandomDigest();\n\n                    cryptofuzz::operation::KDF_HKDF op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_TLS1_PRF code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"KDF_TLS1_PRF\"):                {\n                    size_t numParts = 0;\n\n                    numParts++; /* modifier */\n                    numParts++; /* secret */\n                    numParts++; /* seed */\n\n                    const auto lengths = SplitLength(maxSize - 64, numParts);\n\n                    parameters[\"modifier\"] = getBuffer(lengths[0]);\n                    parameters[\"secret\"] = getBuffer(lengths[1]);\n                    parameters[\"seed\"] = getBuffer(lengths[2]);\n                    parameters[\"keySize\"] = PRNG() % 1024;\n                    parameters[\"digestType\"] = getRandomDigest();\n\n                    cryptofuzz::operation::KDF_TLS1_PRF op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_PBKDF code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"KDF_PBKDF\"):                {\n                    size_t numParts = 0;\n\n                    numParts++; /* modifier */\n                    numParts++; /* password */\n                    numParts++; /* salt */\n\n                    const auto lengths = SplitLength(maxSize - 64, numParts);\n\n                    parameters[\"modifier\"] = getBuffer(lengths[0]);\n                    parameters[\"password\"] = getBuffer(lengths[1]);\n                    parameters[\"salt\"] = getBuffer(lengths[2]);\n                    parameters[\"iterations\"] = PRNG() % 5;\n                    parameters[\"keySize\"] = PRNG() % 1024;\n                    parameters[\"digestType\"] = getRandomDigest();\n\n                    cryptofuzz::operation::KDF_PBKDF op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_PBKDF1 code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"KDF_PBKDF1\"):                {\n                    size_t numParts = 0;\n\n                    numParts++; /* modifier */\n                    numParts++; /* password */\n                    numParts++; /* salt */\n\n                    const auto lengths = SplitLength(maxSize - 64, numParts);\n\n                    parameters[\"modifier\"] = getBuffer(lengths[0]);\n                    parameters[\"password\"] = getBuffer(lengths[1]);\n                    parameters[\"salt\"] = getBuffer(lengths[2]);\n                    parameters[\"iterations\"] = PRNG() % 5;\n                    parameters[\"keySize\"] = PRNG() % 1024;\n                    parameters[\"digestType\"] = getRandomDigest();\n\n                    cryptofuzz::operation::KDF_PBKDF op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_PBKDF2 code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"KDF_PBKDF2\"):                {\n                    size_t numParts = 0;\n\n                    numParts++; /* modifier */\n                    numParts++; /* password */\n                    numParts++; /* salt */\n\n                    const auto lengths = SplitLength(maxSize - 64, numParts);\n\n                    parameters[\"modifier\"] = getBuffer(lengths[0]);\n                    parameters[\"password\"] = getBuffer(lengths[1]);\n                    parameters[\"salt\"] = getBuffer(lengths[2]);\n                    parameters[\"iterations\"] = PRNG() % 5;\n                    parameters[\"keySize\"] = PRNG() % 1024;\n                    parameters[\"digestType\"] = getRandomDigest();\n\n                    cryptofuzz::operation::KDF_PBKDF2 op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_ARGON2 code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"KDF_ARGON2\"):                {\n                    size_t numParts = 0;\n\n                    numParts++; /* modifier */\n                    numParts++; /* password */\n                    numParts++; /* salt */\n\n                    const auto lengths = SplitLength(maxSize - 64, numParts);\n\n                    parameters[\"modifier\"] = getBuffer(lengths[0]);\n                    parameters[\"password\"] = getBuffer(lengths[1]);\n                    parameters[\"salt\"] = getBuffer(lengths[2]);\n                    parameters[\"type\"] = PRNG() % 3;\n                    parameters[\"threads\"] = PRNG() % 256;\n                    parameters[\"memory\"] = PRNG() % (64*1024);\n                    parameters[\"iterations\"] = PRNG() % 3;\n                    parameters[\"keySize\"] = PRNG() % 1024;\n\n                    cryptofuzz::operation::KDF_ARGON2 op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_SSH code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"KDF_SSH\"):                {\n                    size_t numParts = 0;\n\n                    numParts++; /* modifier */\n                    numParts++; /* key */\n                    numParts++; /* xcghash */\n                    numParts++; /* session_id */\n\n                    const auto lengths = SplitLength(maxSize - 64, numParts);\n\n                    parameters[\"modifier\"] = getBuffer(lengths[0]);\n                    parameters[\"key\"] = getBuffer(lengths[1]);\n                    parameters[\"xcghash\"] = getBuffer(lengths[2]);\n                    parameters[\"session_id\"] = getBuffer(lengths[3]);\n                    parameters[\"type\"] = getBuffer(1);\n                    parameters[\"keySize\"] = PRNG() % 1024;\n                    parameters[\"digestType\"] = getRandomDigest();\n\n                    cryptofuzz::operation::KDF_SSH op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_X963 code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"KDF_X963\"):                {\n                    size_t numParts = 0;\n\n                    numParts++; /* modifier */\n                    numParts++; /* secret */\n                    numParts++; /* info */\n\n                    const auto lengths = SplitLength(maxSize - 64, numParts);\n\n                    parameters[\"modifier\"] = getBuffer(lengths[0]);\n                    parameters[\"secret\"] = getBuffer(lengths[1]);\n                    parameters[\"info\"] = getBuffer(lengths[2]);\n                    parameters[\"keySize\"] = PRNG() % 1024;\n                    parameters[\"digestType\"] = getRandomDigest();\n\n                    cryptofuzz::operation::KDF_X963 op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_SP_800_108 code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"KDF_SP_800_108\"):                {\n                    size_t numParts = 0;\n\n                    numParts++; /* modifier */\n                    numParts++; /* secret */\n                    numParts++; /* salt */\n                    numParts++; /* label */\n\n                    const auto lengths = SplitLength(maxSize - 64, numParts);\n\n                    if ( getBool() == true ) {\n                        /* MAC = HMAC */\n                        parameters[\"mech\"][\"mode\"] = true;\n                        parameters[\"mech\"][\"type\"] = getRandomDigest();\n                    } else {\n                        /* MAC = CMAC */\n                        parameters[\"mech\"][\"mode\"] = false;\n                        parameters[\"mech\"][\"type\"] = getRandomCipher();\n                    }\n\n                    parameters[\"modifier\"] = getBuffer(lengths[0]);\n                    parameters[\"secret\"] = getBuffer(lengths[1]);\n                    parameters[\"salt\"] = getBuffer(lengths[2]);\n                    parameters[\"label\"] = getBuffer(lengths[3]);\n                    parameters[\"mode\"] = PRNG() % 3;\n                    parameters[\"keySize\"] = PRNG() % 17000;\n\n                    cryptofuzz::operation::KDF_SP_800_108 op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_SRTP code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"KDF_SRTP\"):                {\n                    parameters[\"modifier\"] = \"\";\n                    parameters[\"key\"] = getBuffer(PRNG() % 64);\n                    parameters[\"salt\"] = getBuffer(PRNG() % 20);\n                    parameters[\"kdr\"] = PRNG() % 256;\n                    parameters[\"index\"] = PRNG();\n                    parameters[\"key1Size\"] = PRNG() % (1024 * 1024);\n                    parameters[\"key2Size\"] = PRNG() % (1024 * 1024);\n                    parameters[\"key3Size\"] = PRNG() % (1024 * 1024);\n\n                    cryptofuzz::operation::KDF_SRTP op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate KDF_SRTCP code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"KDF_SRTCP\"):                {\n                    parameters[\"modifier\"] = \"\";\n                    parameters[\"key\"] = getBuffer(PRNG() % 64);\n                    parameters[\"salt\"] = getBuffer(PRNG() % 20);\n                    parameters[\"kdr\"] = PRNG() % 256;\n                    parameters[\"index\"] = PRNG();\n                    parameters[\"key1Size\"] = PRNG() % (1024 * 1024);\n                    parameters[\"key2Size\"] = PRNG() % (1024 * 1024);\n                    parameters[\"key3Size\"] = PRNG() % (1024 * 1024);\n\n                    cryptofuzz::operation::KDF_SRTCP op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate DH_GenerateKeyPair code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"DH_GenerateKeyPair\"):                {\n                    parameters[\"modifier\"] = getBuffer(PRNG() % 1000);\n                    parameters[\"prime\"] = getBignum();\n                    parameters[\"base\"] = getBignum();\n\n                    cryptofuzz::operation::DH_GenerateKeyPair op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate DH_Derive code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"DH_Derive\"):                {\n                    parameters[\"modifier\"] = getBuffer(PRNG() % 1000);\n                    parameters[\"prime\"] = getBignum();\n                    parameters[\"base\"] = getBignum();\n                    if ( Pool_DH_PublicKey.Have() && getBool() == true ) {\n                        parameters[\"pub\"] = Pool_DH_PublicKey.Get();\n                    } else {\n                        parameters[\"pub\"] = getBignum();\n                    }\n\n                    if ( Pool_DH_PrivateKey.Have() && getBool() == true ) {\n                        parameters[\"priv\"] = Pool_DH_PrivateKey.Get();\n                    } else {\n                        parameters[\"priv\"] = getBignum();\n                    }\n\n                    cryptofuzz::operation::DH_Derive op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_PrivateToPublic code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"BLS_PrivateToPublic\"):                {\n                    parameters[\"modifier\"] = getBuffer(PRNG() % 1000);\n                    parameters[\"curveType\"] = hint_ecc_mont(getRandomCurve());\n\n                    parameters[\"priv\"] = getBignum();\n\n                    cryptofuzz::operation::BLS_PrivateToPublic op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_PrivateToPublic_G2 code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"BLS_PrivateToPublic_G2\"):                {\n                    parameters[\"modifier\"] = getBuffer(PRNG() % 1000);\n                    parameters[\"curveType\"] = hint_ecc_mont(getRandomCurve());\n\n                    parameters[\"priv\"] = getBignum();\n\n                    cryptofuzz::operation::BLS_PrivateToPublic_G2 op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_Sign code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"BLS_Sign\"):                {\n                    parameters[\"modifier\"] = getBuffer(PRNG() % 1000);\n                    parameters[\"curveType\"] = hint_ecc_mont(getRandomCurve());\n                    const auto hashOrPoint = getBool();\n                    //const auto hashOrPoint = false;\n                    parameters[\"hashOrPoint\"] = hashOrPoint;\n                    if ( hashOrPoint == true ) {\n                        //parameters[\"cleartext\"] = getBuffer(PRNG() % 32);\n                        parameters[\"cleartext\"] = cryptofuzz::util::DecToHex(getBignum(true), (PRNG() % 64) * 2);\n                        parameters[\"point_v\"] = \"\";\n                        parameters[\"point_w\"] = \"\";\n                        parameters[\"point_x\"] = \"\";\n                        parameters[\"point_y\"] = \"\";\n                    } else {\n                        if ( getBool() && Pool_CurveBLSG2.Have() == true ) {\n                            const auto P = Pool_CurveBLSG2.Get();\n                            parameters[\"point_v\"] = GET_OR_BIGNUM(P.g2_v);\n                            parameters[\"point_w\"] = GET_OR_BIGNUM(P.g2_w);\n                            parameters[\"point_x\"] = GET_OR_BIGNUM(P.g2_x);\n                            parameters[\"point_y\"] = GET_OR_BIGNUM(P.g2_y);\n                        } else {\n                            parameters[\"point_v\"] = getBignum();\n                            parameters[\"point_w\"] = getBignum();\n                            parameters[\"point_x\"] = getBignum();\n                            parameters[\"point_y\"] = getBignum();\n                        }\n\n                        parameters[\"cleartext\"] = \"\";\n                    }\n                    parameters[\"dest\"] = getBool() ? getBuffer(PRNG() % 512) : get_BLS_predefined_DST();\n                    parameters[\"aug\"] = \"\";\n                    parameters[\"priv\"] = getBignum();\n\n                    cryptofuzz::operation::BLS_Sign op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_Verify code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"BLS_Verify\"):                {\n                    parameters[\"modifier\"] = getBuffer(PRNG() % 1000);\n\n                    if ( Pool_CurveBLSSignature.Have() == true ) {\n                        const auto P = Pool_CurveBLSSignature.Get();\n\n                        parameters[\"curveType\"] = hint_ecc_mont(P.curveID);\n                        parameters[\"hashOrPoint\"] = P.hashOrPoint;\n                        parameters[\"point_v\"] = GET_OR_BIGNUM(P.point_v);\n                        parameters[\"point_w\"] = GET_OR_BIGNUM(P.point_w);\n                        parameters[\"point_x\"] = GET_OR_BIGNUM(P.point_x);\n                        parameters[\"point_y\"] = GET_OR_BIGNUM(P.point_y);\n                        parameters[\"cleartext\"] = P.cleartext;\n                        parameters[\"dest\"] = P.dest;\n                        parameters[\"aug\"] = P.aug;\n                        parameters[\"pub_x\"] = GET_OR_BIGNUM(P.pub_x);\n                        parameters[\"pub_y\"] = GET_OR_BIGNUM(P.pub_y);\n                        parameters[\"sig_v\"] = GET_OR_BIGNUM(P.sig_v);\n                        parameters[\"sig_w\"] = GET_OR_BIGNUM(P.sig_w);\n                        parameters[\"sig_x\"] = GET_OR_BIGNUM(P.sig_x);\n                        parameters[\"sig_y\"] = GET_OR_BIGNUM(P.sig_y);\n                    } else {\n                        parameters[\"curveType\"] = hint_ecc_mont(getRandomCurve());\n                        const auto hashOrPoint = getBool();\n                        parameters[\"hashOrPoint\"] = hashOrPoint;\n                        if ( hashOrPoint == true ) {\n                            parameters[\"cleartext\"] = getBuffer(PRNG() % 32);\n                            parameters[\"point_v\"] = \"\";\n                            parameters[\"point_w\"] = \"\";\n                            parameters[\"point_x\"] = \"\";\n                            parameters[\"point_y\"] = \"\";\n                        } else {\n                            parameters[\"point_v\"] = getBignum();\n                            parameters[\"point_w\"] = getBignum();\n                            parameters[\"point_x\"] = getBignum();\n                            parameters[\"point_y\"] = getBignum();\n                            parameters[\"cleartext\"] = \"\";\n                        }\n                        parameters[\"dest\"] = getBool() ? getBuffer(PRNG() % 512) : get_BLS_predefined_DST();\n                        parameters[\"pub_x\"] = getBignum();\n                        parameters[\"pub_y\"] = getBignum();\n                        parameters[\"sig_v\"] = getBignum();\n                        parameters[\"sig_w\"] = getBignum();\n                        parameters[\"sig_x\"] = getBignum();\n                        parameters[\"sig_y\"] = getBignum();\n                    }\n\n                    cryptofuzz::operation::BLS_Verify op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_BatchSign code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"BLS_BatchSign\"):                {\n                    parameters[\"modifier\"] = \"\";\n\n                    //const size_t num = PRNG() % 100;\n                    //const size_t num = (PRNG() % 50) + 30;\n                    const size_t num = (PRNG() % 8) + 1;\n\n                    parameters[\"bf\"] = nlohmann::json::array();\n\n                    for (size_t i = 0; i < num; i++) {\n                        const auto P = Pool_CurveBLSG1.Get();\n\n                        nlohmann::json p;\n\n                        p[\"priv\"] = getBignum();\n                        p[\"g1_x\"] = P.g1_x;\n                        p[\"g1_y\"] = P.g1_y;\n\n                        parameters[\"bf\"].push_back(p);\n                    }\n\n                    cryptofuzz::operation::BLS_BatchSign op(parameters);\n                    op.Serialize(dsOut2);\n\n                    generateECCPoint();\n                }\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_BatchVerify code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"BLS_BatchVerify\"):                {\n                    parameters[\"modifier\"] = \"\";\n                    parameters[\"dest\"] = get_BLS_predefined_DST();\n\n                    std::vector<\n                        std::pair<\n                            std::array<std::string, 2>,\n                            std::array<std::string, 4>\n                        >\n                    > points;\n\n                    if ( Pool_BLS_BatchSignature.Have() == true ) {\n                        const auto sig = Pool_BLS_BatchSignature.Get();\n\n                        for (const auto& mp : sig.msgpub) {\n                            std::array<std::string, 2> g1;\n                            std::array<std::string, 4> g2;\n\n                            switch ( PRNG() % 3 ) {\n                                case    0:\n                                    {\n                                        const auto P = Pool_CurveBLSG1.Get();\n                                        g1 = {P.g1_x, P.g1_y};\n                                    }\n                                    break;\n                                case    1:\n                                    g1 = {mp.first.g1_x, mp.first.g1_y};\n                                    break;\n                                case    2:\n                                    g1 = {getBignum(), getBignum()};\n                                    break;\n                            }\n\n                            if ( (PRNG()%3) == 0 ) {\n                                const auto P2 = Pool_CurveBLSG2.Get();\n                                g2 = {P2.g2_v, P2.g2_w, P2.g2_x, P2.g2_y};\n                            } else {\n                                g2 = {mp.second.g2_v, mp.second.g2_w, mp.second.g2_x, mp.second.g2_y};\n                            }\n\n                            points.push_back({g1, g2});\n                        }\n\n                        parameters[\"bf\"] = nlohmann::json::array();\n\n                        std::shuffle(std::begin(points), std::end(points), rng);\n\n                        for (const auto& p : points) {\n                            nlohmann::json cur;\n                            cur[\"g1_x\"] = p.first[0];\n                            cur[\"g1_y\"] = p.first[1];\n\n                            cur[\"g2_v\"] = p.second[0];\n                            cur[\"g2_w\"] = p.second[1];\n                            cur[\"g2_x\"] = p.second[2];\n                            cur[\"g2_y\"] = p.second[3];\n                            parameters[\"bf\"].push_back(cur);\n                        }\n\n                        cryptofuzz::operation::BLS_BatchVerify op(parameters);\n                        op.Serialize(dsOut2);\n                    } else {\n                        goto end;\n                    }\n                }\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_IsG1OnCurve code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"BLS_IsG1OnCurve\"):                {\n                    parameters[\"modifier\"] = getBuffer(PRNG() % 1000);\n                    parameters[\"curveType\"] = hint_ecc_mont(getRandomCurve());\n\n                    if ( getBool() && Pool_CurveBLSG1.Have() == true ) {\n                        const auto P = Pool_CurveBLSG1.Get();\n                        parameters[\"g1_x\"] = GET_OR_BIGNUM(P.g1_x);\n                        parameters[\"g1_y\"] = GET_OR_BIGNUM(P.g1_y);\n                    } else {\n                        parameters[\"g1_x\"] = getBignum();\n                        parameters[\"g1_y\"] = getBignum();\n                    }\n\n                    cryptofuzz::operation::BLS_IsG1OnCurve op(parameters);\n                    op.Serialize(dsOut2);\n\n                    generateECCPoint();\n                }\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_IsG2OnCurve code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"BLS_IsG2OnCurve\"):                {\n                    parameters[\"modifier\"] = getBuffer(PRNG() % 1000);\n                    parameters[\"curveType\"] = hint_ecc_mont(getRandomCurve());\n\n                    if ( getBool() && Pool_CurveBLSG2.Have() == true ) {\n                        const auto P = Pool_CurveBLSG2.Get();\n                        parameters[\"g2_v\"] = GET_OR_BIGNUM(P.g2_v);\n                        parameters[\"g2_w\"] = GET_OR_BIGNUM(P.g2_w);\n                        parameters[\"g2_x\"] = GET_OR_BIGNUM(P.g2_x);\n                        parameters[\"g2_y\"] = GET_OR_BIGNUM(P.g2_y);\n                    } else {\n                        parameters[\"g2_v\"] = getBignum();\n                        parameters[\"g2_w\"] = getBignum();\n                        parameters[\"g2_x\"] = getBignum();\n                        parameters[\"g2_y\"] = getBignum();\n                    }\n\n                    cryptofuzz::operation::BLS_IsG2OnCurve op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}]}
{"messages": [{"role": "system", "content": "You are a code generator specialized in cryptographic libraries."}, {"role": "user", "content": "Generate BLS_GenerateKeyPair code for mutator.cpp"}, {"role": "assistant", "content": "            case    CF_OPERATION(\"BLS_GenerateKeyPair\"):                {\n                    parameters[\"modifier\"] = getBuffer(PRNG() % 1000);\n                    parameters[\"curveType\"] = hint_ecc_mont(getRandomCurve());\n                    parameters[\"ikm\"] = getBuffer(PRNG() % 512);\n                    parameters[\"info\"] = getBuffer(PRNG() % 512);\n\n                    cryptofuzz::operation::BLS_GenerateKeyPair op(parameters);\n                    op.Serialize(dsOut2);\n                }\n                break;\n"}]}
